# ExportsTxt.py

import os

def combine_files(project_dir, output_file):
    excluded_items = {'app_data.pkl', 'icons','dist', 'logger_config.py','logs','custom_posts.pkl','main.cpython-312-darwin.so','main.c','Tests', 'main.spec','setup.py', 'build', 'test', 'build/main', '.DS_Store', 'exportsTxt.py', 'test.py','utils', 'app.log', '__pycache__','venv', 'planningt.txt', 'SAVE base.txt', 'SAV 2.txt','SAV3.txt'}
    
    with open(output_file, "w", encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(project_dir):
            # Remove excluded directories
            dirs[:] = [d for d in dirs if d not in excluded_items]
            
            for file in files:
                if file in excluded_items:
                    continue
                
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding='utf-8') as infile:
                        relative_path = os.path.relpath(file_path, project_dir)
                        outfile.write(f"# {relative_path}\n\n")
                        outfile.write(infile.read())
                        outfile.write("\n\n")
                except UnicodeDecodeError:
                    print(f"Skipping file due to encoding issues: {file_path}")

project_directory = "/Users/arkane/Documents/Planning"
output_file_path = "/Users/arkane/Documents/Planning/planningt.txt"
combine_files(project_directory, output_file_path)


# main.py

# © 2024 HILAL Arkane. Tous droits réservés.
# main.py

import sys
import os
import logging

from logger_config import setup_logger
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QPalette, QColor, QIcon
from PyQt6.QtCore import QTimer, QThread, pyqtSignal
from gui.main_window import MainWindow
from gui.splash_screen import SplashScreen
from core.Constantes.models import Doctor, CAT, create_default_post_configuration
from core.Constantes.data_persistence import DataPersistence

def resource_path(relative_path):
    """Get the absolute path to the resource, works for development and for PyInstaller."""
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

def set_application_style(app):
    app.setStyle("Fusion")
    
    # Palette de couleurs
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(245, 245, 250))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(240, 240, 245))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 225))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Text, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Button, QColor(225, 225, 230))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Link, QColor(85, 125, 160))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(85, 125, 160))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))

    app.setPalette(palette)

    # Feuille de style CSS
    app.setStyleSheet("""
    QMainWindow, QWidget {
        background-color: #F5F5FA;
        color: #323232;
        font-family: 'Helvetica Neue', 'Arial', sans-serif;
        font-size: 13px;
    }
    QPushButton {
        background-color: #3C6EA0;
        color: white;
        border: none;
        padding: 8px 18px;
        border-radius: 4px;
        font-weight: bold;
    }
    QPushButton:hover {
        background-color: #508CBB;
    }
    QPushButton:pressed {
        background-color: #2A5280;
    }
    QTableWidget, QTreeWidget, QListWidget {
        background-color: white;
        alternate-background-color: #F8F8FA;
    }
    QHeaderView::section {
        background-color: #E6E6EB;
        color: #323232;
        padding: 5px;
        border: none;
        border-right: 1px solid #D0D0D8;
        border-bottom: 1px solid #D0D0D8;
        font-weight: bold;
    }
    QTabWidget::pane {
        border: 1px solid #D0D0D8;
        background-color: #F5F5FA;
    }
    QTabBar::tab {
        background-color: #E6E6EB;
        color: #323232;
        padding: 8px 16px;
        border: 1px solid #D0D0D8;
        border-bottom: none;
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
    }
    QTabBar::tab:selected {
        background-color: #F5F5FA;
        border-bottom: 2px solid #557DA0;
    }
    QTabBar::tab:hover:!selected {
        background-color: #F2F2F5;
    }
    QComboBox, QDateEdit {
        background-color: #FFFFFF;
        color: #323232;
        border: 1px solid #D0D0D8;
        padding: 6px;
        border-radius: 6px;
    }
    QScrollBar:vertical {
        background-color: #F2F2F5;
        width: 12px;
    }
    QScrollBar::handle:vertical {
        background-color: #C0C0C8;
        border-radius: 6px;
    }
    QScrollBar::handle:vertical:hover {
        background-color: #A0A0A8;
    }
    QGroupBox {
        border: 1px solid #D0D0D8;
        border-radius: 6px;
        padding-top: 10px;
    }
    QGroupBox::title {
        color: #557DA0;
        font-weight: bold;
    }
    """)

class LoaderThread(QThread):
    update_signal = pyqtSignal(str)
    finished_signal = pyqtSignal(tuple)

    def run(self):
        self.update_signal.emit("Chargement des données...")
        data_persistence = DataPersistence()
        doctors, cats, post_configuration = data_persistence.load_data()

        if not doctors and not cats:
            self.update_signal.emit("Création des données par défaut...")
            doctors = [
                Doctor("Dr. Smith", 2),
                Doctor("Dr. Johnson", 1),
                Doctor("Dr. Williams", 2),
            ]
            cats = [
                CAT("CAT 1"),
                CAT("CAT 2"),
            ]

        if post_configuration is None:
            self.update_signal.emit("Création de la configuration par défaut...")
            post_configuration = create_default_post_configuration()

        self.update_signal.emit("Initialisation de l'interface...")
        self.finished_signal.emit((doctors, cats, post_configuration))


def main():
    logger = setup_logger()
    app = QApplication(sys.argv)
    set_application_style(app)

    splash = SplashScreen()
    splash.show()

    loader_thread = LoaderThread()
    loader_thread.update_signal.connect(splash.update_message)
    loader_thread.finished_signal.connect(lambda data: on_load_finished(data, splash))
    loader_thread.start()

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    sys.exit(app.exec())

def on_load_finished(data, splash):
    doctors, cats, post_configuration = data
    window = MainWindow(doctors, cats, post_configuration)
    
    def show_main_window():
        splash.finish(window)  # Ceci fermera le splash screen
        window.show()

    QTimer.singleShot(1000, show_main_window)  # Attendre au moins 3 secondes

if __name__ == "__main__":
    main()

# core/__init__.py

# © 2024 HILAL Arkane. Tous droits réservés.

from .Constantes.models import *
from .Generator.planning_generator import PlanningGenerator
from .Analyzer.pre_analyzer import PlanningPreAnalyzer
from .Constantes.constraints import PlanningConstraints

__all__ = ['PlanningGenerator']

# core/utils.py

# core/utils.py
from typing import Union
from datetime import datetime
import sys
import os

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

def get_post_period(post_or_slot) -> int:
    """
    Détermine la période d'un poste (0: Matin, 1: Après-midi, 2: Soir)
    basé sur la plage horaire majoritaire.
    """
    # Pour les postes standards (strings)
    if isinstance(post_or_slot, str):
        if post_or_slot in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return 0
        elif post_or_slot in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1
        else:
            return 2
    
    # Pour les postes avec horaires
    else:
        start_hour = post_or_slot.start_time.hour
        end_hour = post_or_slot.end_time.hour
        
        # Si le poste traverse minuit
        if end_hour < start_hour:
            hours_range = list(range(start_hour, 24)) + list(range(0, end_hour + 1))
        else:
            hours_range = list(range(start_hour, end_hour + 1))
        
        # Compte des heures dans chaque période
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        # Retourne la période avec le plus d'heures
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        if max_hours == morning_hours:
            return 0
        elif max_hours == afternoon_hours:
            return 1
        else:
            return 2

# core/Generator/planning_generator.py

# core/planning_generator.py

"""
planning_generator.py
Module de génération du planning basé sur les résultats de la pré-analyse
"""

import logging
import random
from datetime import datetime, date, timedelta, time
from typing import List, Dict, Optional, Tuple, Union
import math
from core.Constantes.models import (
    Doctor, CAT, Planning, DayPlanning, TimeSlot, PostManager, PostConfig,SpecificPostConfig,
    ALL_POST_TYPES, WEEKDAY_COMBINATIONS, WEEKEND_COMBINATIONS
)
from core.Constantes.constraints import PlanningConstraints
from core.Analyzer.pre_analyzer import PlanningPreAnalyzer
from core.Constantes.data_persistence import DataPersistence
from core.Constantes.day_type import DayType
from core.Constantes.custom_post import CustomPost
from collections import defaultdict


from workalendar.europe import France


logger = logging.getLogger(__name__)

class PlanningGenerator:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.constraints = PlanningConstraints()
        self.cal = France()
        self.post_manager = PostManager()
        
        # Chargement des postes personnalisés
        data_persistence = DataPersistence()
        self.custom_posts = data_persistence.load_custom_posts()
        
        # Vérification que tous les postes sont bien des objets CustomPost
        invalid_posts = []
        for name, post in list(self.custom_posts.items()):
            if not isinstance(post, CustomPost):
                try:
                    self.custom_posts[name] = CustomPost.from_dict(post if isinstance(post, dict) else post.__dict__)
                except Exception as e:
                    logger.error(f"Impossible de convertir le poste {name}: {e}")
                    invalid_posts.append(name)
        
        # Supprimer les postes invalides
        for name in invalid_posts:
            del self.custom_posts[name]
        
        logger.info(f"Postes personnalisés chargés: {list(self.custom_posts.keys())}")
        
        # Initialisation du suivi de distribution 
        self.current_distribution = {
            "weekend": {
                person.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0,  # NL weekend
                    "NAs": 0, "NAd": 0,  # NA weekend
                    "NMs": 0, "NMd": 0,  # NM weekend
                    "weekend_groups": {}  # Groupes weekend
                } for person in doctors + cats  # Ajouter aussi les CAT
            },
            "weekday": {
                person.name: {
                    "NL": 0,      # NL semaine
                    "weekday_groups": {}  # Groupes semaine
                } for person in doctors + cats  # Ajouter aussi les CAT
            }
        }
    def _initialize_planning_days(self, planning: Planning):
        logger.info("\nINITIALISATION DU PLANNING")
        logger.info("=" * 80)
        

        planning.days = []
        current_date = planning.start_date

        while current_date <= planning.end_date:
            # Utiliser DayTypeDetector pour déterminer le type de jour
            day_type = DayType.get_day_type(current_date, self.cal)
            
            # Nouveau : Traitement spécial pour les samedis de pont
            is_bridge_saturday = (current_date.weekday() == 5 and 
                                DayType.is_bridge_day(current_date, self.cal))
            
            # Déterminer la configuration à utiliser
            config_to_use = None
            
            # Modification : Utiliser la configuration sunday_holiday pour les samedis de pont
            if day_type == "sunday_holiday" or is_bridge_saturday:
                config_to_use = self.post_configuration.sunday_holiday
                logger.debug(f"{current_date} est un jour férié/pont - force config sunday_holiday")
            elif day_type == "saturday" and not is_bridge_saturday:
                config_to_use = self.post_configuration.saturday
            else:
                config_to_use = self.post_configuration.weekday

            # Vérifier s'il existe une configuration spécifique pour cette date
            specific_config = self._get_specific_config(current_date, day_type)
            if specific_config:
                config_to_use = specific_config

            # Créer l'instance du jour avec le statut correct
            day = DayPlanning(
                date=current_date,
                slots=[],
                is_weekend=(day_type in ["saturday", "sunday_holiday"]),
                is_holiday_or_bridge=(day_type == "sunday_holiday" or is_bridge_saturday)  # Modification ici
            )

            # Créer les slots en tenant compte du type spécial de jour
            if is_bridge_saturday:
                # Pour un samedi de pont, on traite comme un jour férié
                self._create_standard_slots(day, config_to_use, "sunday_holiday")
            else:
                self._create_standard_slots(day, config_to_use, day_type)
                
            self._create_custom_slots(day, config_to_use, day_type)

            planning.days.append(day)
            current_date += timedelta(days=1)

        self._log_slots_summary(planning)

    def _get_specific_config(self, current_date: date, day_type: str) -> Optional[Dict]:
        """Vérifie s'il existe une configuration spécifique pour cette date"""
        if hasattr(self.post_configuration, 'specific_configs'):
            normalized_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }[day_type]
            
            for config in self.post_configuration.specific_configs:
                if (config.start_date <= current_date <= config.end_date and
                    config.apply_to == normalized_type):
                    return config.post_counts
        return None


    def _get_config_from_analysis(self, current_date: date, day_type: str) -> Dict:
        """
        Récupère la configuration à utiliser pour un jour donné.
        """
        # D'abord vérifier si c'est un jour de pont
        if DayType.is_bridge_day(current_date, self.cal):
            logger.debug(f"{current_date} : jour de pont - utilisation config sunday_holiday")
            return self.post_configuration.sunday_holiday
            
        # Ensuite vérifier les configurations spécifiques
        if hasattr(self.post_configuration, 'specific_configs'):
            normalized_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }[day_type]
            
            for config in self.post_configuration.specific_configs:
                if (config.start_date <= current_date <= config.end_date and
                    config.apply_to == normalized_type):
                    logger.debug(f"{current_date} : configuration spécifique trouvée")
                    return config.post_counts
                    
        # Sinon utiliser la configuration standard
        if day_type == "sunday_holiday":
            logger.debug(f"{current_date} : dimanche/férié standard")
            return self.post_configuration.sunday_holiday
        elif day_type == "saturday":
            return self.post_configuration.saturday
        else:
            return self.post_configuration.weekday
        
    def _normalize_day_type(self, day_type: str) -> str:
        """
        Normalise le type de jour pour la comparaison avec les configurations spécifiques.
        """
        mapping = {
            "weekday": "Semaine",
            "saturday": "Samedi",
            "sunday_holiday": "Dimanche/Férié"
        }
        return mapping.get(day_type, day_type)

    def _create_standard_slots(self, day: DayPlanning, config: Dict, day_type: str):
        """
        Crée les slots standards pour un jour selon la configuration.
        """
        

        # Pour les jours de pont, on force l'utilisation de la config sunday_holiday
        if DayType.is_bridge_day(day.date, self.cal):
            logger.debug(f"{day.date} est un jour de pont - force config sunday_holiday")
            config = self.post_configuration.sunday_holiday

        for post_type, count in config.items():
            # Ignorer les postes personnalisés
            if post_type in self.custom_posts:
                continue

            total = count.total if isinstance(count, PostConfig) else count
            
            if total > 0:
                post_details = self.post_manager.get_post_details(post_type, day_type)
                
                if not post_details:
                    logger.warning(f"Pas de détails trouvés pour le poste {post_type}")
                    continue

                # Traitement spécial pour NL
                if post_type == "NL":
                    if day_type == "sunday_holiday" or (
                        day.date.weekday() == 4 and 
                        not DayType.get_day_type(day.date + timedelta(days=1), self.cal) == "sunday_holiday"
                    ) or (
                        day.date.weekday() == 5 and 
                        not DayType.get_day_type(day.date, self.cal) == "sunday_holiday"
                    ):
                        logger.debug(f"  - Création de {total} slot(s) {post_type}")
            
                
                # Création effective des slots
                for _ in range(total):
                    slot = TimeSlot(
                        start_time=datetime.combine(day.date, post_details['start_time']),
                        end_time=datetime.combine(
                            day.date + timedelta(days=1) if post_details['end_time'] < post_details['start_time'] else day.date,
                            post_details['end_time']
                        ),
                        site=post_details['site'],
                        slot_type="Consultation" if "Visite" not in post_details['site'] else "Visite",
                        abbreviation=post_type,
                        assignee=None
                    )
                    day.slots.append(slot)
                    
    def _create_custom_slots(self, day: DayPlanning, config: Dict, day_type: str):
        """Crée les slots pour les postes personnalisés"""
        if not self.custom_posts:
            return

        for post_name, custom_post in self.custom_posts.items():
            # Vérifier si le poste doit être créé pour ce type de jour
            if day_type in custom_post.day_types:
                # Récupérer la configuration pour ce jour
                configured_count = 0
                if isinstance(config, SpecificPostConfig):
                    configured_count = config.post_counts.get(post_name, 0)
                else:
                    configured_count = config.get(post_name, PostConfig()).total

                # Pour les samedis, créer le nombre de slots configuré dans post_configuration
                if day_type == "saturday":
                    configured_count = self.post_configuration.saturday.get(post_name, PostConfig()).total
                elif day_type == "sunday_holiday":
                    configured_count = self.post_configuration.sunday_holiday.get(post_name, PostConfig()).total

                logger.debug(f"Création de {configured_count} slots {post_name} pour {day.date} ({day_type})")

                # Créer les slots
                for _ in range(configured_count):
                    slot = TimeSlot(
                        start_time=datetime.combine(day.date, custom_post.start_time),
                        end_time=datetime.combine(
                            day.date + timedelta(days=1 if custom_post.end_time < custom_post.start_time else 0),
                            custom_post.end_time
                        ),
                        site="Personnalisé",
                        slot_type=custom_post.statistic_group.strip() if custom_post.statistic_group else "Personnalisé",
                        abbreviation=post_name,
                        assignee=None
                    )
                    day.slots.append(slot)

    def _create_slot(self, day_date: date, post_details: Dict, post_type: str) -> TimeSlot:
        """
        Crée un slot de planning à partir des détails du poste.
        
        Args:
            day_date (date): Date du jour
            post_details (Dict): Détails du poste (horaires, site, etc)
            post_type (str): Type de poste (NL, ML, etc)
            
        Returns:
            TimeSlot: Le slot créé
        """
        # Déterminer si le slot traverse minuit
        start_time = datetime.combine(day_date, post_details['start_time'])
        end_time = datetime.combine(
            day_date + timedelta(days=1) if post_details['end_time'] < post_details['start_time'] else day_date,
            post_details['end_time']
        )
        
        # Déterminer le type de slot (Consultation ou Visite)
        slot_type = "Consultation" if "Visite" not in post_details['site'] else "Visite"
        
        return TimeSlot(
            start_time=start_time,
            end_time=end_time,
            site=post_details['site'],
            slot_type=slot_type,
            abbreviation=post_type,
            assignee=None
        )

    def _log_slots_summary(self, planning: Planning):
        """
        Affiche un résumé détaillé des slots qui ont été créés.
        """
        logger.info("\nRÉSUMÉ DES SLOTS INITIALISÉS")
        logger.info("=" * 80)

        # Structure pour compter les slots par type de jour
        counts = {
            "weekday": defaultdict(int),    # Jours de semaine
            "saturday": defaultdict(int),    # Samedis normaux
            "sunday_holiday": defaultdict(int)  # Dimanches/Fériés/Ponts
        }

        # Les NL nécessitent un traitement spécial
        nl_slots = {
            "weekday": 0,   # Lundi-Jeudi
            "nlv": 0,       # Vendredi
            "nls": 0,       # Samedi normal
            "nld": 0        # Dimanche/Férié/Pont
        }

        # Compter les slots existants
        for day in planning.days:
            for slot in day.slots:
                if slot.abbreviation == "NL":
                    if day.is_holiday_or_bridge:
                        nl_slots["nld"] += 1
                    elif day.is_weekend and not day.is_holiday_or_bridge:
                        nl_slots["nls"] += 1
                    elif day.date.weekday() == 4:  # Vendredi
                        nl_slots["nlv"] += 1
                    else:
                        nl_slots["weekday"] += 1
                else:
                    if day.is_holiday_or_bridge:
                        counts["sunday_holiday"][slot.abbreviation] += 1
                    elif day.is_weekend and not day.is_holiday_or_bridge:
                        counts["saturday"][slot.abbreviation] += 1
                    else:
                        counts["weekday"][slot.abbreviation] += 1

        # Affichage des résultats
        for day_type, label in [
            ("weekday", "SEMAINE"),
            ("saturday", "SAMEDI"),
            ("sunday_holiday", "DIMANCHE/FÉRIÉ")
        ]:
            logger.info(f"\n{label}")
            logger.info("-" * 40)

            # Afficher d'abord les NL
            if day_type == "weekday":
                logger.info(f"NL (lundi-jeudi)   : {nl_slots['weekday']:3d} slots")
                logger.info(f"NL (vendredi)      : {nl_slots['nlv']:3d} slots")
            elif day_type == "saturday":
                logger.info(f"NL  : {nl_slots['nls']:3d} slots")
            else:
                logger.info(f"NL  : {nl_slots['nld']:3d} slots")

            # Afficher les autres postes triés
            if counts[day_type]:
                logger.info("\nAutres postes:")
                for post_type, count in sorted(counts[day_type].items()):
                    logger.info(f"{post_type:4}: {count:3d} slots")

        # Afficher les totaux NL
        logger.info("\nTOTAUX NL PAR CATÉGORIE:")
        logger.info("-" * 40)
        logger.info(f"NLv (Vendredi)        : {nl_slots['nlv']:3d} slots")
        logger.info(f"NLs (Samedi)          : {nl_slots['nls']:3d} slots")
        logger.info(f"NLd (Dimanche/Férié)  : {nl_slots['nld']:3d} slots")
        total_nl = sum(nl_slots.values())
        logger.info(f"Total NL              : {total_nl:3d} slots")

        # Statistiques NLd
        logger.info("\nSTATISTIQUES FINALES")
        logger.info("-" * 40)
        nld_days = nl_slots["nld"] // 2  # Car 2 slots par jour
        logger.info(f"Nombre total de jours NLd   : {nld_days}")
        logger.info(f"Nombre total de slots NLd   : {nl_slots['nld']}")

        # Vérification avec la pré-analyse
        if hasattr(planning, 'pre_analysis_results') and planning.pre_analysis_results is not None:
            target_nlw = planning.pre_analysis_results.get('adjusted_posts', {}).get('weekend_groups', {}).get('NLw', 0)
            if target_nlw:
                weekend_nl = nl_slots['nls'] + nl_slots['nld'] + nl_slots['nlv']
                logger.info(f"Requis selon pré-analyse    : {target_nlw}")
                if weekend_nl != target_nlw:
                    logger.warning(f"ATTENTION: Différence entre slots créés ({weekend_nl}) et requis ({target_nlw})")    
    def is_bridge_day(self, day: date) -> bool:
        """Détermine si une date est un jour de pont"""
        # 1) Lundi avant un mardi férié
        if day.weekday() == 0 and self.cal.is_holiday(day + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if day.weekday() in [4, 5] and self.cal.is_holiday(day - timedelta(days=1 if day.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if day.weekday() == 5 and self.cal.is_holiday(day - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= day.weekday() <= 4:
            if (self.cal.is_holiday(day - timedelta(days=1)) and 
                self.cal.is_holiday(day + timedelta(days=1))):
                return True
        
        return False


    def generate_planning(self, start_date: date, end_date: date) -> Optional[Planning]:
        try:
            logger.info("=" * 80)
            logger.info(f"GÉNÉRATION DU PLANNING: {start_date} - {end_date}")
            logger.info("=" * 80)
            
            planning = Planning(start_date, end_date)
            
            # Initialiser les jours du planning
            self._initialize_planning_days(planning)
            
            # Pré-analyse
            pre_analyzer = PlanningPreAnalyzer(self.doctors, self.cats, self.post_configuration)
            pre_analyzer.set_date_range(start_date, end_date)
            pre_analysis_results = pre_analyzer.analyze()
            planning.set_pre_analysis_results(pre_analysis_results)
            
            # Distribution des weekend
            logger.info("\nDISTRIBUTION DES WEEKEND")
            weekend_success = self.distribute_weekend(planning)
            if not weekend_success:
                logger.warning("Distribution des weekend incomplète")
            
            return planning
        
            
            
        except Exception as e:
            logger.error(f"Erreur lors de la génération du planning: {e}")
            return None
          
            
    def distribute_weekend(self, planning: Planning) -> bool:
        """Distribution complète des postes de weekend"""
        pre_analysis = planning.pre_analysis_results
        
        try:
            # 1. Distribution des NL weekend
            logger.info("\nDISTRIBUTION NL WEEKEND")
            nl_success = self.distribute_nlw(planning, pre_analysis)
            if not nl_success:
                logger.warning("Distribution des NL weekend incomplète")
            
            # 2. Distribution des NAMw
            logger.info("\nDISTRIBUTION NAMw")
            if not self.distribute_namw(planning, pre_analysis):
                logger.warning("Distribution NAMw incomplète")
                return False
            
            # 3. Distribution des combinaisons aux CAT
            logger.info("\nDISTRIBUTION COMBINAISONS CAT WEEKEND")
            cat_success = self._distribute_cat_weekend_combinations(planning)
            if not cat_success:
                logger.warning("Distribution des combinaisons CAT weekend incomplète")
                return False

            # 4. Distribution des combinaisons aux médecins
            logger.info("\nDISTRIBUTION COMBINAISONS MÉDECINS WEEKEND")
            med_success = self._distribute_doctor_weekend_combinations(planning)
            if not med_success:
                logger.warning("Distribution des combinaisons médecins weekend incomplète")
                return False
                    
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution weekend: {e}", exc_info=True)
            return False
                
    def distribute_weekday(self, planning: Planning) -> bool:
        """Distribution complète des postes de semaine"""
        pre_analysis = planning.pre_analysis_results
        
        try:
            # 1. Distribution des NL semaine (hors vendredi)
            logger.info("\nDISTRIBUTION NL SEMAINE")
            if not self.distribute_weekday_nl(planning, pre_analysis):
                return False
            
            # 2. Distribution des NC+NA+NM semaine
            logger.info("\nDISTRIBUTION NANM SEMAINE")
            if not self.distribute_weekday_nanm(planning, pre_analysis):
                return False
                
            # 3. Distribution des combinaisons de postes semaine
            logger.info("\nDISTRIBUTION COMBINAISONS SEMAINE")
            if not self.distribute_weekday_combinations(planning, pre_analysis):
                return False
                
            # 4. Distribution des autres groupes semaine
            logger.info("\nDISTRIBUTION AUTRES GROUPES SEMAINE")
            if not self.distribute_weekday_groups(planning, pre_analysis):
                return False
                
            # 5. Distribution des postes personnalisés semaine
            logger.info("\nDISTRIBUTION POSTES PERSONNALISÉS SEMAINE")
            if not self.distribute_weekday_custom_posts(planning, pre_analysis):
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution semaine: {e}")
            return False

    
    def distribute_nlw(self, planning: Planning, pre_analysis) -> bool:
        """Distribution des NL weekend en utilisant directement les résultats du pre_analyzer"""
        try:
            logger.info("\nDISTRIBUTION DES NL WEEKEND")
            logger.info("=" * 80)
            
            # 1. Récupération des totaux pour les CAT depuis pre_analysis["cat_posts"]
            cat_count = len(self.cats)
            cat_nlv = pre_analysis["cat_posts"]["weekday"].get("NLv", 0) 
            cat_nls = pre_analysis["cat_posts"]["saturday"].get("NL", 0)
            cat_nld = pre_analysis["cat_posts"]["sunday_holiday"].get("NL", 0)
            
            cat_totals = {
                "NLv": cat_nlv * cat_count,
                "NLs": cat_nls * cat_count,
                "NLd": cat_nld * cat_count
            }
            cat_total = sum(cat_totals.values())
            
            # 2. Récupération des totaux ajustés pour les médecins depuis pre_analysis["adjusted_posts"]
            med_nlv = pre_analysis["adjusted_posts"]["weekday_groups"]["NLv"]
            med_nlw = pre_analysis["adjusted_posts"]["weekend_groups"]["NLw"]
            
            # Les NLs et NLd sont déjà calculés dans pre_analysis
            med_nls = pre_analysis["adjusted_posts"]["saturday"]["NL"]
            med_nld = pre_analysis["adjusted_posts"]["sunday_holiday"]["NL"]
            
            med_totals = {
                "NLv": med_nlv,
                "NLs": med_nls,
                "NLd": med_nld
            }
            med_total = sum(med_totals.values())
            
            # Log des totaux à distribuer
            logger.info("\nTOTAUX CAT À DISTRIBUER:")
            logger.info(f"NLv: {cat_totals['NLv']} ({cat_nlv}/CAT)")
            logger.info(f"NLs: {cat_totals['NLs']} ({cat_nls}/CAT)")
            logger.info(f"NLd: {cat_totals['NLd']} ({cat_nld}/CAT)")
            logger.info(f"Total: {cat_total}")
            
            logger.info("\nTOTAUX MÉDECINS À DISTRIBUER:")
            logger.info(f"NLv: {med_totals['NLv']}")
            logger.info(f"NLs: {med_totals['NLs']}")
            logger.info(f"NLd: {med_totals['NLd']}")
            logger.info(f"Total NLw: {med_nlw}")
            
            # Vérification de la cohérence des totaux
            if med_nlw != sum(med_totals.values()):
                logger.error("Incohérence dans les totaux médecins: "
                            f"NLw ({med_nlw}) ≠ NLv+NLs+NLd ({sum(med_totals.values())})")
                return False
                
            # Créer les slots une seule fois et les partager
            nl_slots = self._create_nl_distribution_map(planning)
            
            # Vérification de disponibilité
            for nl_type in ["NLv", "NLs", "NLd"]:
                total_needed = cat_totals[nl_type] + med_totals[nl_type]
                available = len(nl_slots[nl_type])
                
                logger.info(f"\nVérification {nl_type}:")
                logger.info(f"Requis : {total_needed} slots")
                logger.info(f"Disponible : {available} slots")
                
                if available < total_needed:
                    logger.error(f"Pas assez de slots {nl_type} disponibles.")
                    return False
                    
            # Distribution aux CAT avec les slots partagés
            if not self._distribute_nl_to_cats(planning, 
                                            cat_totals["NLv"],
                                            cat_totals["NLs"], 
                                            cat_totals["NLd"],
                                            nl_slots):  # Nouveau paramètre
                return False
                
            # Distribution aux médecins - Corrigé pour passer nl_slots
            if not self._distribute_nl_to_doctors(planning,
                                                med_totals["NLv"],
                                                med_totals["NLs"],
                                                med_totals["NLd"],
                                                pre_analysis):  # Retirer nl_slots ici
                logger.error("Échec de la distribution des NL aux médecins")
                return False
                
            # 7. Vérification finale
            verification_data = {
                'cats': {
                    'total': cat_total,
                    'NLv': cat_totals["NLv"],
                    'NLs': cat_totals["NLs"],
                    'NLd': cat_totals["NLd"]
                },
                'doctors': {
                    'total': med_nlw,
                    'NLv': med_totals["NLv"],
                    'NLs': med_totals["NLs"],
                    'NLd': med_totals["NLd"]
                }
            }
            
            self._verify_nl_distribution(planning, verification_data)
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution NLw: {e}", exc_info=True)
            return False

    def _create_nl_distribution_map(self, planning):
        """
        Crée un dictionnaire organisé des slots NL déjà créés
        Assure que seuls les Vendredis, Samedis, et Dimanches/Fériés/Ponts soient inclus
        """
        nl_slots = {
            "NLv": [],  # UNIQUEMENT les vendredis non fériés/pont
            "NLs": [],  # UNIQUEMENT les samedis non fériés/pont
            "NLd": []   # Dimanches + tous les jours fériés/pont
        }

        for day in planning.days:
            # Ne traiter que les slots NL non assignés
            nl_slots_day = [slot for slot in day.slots if slot.abbreviation == "NL" and not slot.assignee]
            
            # Déterminer le type de jour précisément
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)
            weekday = day.date.weekday()

            # Distribution stricte selon le type de jour
            if weekday == 4 and not (day_type == "sunday_holiday" or is_bridge):
                # Uniquement les vendredis normaux
                nl_slots["NLv"].extend((day, slot) for slot in nl_slots_day)
            
            elif weekday == 5 and not (day_type == "sunday_holiday" or is_bridge):
                # Uniquement les samedis normaux
                nl_slots["NLs"].extend((day, slot) for slot in nl_slots_day)
            
            elif weekday == 6 or day_type == "sunday_holiday" or is_bridge:
                # Dimanches + tous les jours fériés/pont
                nl_slots["NLd"].extend((day, slot) for slot in nl_slots_day)


        # Log de vérification
        logger.debug("\nVérification des slots NL collectés:")
        for nl_type, slots in nl_slots.items():
            logger.debug(f"{nl_type}: {len(slots)} slots")

        return nl_slots
    
    

    def _distribute_nl_to_cats(self, planning: Planning, nlv_total: int, nls_total: int, nld_total: int, nl_slots: Dict) -> bool:
        try:
            logger.info("Distribution NL aux CAT")
            cat_counts = {
                cat.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0, "total": 0
                } for cat in self.cats
            }

            # Calculer les quotas par CAT
            cat_count = len(self.cats)
            quotas = {
                "NLv": nlv_total // cat_count,
                "NLs": nls_total // cat_count,
                "NLd": nld_total // cat_count
            }

            # Priorité à la distribution équitable
            for nl_type in ["NLv", "NLs", "NLd"]:
                quota = quotas[nl_type]
                available_slots = nl_slots[nl_type].copy()
                random.shuffle(available_slots)

                # Première passe : distribution égale garantie
                for cat in self.cats:
                    slots_needed = quota
                    slots_assigned = 0
                    
                    while slots_assigned < slots_needed and available_slots:
                        day, slot = available_slots[0]
                        if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                            slot.assignee = cat.name
                            cat_counts[cat.name][nl_type] += 1
                            cat_counts[cat.name]["total"] += 1
                            available_slots.pop(0)
                            slots_assigned += 1
                        else:
                            available_slots.pop(0)
                            continue

                    if slots_assigned < slots_needed:
                        logger.warning(f"Impossible d'atteindre le quota {nl_type} pour {cat.name} "
                                    f"({slots_assigned}/{slots_needed})")

            # Vérification des totaux
            total_assigned = sum(counts["total"] for counts in cat_counts.values())
            total_expected = sum(quotas.values()) * cat_count

            if total_assigned != total_expected:
                logger.warning(f"Distribution inégale des NL pour les CAT: "
                            f"Attendu {total_expected}, Obtenu {total_assigned}")

            return True

        except Exception as e:
            logger.error(f"Erreur distribution CAT: {e}", exc_info=True)
            return False

    def _distribute_nl_to_doctors(self, planning: Planning, nlv_total: int, nls_total: int, nld_total: int, pre_analysis: dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NL AUX MÉDECINS")
            logger.info("=" * 60)

            # Vérifier et logger les intervalles exacts
            nlw_distribution = pre_analysis["ideal_distribution"]
            max_plein_temps = 4  # Fixé d'après la pré-analyse
            max_mi_temps = 2     # Fixé d'après la pré-analyse
            
            logger.info("Intervalles de distribution NL:")
            logger.info(f"Plein temps: [3-{max_plein_temps}]")
            logger.info(f"Mi-temps: [1-{max_mi_temps}]")

            # Initialisation des compteurs
            doctor_nl_counts = {
                doctor.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0,
                    "total": 0,
                    "max": max_plein_temps if doctor.half_parts == 2 else max_mi_temps,
                    "min": 3 if doctor.half_parts == 2 else 1
                } for doctor in self.doctors
            }

            # Slots disponibles
            available_slots = self._create_nl_distribution_map(planning)
            logger.info("\nSlots disponibles au début:")
            for nl_type, slots in available_slots.items():
                logger.info(f"{nl_type}: {len(slots)} slots")

            # Liste des médecins dans un ordre aléatoire
            all_doctors = self.doctors.copy()
            random.shuffle(all_doctors)
            max_failed_attempts = 5

            # Phase 1: Distribution du minimum à tous les médecins
            logger.info("\nPHASE 1: Distribution du minimum à tous les médecins")
            logger.info("=" * 50)

            for doctor in all_doctors:
                min_nlw = doctor_nl_counts[doctor.name]["min"]
                logger.info(f"\nDistribution pour {doctor.name} (minimum: {min_nlw}, maximum: {doctor_nl_counts[doctor.name]['max']})")
                

                failed_attempts = 0
                while doctor_nl_counts[doctor.name]["total"] < min_nlw:
                    # Vérifier la disponibilité des slots
                    if not any(len(slots) > 0 for slots in available_slots.values()):
                        logger.warning(f"Plus aucun slot disponible pour {doctor.name}")
                        break

                    # Choix aléatoire du type de NL
                    nl_type = self._distribute_nl_type_randomly(
                        doctor,
                        available_slots,
                        doctor_nl_counts[doctor.name]
                    )

                    if not nl_type:
                        failed_attempts += 1
                        if failed_attempts >= max_failed_attempts:
                            logger.warning(f"{doctor.name}: Abandon après {failed_attempts} échecs consécutifs")
                            break
                        continue

                    success = self._try_assign_nl_slot(
                        doctor,
                        available_slots[nl_type],
                        planning,
                        doctor_nl_counts[doctor.name],
                        nl_type
                    )

                    if success:
                        failed_attempts = 0
                        logger.info(f"{doctor.name}: {nl_type} attribué ({doctor_nl_counts[doctor.name]['total']}/{min_nlw})")
                    else:
                        failed_attempts += 1
                        if failed_attempts >= max_failed_attempts:
                            logger.warning(f"{doctor.name}: Abandon après {failed_attempts} échecs consécutifs")
                            break

             # Phase 2: Distribution du reste dans la limite des maximums stricts
            while any(len(slots) > 0 for slots in available_slots.values()):
                random.shuffle(all_doctors)
                assigned = False

                for doctor in all_doctors:
                    current_count = doctor_nl_counts[doctor.name]["total"]
                    max_allowed = doctor_nl_counts[doctor.name]["max"]
                    
                    # Vérification stricte du maximum
                    if current_count >= max_allowed:
                        logger.debug(f"Maximum atteint pour {doctor.name}: {current_count}/{max_allowed}")
                        continue

                    nl_type = self._distribute_nl_type_randomly(
                        doctor, 
                        available_slots,
                        doctor_nl_counts[doctor.name]
                    )
                    
                    if not nl_type:
                        continue

                    # Vérification supplémentaire avant l'assignation
                    if current_count + 1 > max_allowed:
                        logger.debug(f"Attribution impossible pour {doctor.name}: dépasserait le maximum ({max_allowed})")
                        continue

                    success = self._try_assign_nl_slot(
                        doctor,
                        available_slots[nl_type],
                        planning,
                        doctor_nl_counts[doctor.name],
                        nl_type
                    )
                    
                    if success:
                        assigned = True
                        logger.info(f"{doctor.name}: {nl_type} attribué (total: {doctor_nl_counts[doctor.name]['total']}/{max_allowed})")
                        break

                if not assigned:
                    logger.info("Aucune assignation possible, fin de la distribution")
                    break

            # Log des résultats finaux
            logger.info("\nRÉSULTAT FINAL DE LA DISTRIBUTION")
            logger.info("=" * 40)
            for doctor in sorted(all_doctors, key=lambda x: x.name):
                counts = doctor_nl_counts[doctor.name]
                logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
                logger.info(f"NLv: {counts['NLv']}")
                logger.info(f"NLs: {counts['NLs']}")
                logger.info(f"NLd: {counts['NLd']}")
                logger.info(f"Total: {counts['total']}")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NL: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Erreur dans la distribution NL: {e}", exc_info=True)
            return False

    def _try_assign_nl_slot(self, person, available_slots, planning, person_counts, nl_type, max_attempts=3):
        """Essaie d'assigner un slot NL avec un nombre limité de tentatives"""
        if not available_slots:
            return False

        slots_to_try = available_slots.copy()
        random.shuffle(slots_to_try)
        
        attempts = 0
        while slots_to_try and attempts < max_attempts:
            day, slot = slots_to_try.pop(0)  # Prendre et retirer le premier slot
            
            if self.constraints.can_assign_to_assignee(person, day.date, slot, planning):
                slot.assignee = person.name
                person_counts[nl_type] += 1
                person_counts["total"] += 1
                available_slots.remove((day, slot))
                logger.debug(f"Slot {nl_type} assigné à {person.name} le {day.date}")
                return True
                
            attempts += 1
        
        if attempts >= max_attempts:
            logger.debug(f"Limite de tentatives atteinte pour {person.name} sur {nl_type}")
        elif not slots_to_try:
            logger.debug(f"Plus de slots disponibles pour {person.name} sur {nl_type}")
        
        return False

    def _assign_nl_slots_to_person(self, person, quota, available_slots, planning, counts, nl_type):
        """Méthode commune pour assigner des slots à un médecin ou CAT"""
        remaining = quota
        assigned = 0
        
        while remaining > 0 and available_slots:
            success = self._try_assign_nl_slot(
                person,
                available_slots,
                planning,
                counts,
                nl_type
            )
            
            if success:
                assigned += 1
                remaining -= 1
            else:
                break
                
        if remaining > 0:
            logger.warning(f"  {person.name}: {assigned}/{quota} {nl_type} assignés")
        else:
            logger.info(f"  {person.name}: {assigned}/{quota} {nl_type} assignés")

        return assigned

    def _verify_nl_distribution(self, planning: Planning, expected_counts: Dict) -> bool:
        """
        Vérifie la distribution des NL et compare avec les totaux attendus
        """
        logger.info("\nVÉRIFICATION DE LA DISTRIBUTION NL")
        logger.info("=" * 80)
        
        actual_counts = {
            'cats': {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0},
            'doctors': {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0}
        }
        
        # Compter les NL distribués
        for day in planning.days:
            nl_slots = [slot for slot in day.slots if slot.abbreviation == "NL" and slot.assignee]
            
            # Ignorer les slots vides
            if not nl_slots:
                continue
                
            for slot in nl_slots:
                is_cat = any(cat.name == slot.assignee for cat in self.cats)
                person_type = 'cats' if is_cat else 'doctors'
                
                # Nouveau : Détection correcte du type de NL
                if day.date.weekday() == 4 and not day.is_holiday_or_bridge:  
                    # Vendredi normal
                    actual_counts[person_type]['NLv'] += 1
                elif day.date.weekday() == 5 and not day.is_holiday_or_bridge:  
                    # Samedi normal
                    actual_counts[person_type]['NLs'] += 1
                elif (day.date.weekday() == 6 or  # Dimanche
                    day.is_holiday_or_bridge or  # Jour férié ou pont
                    (day.date.weekday() == 5 and DayType.is_bridge_day(day.date, self.cal))):  # Samedi pont
                    actual_counts[person_type]['NLd'] += 1
                
                actual_counts[person_type]['total'] += 1

        
        # Comparer avec les totaux attendus
        all_match = True
        for person_type in ['cats', 'doctors']:
            logger.info(f"\n{person_type.upper()}:")
            for nl_type in ['NLv', 'NLs', 'NLd']:
                actual = actual_counts[person_type][nl_type]
                expected = expected_counts[person_type][nl_type]
                matches = actual == expected
                all_match &= matches
                
                logger.info(f"{nl_type}: {actual:3d} / {expected:3d} "
                        f"({'OK' if matches else 'ÉCART'})")
                
                # Log détaillé en cas d'écart
                if not matches:
                    logger.warning(f"Écart détecté pour {person_type} {nl_type}: "
                                f"Attendu {expected}, Obtenu {actual}")
            
            actual_total = actual_counts[person_type]['total']
            expected_total = expected_counts[person_type]['total']
            total_matches = actual_total == expected_total
            all_match &= total_matches
            
            logger.info(f"Total: {actual_total:3d} / {expected_total:3d} "
                    f"({'OK' if total_matches else 'ÉCART'})")
            
            if not total_matches:
                logger.warning(f"Écart total détecté pour {person_type}: "
                            f"Attendu {expected_total}, Obtenu {actual_total}")

        return all_match
    
    def _log_distribution_results(self, counts, quotas, person_type: str):
        """Log les résultats de distribution des NL"""
        logger.info(f"\nRÉSULTATS DISTRIBUTION {person_type}:")
        logger.info("=" * 40)
        
        for name, person_counts in sorted(counts.items()):
            logger.info(f"\n{name}:")
            total_assigned = 0
            total_quota = 0
            
            for nl_type in ["NLv", "NLs", "NLd"]:
                assigned = person_counts[nl_type]
                quota = quotas[nl_type]
                total_assigned += assigned
                total_quota += quota
                
                status = "OK" if assigned >= quota else f"MANQUE {quota - assigned}"
                logger.info(f"{nl_type}: {assigned}/{quota} ({status})")
            
            completion_rate = (total_assigned / total_quota * 100) if total_quota > 0 else 0
            logger.info(f"Total: {total_assigned}/{total_quota} ({completion_rate:.1f}%)")

    
    def _distribute_nl_type_randomly(self, doctor, available_slots, nl_counts):
        """
        Distribue les NL de manière aléatoire mais équilibrée
        """
        # Calculer les ratios actuels de chaque type de NL
        total_nl = sum(nl_counts.values())
        if total_nl == 0:
            # Premier NL : choix complètement aléatoire
            return random.choice(list(available_slots.keys()))
        
        # Calculer les ratios idéaux (environ 1/3 de chaque)
        ideal_ratio = 1/3
        
        # Calculer les écarts au ratio idéal
        ratios = {
            nl_type: count/total_nl if total_nl > 0 else 0 
            for nl_type, count in nl_counts.items()
        }
        deviations = {
            nl_type: ideal_ratio - ratio
            for nl_type, ratio in ratios.items()
        }
        
        # Ajouter un facteur aléatoire aux déviations
        random_factor = 0.2  # Facteur d'aléatoire (0.0 à 1.0)
        weighted_deviations = {
            nl_type: dev + (random.random() * random_factor)
            for nl_type, dev in deviations.items()
        }
        
        # Filtrer les types de NL disponibles
        available_types = [nl_type for nl_type, slots in available_slots.items() if slots]
        
        if not available_types:
            return None
        
        # Choisir le type avec la plus grande déviation positive + facteur aléatoire
        chosen_type = max(
            available_types,
            key=lambda x: weighted_deviations[x]
        )
        
        return chosen_type
    
    def _log_doctor_nl_distribution(self, doctor_name: str, counts: Dict):
        """Affiche la distribution actuelle des NL pour un médecin"""
        logger.info(f"\nDistribution pour {doctor_name}:")
        logger.info(f"NLv: {counts['NLv']}")
        logger.info(f"NLs: {counts['NLs']}")
        logger.info(f"NLd: {counts['NLd']}")
        logger.info(f"Total: {counts['total']}")
    
    
    
    
    
    def distribute_namw(self, planning: Planning, pre_analysis) -> bool:
        """Distribution des NA et NM du weekend suivant le même modèle que NLw"""
        try:
            logger.info("\nDISTRIBUTION NAM WEEKEND")
            logger.info("=" * 80)
            
            # 1. Récupération des totaux CAT avec le même format que NLw
            cat_count = len(self.cats)
            cat_nam = {
                "NAs": pre_analysis["cat_posts"]["saturday"].get("NA", 0),
                "NAd": pre_analysis["cat_posts"]["sunday_holiday"].get("NA", 0),
                "NMs": pre_analysis["cat_posts"]["saturday"].get("NM", 0),
                "NMd": pre_analysis["cat_posts"]["sunday_holiday"].get("NM", 0)
            }
            
            cat_totals = {k: v * cat_count for k, v in cat_nam.items()}
            cat_total = sum(cat_totals.values())
            
            # 2. Récupération des totaux médecins
            med_nam = {
                "NAs": pre_analysis["adjusted_posts"]["saturday"]["NA"],
                "NAd": pre_analysis["adjusted_posts"]["sunday_holiday"]["NA"],
                "NMs": pre_analysis["adjusted_posts"]["saturday"]["NM"],
                "NMd": pre_analysis["adjusted_posts"]["sunday_holiday"]["NM"]
            }
            med_total = sum(med_nam.values())
            med_namw = pre_analysis["adjusted_posts"]["weekend_groups"]["NAMw"]
            
            # Log des quotas comme pour NLw
            logger.info("\nTOTAUX CAT À DISTRIBUER:")
            for slot_type, count in cat_totals.items():
                logger.info(f"{slot_type}: {count} ({cat_nam[slot_type]}/CAT)")
            logger.info(f"Total: {cat_total}")
            
            logger.info("\nTOTAUX MÉDECINS À DISTRIBUER:")
            for slot_type, count in med_nam.items():
                logger.info(f"{slot_type}: {count}")
            logger.info(f"Total NAMw: {med_namw}")
            
            # 3. Vérification de cohérence comme pour NLw
            if med_namw != sum(med_nam.values()):
                logger.error("Incohérence dans les totaux médecins: "
                            f"NAMw ({med_namw}) ≠ Total NA+NM ({sum(med_nam.values())})")
                return False
            
            # Collecter les slots une seule fois
            nam_slots = self._collect_nam_slots(planning)

            # 5. Distribution aux CAT
            if not self._distribute_nam_to_cats(planning, cat_totals):  # Enlever nam_slots ici
                logger.error("Échec de la distribution des NAM aux CAT")
                return False
                
            # 7. Distribution médecins (3 phases)
            if not self._distribute_nam_to_doctors(planning, med_nam, pre_analysis):
                return False
                
            # 8. Vérification finale
            verification_data = {
                'cats': cat_totals,
                'doctors': med_nam
            }
            
            return self._verify_nam_distribution(planning, verification_data)
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution NAMw: {e}", exc_info=True)
            return False

        
    
    def _distribute_nam_to_cats(self, planning: Planning, cat_totals: Dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NAM AUX CAT")
            logger.info("=" * 60)

            cat_counts = {
                cat.name: {
                    "NAs": 0, "NAd": 0, "NMs": 0, "NMd": 0
                } for cat in self.cats
            }

            # Récupérer les slots par type
            nam_slots = self._collect_nam_slots(planning)  # Déplacer la collecte ici

            # Pour chaque type de garde, respecter exactement les quotas
            for slot_type in ["NAs", "NAd", "NMs", "NMd"]:
                quota_per_cat = cat_totals[slot_type] // len(self.cats)
                available_slots = nam_slots[slot_type].copy()
                random.shuffle(available_slots)

                # Distribution stricte par CAT
                for cat in self.cats:
                    slots_assigned = 0
                    while slots_assigned < quota_per_cat and available_slots:
                        assigned = False
                        for slot_index in range(len(available_slots)):
                            day, slot = available_slots[slot_index]
                            if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                                slot.assignee = cat.name
                                cat_counts[cat.name][slot_type] += 1
                                available_slots.pop(slot_index)
                                slots_assigned += 1
                                assigned = True
                                break
                        if not assigned:
                            break
                    
                    if slots_assigned < quota_per_cat:
                        logger.warning(f"CAT {cat.name}: impossible d'atteindre le quota {slot_type} "
                                    f"({slots_assigned}/{quota_per_cat})")

            # Log des résultats
            self._log_nam_distribution_results(cat_counts, cat_totals, "CAT")
            return True

        except Exception as e:
            logger.error(f"Erreur distribution NAM CAT: {e}", exc_info=True)
            return False

    def _distribute_nam_to_doctors(self, planning: Planning, med_nam: Dict, pre_analysis: dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NAM AUX MÉDECINS")
            logger.info("=" * 60)

            # Définition des intervalles stricts
            max_plein_temps = 4  # Fixé d'après la pré-analyse
            max_mi_temps = 2     # Fixé d'après la pré-analyse
            min_plein_temps = 3
            min_mi_temps = 1

            logger.info("Intervalles de distribution NAM:")
            logger.info(f"Plein temps: [{min_plein_temps}-{max_plein_temps}]")
            logger.info(f"Mi-temps: [{min_mi_temps}-{max_mi_temps}]")

            # Initialisation des compteurs avec les limites
            doctor_counts = {
                doctor.name: {
                    "NAs": 0, "NAd": 0, "NMs": 0, "NMd": 0, "NAMw": 0,
                    "max": max_plein_temps if doctor.half_parts == 2 else max_mi_temps,
                    "min": min_plein_temps if doctor.half_parts == 2 else min_mi_temps
                } for doctor in self.doctors
            }

            # Récupération et mélange des slots disponibles
            all_slots = []
            nam_slots = self._collect_nam_slots(planning)
            for slot_type, slots in nam_slots.items():
                for slot_info in slots:
                    all_slots.append((slot_info[0], slot_info[1], slot_type))
            
            random.shuffle(all_slots)

            # Liste de tous les médecins dans un ordre aléatoire
            all_doctors = self.doctors.copy()
            random.shuffle(all_doctors)

            # Phase 1: Distribution du minimum à tous les médecins
            logger.info("\nPHASE 1: Distribution du minimum à tous les médecins")
            logger.info("=" * 50)

            for doctor in all_doctors:
                min_target = doctor_counts[doctor.name]["min"]
                logger.info(f"\nDistribution pour {doctor.name} (minimum: {min_target}, maximum: {doctor_counts[doctor.name]['max']})")

                while doctor_counts[doctor.name]["NAMw"] < min_target and all_slots:
                    assigned = False
                    for slot_index in range(len(all_slots)):
                        day, slot, slot_type = all_slots[slot_index]
                        if self.constraints.can_assign_to_assignee(doctor, day.date, slot, planning):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name][slot_type] += 1
                            doctor_counts[doctor.name]["NAMw"] += 1
                            all_slots.pop(slot_index)
                            assigned = True
                            logger.info(f"{doctor.name}: {slot_type} attribué (total: {doctor_counts[doctor.name]['NAMw']}/{min_target})")
                            break
                    if not assigned:
                        logger.warning(f"Impossible d'atteindre le minimum pour {doctor.name}")
                        break

            # Phase 2: Distribution du reste dans la limite des maximums
            logger.info("\nPHASE 2: Distribution du reste aux médecins")
            logger.info("=" * 50)

            while all_slots:
                random.shuffle(all_doctors)
                assigned = False

                for doctor in all_doctors:
                    current_count = doctor_counts[doctor.name]["NAMw"]
                    max_allowed = doctor_counts[doctor.name]["max"]

                    # Vérification stricte du maximum
                    if current_count >= max_allowed:
                        continue

                    # Vérification supplémentaire avant l'assignation
                    if current_count + 1 > max_allowed:
                        continue

                    # Tenter l'assignation
                    for slot_index in range(len(all_slots)):
                        day, slot, slot_type = all_slots[slot_index]
                        if self.constraints.can_assign_to_assignee(doctor, day.date, slot, planning):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name][slot_type] += 1
                            doctor_counts[doctor.name]["NAMw"] += 1
                            all_slots.pop(slot_index)
                            assigned = True
                            logger.info(f"{doctor.name}: {slot_type} attribué (total: {doctor_counts[doctor.name]['NAMw']}/{max_allowed})")
                            break

                if not assigned:
                    logger.info("Aucune assignation possible, fin de la distribution")
                    break

            # Log des résultats finaux
            logger.info("\nRÉSULTAT FINAL DE LA DISTRIBUTION")
            logger.info("=" * 40)
            for doctor in sorted(all_doctors, key=lambda x: x.name):
                counts = doctor_counts[doctor.name]
                logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
                logger.info(f"NAs: {counts['NAs']}")
                logger.info(f"NAd: {counts['NAd']}")
                logger.info(f"NMs: {counts['NMs']}")
                logger.info(f"NMd: {counts['NMd']}")
                logger.info(f"Total NAMw: {counts['NAMw']}")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NAM: {e}", exc_info=True)
            return False
        
    def _collect_nam_slots(self, planning: Planning) -> Dict:
        """Collecte tous les slots NA et NM disponibles"""
        nam_slots = {
            "NAs": [],  # NA samedi
            "NAd": [],  # NA dimanche/férié/pont
            "NMs": [],  # NM samedi
            "NMd": []   # NM dimanche/férié/pont
        }

        for day in planning.days:
            slots_available = [slot for slot in day.slots 
                            if slot.abbreviation in ["NA", "NM"] and not slot.assignee]
            
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)

            for slot in slots_available:
                if day_type == "sunday_holiday" or is_bridge:
                    suffix = "d"  # dimanche/férié/pont
                elif day.date.weekday() == 5 and not is_bridge:
                    suffix = "s"  # samedi normal
                else:
                    continue  # Ignorer les autres jours

                slot_type = f"{slot.abbreviation}{suffix}"
                nam_slots[slot_type].append((day, slot))

        return nam_slots

    def _try_assign_nam_slot(self, person, available_slots, planning, person_counts, nam_type, max_attempts=3):
        """Version NAM de _try_assign_nl_slot"""
        if not available_slots:
            return False

        slots_to_try = available_slots.copy()
        random.shuffle(slots_to_try)
        
        attempts = 0
        while slots_to_try and attempts < max_attempts:
            day, slot = slots_to_try.pop(0)
            
            if self.constraints.can_assign_to_assignee(person, day.date, slot, planning):
                slot.assignee = person.name
                person_counts[nam_type] += 1
                person_counts["total" if "total" in person_counts else "NAMw"] += 1
                available_slots.remove((day, slot))
                logger.debug(f"Slot {nam_type} assigné à {person.name} le {day.date}")
                return True
                
            attempts += 1
        
        return False
    
    def _assign_nam_slots_to_person(self, person, quota, available_slots, planning, counts, slot_type):
        """Méthode commune pour assigner des slots NAM à un médecin ou CAT"""
        remaining = quota
        assigned = 0
        
        while remaining > 0 and available_slots:
            success = self._try_assign_nam_slot(
                person,
                available_slots,
                planning,
                counts,
                slot_type
            )
            
            if success:
                assigned += 1
                remaining -= 1
            else:
                break
                
            # Log des résultats
            if remaining > 0:
                logger.warning(f"  {person.name}: {assigned}/{quota} {slot_type} assignés")
            else:
                logger.info(f"  {person.name}: {assigned}/{quota} {slot_type} assignés")

        return assigned

    def _distribute_nam_type_randomly(self, doctor, available_slots, nam_counts):
        """Version NAM de _distribute_nl_type_randomly"""
        # Calcul des ratios pour NA et NM séparément
        total_na = nam_counts.get("NAs", 0) + nam_counts.get("NAd", 0)
        total_nm = nam_counts.get("NMs", 0) + nam_counts.get("NMd", 0)
        total = total_na + total_nm
        
        if total == 0:
            # Premier choix : complètement aléatoire
            available_types = [t for t, slots in available_slots.items() if slots]
            return random.choice(available_types) if available_types else None
        
        # Calculer les ratios idéaux (équilibre entre NA et NM)
        ideal_ratio = 0.5
        
        # Calculer les déviations actuelles
        na_ratio = total_na / total if total > 0 else 0
        nm_ratio = total_nm / total if total > 0 else 0
        
        # Ajouter un facteur aléatoire
        random_factor = 0.2
        weighted_deviations = {
            "NA": (ideal_ratio - na_ratio) + (random.random() * random_factor),
            "NM": (ideal_ratio - nm_ratio) + (random.random() * random_factor)
        }
        
        # Choisir entre NA et NM
        prefer_na = weighted_deviations["NA"] > weighted_deviations["NM"]
        
        # Filtrer les types disponibles
        available_types = []
        for t, slots in available_slots.items():
            if not slots:
                continue
            if prefer_na and t.startswith("NA"):
                available_types.append(t)
            elif not prefer_na and t.startswith("NM"):
                available_types.append(t)
        
        return random.choice(available_types) if available_types else None

    def _log_nam_distribution_results(self, counts, quotas, person_type: str, ranges: Dict = None):
        """Log unifié et concis des résultats de distribution NAM"""
        logger.info(f"\nRÉSULTATS DISTRIBUTION {person_type} NAM WEEKEND")
        logger.info("=" * 80)

        # En-têtes adaptés selon le type de personne (CAT ou Médecin)
        if person_type == "CAT":
            headers = ["Nom", "NA(s/d)", "NM(s/d)", "Total", "Quota", "Statut"]
        else:
            headers = ["Médecin", "NA(s/d)", "NM(s/d)", "Total", "Cible", "Statut"]

        # Affichage des en-têtes
        logger.info(f"{headers[0]:<15} {headers[1]:<12} {headers[2]:<12} {headers[3]:<8} {headers[4]:<10} {headers[5]}")
        logger.info("-" * 80)

        for name, person_counts in sorted(counts.items()):
            # Calcul des totaux NA et NM
            na_total = person_counts.get("NAs", 0) + person_counts.get("NAd", 0)
            nm_total = person_counts.get("NMs", 0) + person_counts.get("NMd", 0)
            total = na_total + nm_total

            # Format compact pour NA et NM
            na_str = f"{na_total}({person_counts.get('NAs',0)}/{person_counts.get('NAd',0)})"
            nm_str = f"{nm_total}({person_counts.get('NMs',0)}/{person_counts.get('NMd',0)})"

            # Détermination du statut selon le type
            if person_type == "CAT":
                quota_total = sum(quotas.values())
                status = "OK" if total >= quota_total else f"MANQUE {quota_total - total}"
                target = f"{quota_total}"
            else:
                range_info = ranges.get(name, {"min": 0, "max": 0})
                target = f"[{range_info['min']}-{range_info['max']}]"
                if total < range_info["min"]:
                    status = "SOUS MIN"
                elif total > range_info["max"]:
                    status = "SUR MAX"
                else:
                    status = "OK"

            # Affichage de la ligne
            logger.info(f"{name:<15} {na_str:<12} {nm_str:<12} {total:<8} {target:<10} {status}")

        # Affichage du résumé uniquement en cas d'écarts
        ecarts = sum(1 for _, counts in counts.items() if "MANQUE" in counts or "SOUS" in counts or "SUR" in counts)
        if ecarts > 0:
            logger.info("\nRésumé des écarts :")
            for name, person_counts in counts.items():
                if "MANQUE" in person_counts or "SOUS" in person_counts or "SUR" in person_counts:
                    logger.warning(f"{name}: {person_counts['status']}")

    def _verify_nam_distribution(self, planning: Planning, expected_counts: Dict) -> bool:
        """Vérification concise de la distribution NAM"""
        logger.info("\nVÉRIFICATION DISTRIBUTION NAM")
        logger.info("=" * 60)

        actual_counts = {
            'cats': {'NAs': 0, 'NAd': 0, 'NMs': 0, 'NMd': 0},
            'doctors': {'NAs': 0, 'NAd': 0, 'NMs': 0, 'NMd': 0}
        }

        # Compter les NAM distribués
        for day in planning.days:
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)
            
            for slot in day.slots:
                if slot.abbreviation not in ["NA", "NM"] or not slot.assignee:
                    continue
                    
                is_cat = any(cat.name == slot.assignee for cat in self.cats)
                person_type = 'cats' if is_cat else 'doctors'
                
                if day_type == "sunday_holiday" or is_bridge:
                    suffix = "d"
                elif day.date.weekday() == 5 and not is_bridge:
                    suffix = "s"
                else:
                    continue
                    
                slot_type = f"{slot.abbreviation}{suffix}"
                actual_counts[person_type][slot_type] += 1

        # Affichage en format tableau
        headers = ["Type", "NAs", "NAd", "NMs", "NMd", "Total", "Attendu", "Statut"]
        logger.info(f"{headers[0]:<10} {headers[1]:>5} {headers[2]:>5} {headers[3]:>5} {headers[4]:>5} {headers[5]:>7} {headers[6]:>8} {headers[7]}")
        logger.info("-" * 65)

        all_match = True
        for person_type in ['cats', 'doctors']:
            actual = actual_counts[person_type]
            expected = expected_counts[person_type]
            
            actual_total = sum(actual.values())
            expected_total = sum(expected.values())
            
            status = "OK" if actual_total == expected_total else "ÉCART"
            all_match &= actual_total == expected_total
            
            logger.info(f"{person_type:<10} {actual['NAs']:>5} {actual['NAd']:>5} {actual['NMs']:>5} {actual['NMd']:>5} "
                    f"{actual_total:>7} {expected_total:>8} {status}")

            # Log des écarts si présents
            if actual_total != expected_total:
                for slot_type in ['NAs', 'NAd', 'NMs', 'NMd']:
                    if actual[slot_type] != expected[slot_type]:
                        logger.warning(f"  {slot_type}: Attendu={expected[slot_type]}, Obtenu={actual[slot_type]}")

        return all_match
    
    
 



    def _get_critical_weekend_periods(self, planning: Planning) -> List[date]:
        """Identifie les périodes critiques du weekend basées sur les disponibilités des médecins"""
        critical_dates = []
        weekend_dates = self._get_weekend_dates(planning)
        
        for current_date in weekend_dates:
            # Compter les médecins disponibles pour cette date
            available_doctors = 0
            for doctor in self.doctors:
                if not any(
                    desiderata.start_date <= current_date <= desiderata.end_date 
                    for desiderata in doctor.desiderata
                ):
                    available_doctors += 1
            
            # Calculer le pourcentage de médecins disponibles
            availability_percentage = (available_doctors / len(self.doctors)) * 100
            
            # Si moins de 50% des médecins sont disponibles, c'est une période critique
            if availability_percentage < 60:
                critical_dates.append({
                    'date': current_date,
                    'availability': availability_percentage
                })
        
        # Trier les dates par ordre croissant de disponibilité
        critical_dates.sort(key=lambda x: x['availability'])
        
        logger.info("\nPÉRIODES CRITIQUES IDENTIFIÉES:")
        for period in critical_dates:
            logger.info(f"Date: {period['date'].strftime('%Y-%m-%d')} - "
                    f"Disponibilité: {period['availability']:.1f}%")
        
        return critical_dates

    def _distribute_cat_weekend_combinations(self, planning: Planning) -> bool:
        """Distribution des combinaisons weekend pour les CAT en incluant les postes personnalisés"""
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS WEEKEND AUX CAT")
            logger.info("=" * 60)

            # Identifier les périodes critiques
            critical_periods = self._get_critical_weekend_periods(planning)
            critical_dates = [period['date'] for period in critical_periods]

            # Organiser les dates
            weekend_dates = {
                "saturday": [],
                "sunday": []
            }
            
            # Séparer les dates normales des dates critiques
            normal_dates = []
            for date in self._get_weekend_dates(planning):
                if date not in critical_dates:
                    if date.weekday() == 5 and not self.is_bridge_day(date):
                        weekend_dates["saturday"].append(date)
                    else:
                        weekend_dates["sunday"].append(date)
                else:
                    normal_dates.append(date)

            day_type_mapping = {
                "saturday": "saturday",
                "sunday": "sunday_holiday"
            }

            for cat in self.cats:
                logger.info(f"\nAnalyse des combinaisons pour {cat.name}:")
                
                # Récupérer toutes les combinaisons possibles (standards + personnalisées)
                combinations = self._get_cat_possible_combinations(cat, planning)
                logger.debug(f"Combinaisons disponibles pour {cat.name}: {combinations}")
                
                used_posts = {
                    "saturday": defaultdict(int),
                    "sunday": defaultdict(int)
                }
                assignments = {
                    "saturday": defaultdict(int),
                    "sunday": defaultdict(int)
                }

                # 1. Traiter d'abord les périodes critiques
                for critical_date in critical_dates:
                    day_type = "saturday" if critical_date.weekday() == 5 and not self.is_bridge_day(critical_date) else "sunday"
                    
                    if not self._is_cat_available_for_date(cat, critical_date, planning):
                        continue

                    self._try_assign_cat_combination(
                        cat, critical_date, day_type, combinations,
                        used_posts, assignments, planning,
                        is_critical=True
                    )

                # 2. Traiter ensuite les autres dates
                for day_type, dates in weekend_dates.items():
                    dates_to_process = dates.copy()
                    random.shuffle(dates_to_process)

                    for date in dates_to_process:
                        if not self._is_cat_available_for_date(cat, date, planning):
                            continue

                        self._try_assign_cat_combination(
                            cat, date, day_type, combinations,
                            used_posts, assignments, planning,
                            is_critical=False
                        )

                # Log des résultats
                self._log_cat_weekend_distribution(cat, used_posts, assignments, combinations, planning)

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution CAT weekend: {e}", exc_info=True)
            return False

    def _try_assign_cat_combination(self, cat: CAT, date: date, day_type: str,
                            combinations: Dict, used_posts: Dict, assignments: Dict,
                            planning: Planning, is_critical: bool) -> bool:
        """Tente d'attribuer une combinaison pour une date donnée"""
        pre_analysis_day_type = "saturday" if day_type == "saturday" else "sunday_holiday"
        quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_day_type]

        available_combinations = []
        for combo, max_count in combinations[day_type]:
            # Vérifier si c'est une combinaison de poste personnalisé
            is_custom = combo in sum([list(p.possible_combinations.values()) 
                                    for p in self.custom_posts.values()], [])
            
            if is_custom:
                # Récupérer les postes de la combinaison à partir du nom du combo
                for custom_post in self.custom_posts.values():
                    if combo in custom_post.possible_combinations.values():
                        for post, combo_name in custom_post.possible_combinations.items():
                            if combo_name == combo:
                                first_post = custom_post.name
                                second_post = post
                                break
            else:
                first_post, second_post = combo[:2], combo[2:]

            if (used_posts[day_type][first_post] < quotas.get(first_post, 0) and
                used_posts[day_type][second_post] < quotas.get(second_post, 0) and
                assignments[day_type][combo] < max_count and
                self._can_assign_cat_combination(cat, combo, date, planning)):
                available_combinations.append(combo)

        if available_combinations:
            weighted_combinations = []
            for combo in available_combinations:
                weight = (max_count + 1 - assignments[day_type][combo])
                if is_critical:
                    weight *= 2
                weighted_combinations.extend([combo] * weight)

            if weighted_combinations:
                combo = random.choice(weighted_combinations)
                if self._assign_combination_to_cat(cat, combo, date, planning):
                    if combo in sum([list(p.possible_combinations.values()) 
                                for p in self.custom_posts.values()], []):
                        # Trouver les postes pour la combinaison personnalisée
                        for custom_post in self.custom_posts.values():
                            if combo in custom_post.possible_combinations.values():
                                for post, combo_name in custom_post.possible_combinations.items():
                                    if combo_name == combo:
                                        first_post = custom_post.name
                                        second_post = post
                                        break
                    else:
                        first_post, second_post = combo[:2], combo[2:]

                    used_posts[day_type][first_post] += 1
                    used_posts[day_type][second_post] += 1
                    assignments[day_type][combo] += 1
                    logger.info(f"{cat.name}: {combo} attribué pour {date} "
                            f"({day_type}) {'[CRITIQUE]' if is_critical else ''}")
                    return True

        return False

    def _get_weekend_dates(self, planning: Planning) -> List[date]:
        weekend_dates = []
        current_date = planning.start_date
        
        while current_date <= planning.end_date:
            if (current_date.weekday() >= 5 or
                self.cal.is_holiday(current_date) or
                self.is_bridge_day(current_date)):
                weekend_dates.append(current_date)
            current_date += timedelta(days=1)
        
        return weekend_dates

    def _can_assign_cat_combination(self, cat: CAT, combo: str, date: date, planning: Planning) -> bool:
        """Vérifie si une combinaison peut être attribuée à un CAT pour une date donnée"""
        # Récupérer les slots pour la date
        day = planning.get_day(date)
        if not day:
            return False

        # Vérifier si c'est une combinaison de poste personnalisé
        is_custom_combo = any(combo in post.possible_combinations.values() 
                            for post in self.custom_posts.values())

        if is_custom_combo:
            # Trouver les postes impliqués dans la combinaison personnalisée
            first_post = None
            second_post = None
            for custom_post in self.custom_posts.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        first_post = custom_post.name
                        second_post = post
                        break
                if first_post:
                    break
        else:
            # Combinaison standard
            first_post, second_post = combo[:2], combo[2:]

        if not (first_post and second_post):
            logger.error(f"Impossible de déterminer les postes pour la combinaison {combo}")
            return False

        # Vérifier la disponibilité des slots
        first_slot = next((s for s in day.slots if s.abbreviation == first_post and not s.assignee), None)
        second_slot = next((s for s in day.slots if s.abbreviation == second_post and not s.assignee), None)

        if not (first_slot and second_slot):
            logger.debug(f"Slots non disponibles pour {combo} le {date}")
            return False

        # Vérifier les contraintes pour chaque slot
        can_assign = (self.constraints.can_assign_to_assignee(cat, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, planning))
        
        if can_assign:
            logger.debug(f"Combinaison {combo} possible pour {cat.name} le {date}")
        
        return can_assign

    def _assign_combination_to_cat(self, cat: CAT, combo: str, date: date, planning: Planning) -> bool:
        """Attribution d'une combinaison à un CAT"""
        try:
            day = planning.get_day(date)
            if not day:
                return False

            # Vérifier si c'est une combinaison personnalisée
            is_custom_combo = any(combo in post.possible_combinations.values() 
                                for post in self.custom_posts.values())

            if is_custom_combo:
                # Trouver les postes impliqués
                first_post = None
                second_post = None
                for custom_post in self.custom_posts.values():
                    for post, combo_name in custom_post.possible_combinations.items():
                        if combo_name == combo:
                            first_post = custom_post.name
                            second_post = post
                            break
                    if first_post:
                        break
            else:
                first_post, second_post = combo[:2], combo[2:]

            if not (first_post and second_post):
                logger.error(f"Impossible de déterminer les postes pour la combinaison {combo}")
                return False

            # Trouver les slots non assignés
            first_slot = next((s for s in day.slots if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots if s.abbreviation == second_post and not s.assignee), None)

            if not (first_slot and second_slot):
                logger.debug(f"Slots non disponibles pour {combo} le {date}")
                return False

            # Vérifier les contraintes
            if not (self.constraints.can_assign_to_assignee(cat, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, planning)):
                return False

            # Assigner les slots
            first_slot.assignee = cat.name
            second_slot.assignee = cat.name

            logger.info(f"Attribution réussie: {combo} ({first_post}+{second_post}) à {cat.name} pour {date}")
            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution de {combo} à {cat.name}: {e}")
            return False

    def _get_cat_possible_combinations(self, cat: CAT, planning: Planning) -> Dict[str, List[Tuple[str, int]]]:
        """Détermine les combinaisons possibles pour un CAT"""
        combinations = {"saturday": [], "sunday": []}
        
        # Récupérer les quotas pour chaque type de jour
        for day_type, pre_analysis_key in [("saturday", "saturday"), ("sunday", "sunday_holiday")]:
            quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_key]
            
            # Debug des quotas disponibles
            logger.debug(f"Quotas {day_type} pour {cat.name}: {quotas}")

            # Ajouter les combinaisons standards
            for combo in WEEKEND_COMBINATIONS:
                first_post, second_post = combo[:2], combo[2:]
                if quotas.get(first_post, 0) > 0 and quotas.get(second_post, 0) > 0:
                    max_count = min(quotas[first_post], quotas[second_post])
                    if max_count > 0:
                        combinations[day_type].append((combo, max_count))

            # Ajouter les combinaisons des postes personnalisés
            for post_name, custom_post in self.custom_posts.items():
                if custom_post.assignment_type in ['cats', 'both']:
                    if day_type.replace('sunday', 'sunday_holiday') in custom_post.day_types:
                        quota_custom = quotas.get(post_name, 0)
                        if quota_custom > 0:
                            for other_post, combo_name in custom_post.possible_combinations.items():
                                quota_other = quotas.get(other_post, 0)
                                if quota_other > 0:
                                    max_count = min(quota_custom, quota_other)
                                    combinations[day_type].append((combo_name, max_count))
                                    logger.debug(f"Ajout combinaison {combo_name} pour {cat.name} "
                                            f"({post_name}+{other_post}) avec max={max_count}")

        # Log des combinaisons disponibles
        logger.debug(f"Combinaisons disponibles pour {cat.name}: {combinations}")
        
        return combinations

    def _is_cat_available_for_date(self, cat: CAT, date: date, planning: Planning) -> bool:
        """Vérifie si un CAT est disponible pour une date donnée"""
        # Vérifier les desiderata
        for desiderata in cat.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                return False
                
        # Vérifier si le CAT a déjà des postes ce jour
        day = planning.get_day(date)
        if day:
            return not any(slot.assignee == cat.name for slot in day.slots)
        
        return True

    def _verify_cat_combinations(self, cat_combinations: Dict):
        """Vérifie et log la distribution finale des combinaisons aux CAT"""
        logger.info("\nVÉRIFICATION FINALE DES COMBINAISONS CAT")
        logger.info("=" * 60)
        
        for cat_name, counts in cat_combinations.items():
            logger.info(f"\n{cat_name}:")
            for combo, count in counts.items():
                if combo != "total" and count > 0:
                    logger.info(f"{combo}: {count}")
            logger.info(f"Total combinaisons: {counts['total']}")
            
    def _log_cat_weekend_distribution(self, cat: CAT, used_posts: Dict, 
                                    assignments: Dict, combinations: Dict, planning: Planning):
        """Log détaillé de la distribution pour un CAT"""
        logger.info(f"\nRésultats de distribution pour {cat.name}:")
        
        for day_type in ["saturday", "sunday"]:
            logger.info(f"\n{day_type.upper()}:")
            logger.info("-" * 40)
            
            # Log des combinaisons utilisées
            logger.info("Combinaisons utilisées:")
            for combo, count in assignments[day_type].items():
                if count > 0:
                    max_count = next(m for c, m in combinations[day_type] if c == combo)
                    logger.info(f"{combo}: {count}/{max_count}")
            
            # Log des postes utilisés
            logger.info("\nPostes utilisés:")
            pre_analysis_day_type = "saturday" if day_type == "saturday" else "sunday_holiday"
            quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_day_type]
            
            for post_type, used in used_posts[day_type].items():
                if used > 0:
                    is_custom = post_type in self.custom_posts
                    quota = quotas.get(post_type, 0)
                    logger.info(f"{post_type}: {used}/{quota}" + 
                            " (Personnalisé)" if is_custom else "")
    
    
    
    
    def _distribute_doctor_weekend_combinations(self, planning: Planning) -> bool:
        """
        Distribue les combinaisons de postes weekend aux médecins.
        Prend en compte les périodes critiques, les indisponibilités et les contraintes.
        """
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS WEEKEND AUX MÉDECINS")
            logger.info("=" * 80)

            # Initialisation des structures de données
            doctor_counts = self._initialize_doctor_counts(planning)  # Modification ici
            critical_periods = self._get_critical_weekend_periods(planning)

            # Récupération et organisation des combinaisons disponibles
            available_combinations = self._get_available_doctor_combinations(planning)
            if not available_combinations:
                logger.error("Aucune combinaison disponible pour la distribution")
                return False

            # 1. Distribution pour les périodes critiques
            if critical_periods:
                logger.info("\nPHASE 1: DISTRIBUTION PÉRIODES CRITIQUES")
                logger.info("-" * 60)
                sorted_doctors = self._sort_doctors_by_unavailability(planning)
                
                for period in critical_periods:
                    date = period['date']
                    logger.info(f"\nTraitement période critique: {date} "
                            f"(disponibilité: {period['availability']:.1f}%)")
                    
                    if not self._distribute_critical_period(
                        date, sorted_doctors, doctor_counts,
                        available_combinations, planning
                    ):
                        logger.warning(f"Distribution incomplète pour {date}")

            # 2. Distribution générale équilibrée
            logger.info("\nPHASE 2: DISTRIBUTION GÉNÉRALE")
            logger.info("-" * 60)

            if not self._distribute_remaining_combinations(
                doctor_counts, available_combinations, planning
            ):
                logger.warning("Distribution générale incomplète")

            # Vérification et log des résultats
            self._verify_doctor_distribution(doctor_counts, planning)
            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution des combinaisons médecins: {e}", 
                        exc_info=True)
            return False

    def _initialize_doctor_counts(self, planning: Planning) -> Dict:
        """Initialise les compteurs pour chaque médecin."""
        doctor_counts = {}
        
        for doctor in self.doctors:
            doctor_counts[doctor.name] = {
                "posts": {post_type: 0 for post_type in ALL_POST_TYPES},
                "combinations": {combo: 0 for combo in WEEKEND_COMBINATIONS},
                "total_combinations": 0,
                "custom_posts": {name: 0 for name in self.custom_posts.keys()},
                "intervals": self._get_doctor_intervals(doctor, planning)
            }
            
        return doctor_counts

    def _get_doctor_intervals(self, doctor: Doctor, planning: Planning) -> Dict:
        """
        Récupère les intervalles min-max pour un médecin depuis la pré-analyse.
        """
        intervals = {}
        pre_analysis = planning.pre_analysis_results
        if not pre_analysis or 'ideal_distribution' not in pre_analysis:
            return intervals

        doctor_distribution = pre_analysis['ideal_distribution'].get(doctor.name, {})
        
        # Intervalles pour les postes standards
        for post_type in ALL_POST_TYPES:
            if post_type in doctor_distribution.get('weekend_posts', {}):
                intervals[post_type] = {
                    'min': doctor_distribution['weekend_posts'][post_type]['min'],
                    'max': doctor_distribution['weekend_posts'][post_type]['max']
                }
                
        # Intervalles pour les postes personnalisés
        for post_name in self.custom_posts.keys():
            if post_name in doctor_distribution.get('weekend_posts', {}):
                intervals[post_name] = {
                    'min': doctor_distribution['weekend_posts'][post_name]['min'],
                    'max': doctor_distribution['weekend_posts'][post_name]['max']
                }
                
        return intervals

    def _sort_doctors_by_unavailability(self, planning: Planning) -> List[Doctor]:
        """
        Trie les médecins par ordre décroissant d'indisponibilités weekend.
        Ajoute un facteur aléatoire pour éviter la monotonie.
        """
        doctor_unavailability = {}
        
        for doctor in self.doctors:
            weekend_unavailable = 0
            for desiderata in doctor.desiderata:
                # Compte les weekends dans la période de desiderata
                current_date = max(desiderata.start_date, planning.start_date)
                end_date = min(desiderata.end_date, planning.end_date)
                
                while current_date <= end_date:
                    if (current_date.weekday() >= 5 or 
                        self.cal.is_holiday(current_date) or
                        self.is_bridge_day(current_date)):
                        weekend_unavailable += 1
                    current_date += timedelta(days=1)
                    
            # Ajout d'un facteur aléatoire (±10%)
            random_factor = 1 + (random.random() * 0.2 - 0.1)
            doctor_unavailability[doctor.name] = weekend_unavailable * random_factor

        # Tri par indisponibilité décroissante en utilisant le nom comme clé
        return sorted(self.doctors, 
                    key=lambda d: doctor_unavailability[d.name], 
                    reverse=True)

    def _distribute_critical_period(self, date: date, sorted_doctors: List[Doctor],
                                doctor_counts: Dict, available_combinations: Dict,
                                planning: Planning) -> bool:
        """
        Distribution prioritaire pour une période critique.
        """
        try:
            # Identifier le type de jour
            is_saturday = date.weekday() == 5 and not self.is_bridge_day(date)
            day_type = "saturday" if is_saturday else "sunday_holiday"
            
            # Filtrer les médecins disponibles pour cette date
            available_doctors = [
                doctor for doctor in sorted_doctors
                if self._is_doctor_available_for_date(doctor, date, planning)
            ]
            
            if not available_doctors:
                logger.warning(f"Aucun médecin disponible pour {date}")
                return False
                
            combinations_assigned = 0
            max_combinations = len(available_combinations[day_type])
            
            # Attribution des combinaisons
            for doctor in available_doctors:
                if combinations_assigned >= max_combinations:
                    break
                    
                # Tenter d'attribuer une combinaison appropriée
                combo = self._get_best_combination_for_doctor(
                    doctor, date, available_combinations[day_type],
                    doctor_counts[doctor.name], planning
                )
                
                if combo and self._try_assign_combination(
                    doctor, combo, date, doctor_counts[doctor.name], planning
                ):
                    combinations_assigned += 1
                    logger.info(f"{doctor.name}: {combo} attribué pour {date}")
                    
            return combinations_assigned > 0
            
        except Exception as e:
            logger.error(f"Erreur distribution période critique {date}: {e}")
            return False

    def _is_doctor_available_for_date(self, doctor: Doctor, date: date, 
                                planning: Planning) -> bool:
        """
        Vérifie la disponibilité d'un médecin pour une date donnée.
        """
        # Vérifier les desiderata
        for desiderata in doctor.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                return False
                
        # Vérifier les postes déjà attribués ce jour
        day = planning.get_day(date)
        if day:
            return not any(slot.assignee == doctor.name for slot in day.slots)
            
        return True

    def _get_best_combination_for_doctor(self, doctor: Doctor, date: date,
                                    available_combinations: List[str],
                                    doctor_state: Dict,
                                    planning: Planning) -> Optional[str]:
        """
        Sélectionne la meilleure combinaison pour un médecin.
        Prend en compte les limites max et l'équilibre des postes.
        """
        suitable_combinations = []
        
        for combo in available_combinations:
            # Vérifier si la combinaison est possible
            if self._can_assign_combination(doctor, combo, date, 
                                        doctor_state, planning):
                # Calcul du score de pertinence
                score = self._calculate_combination_score(
                    combo, doctor_state, doctor.half_parts
                )
                suitable_combinations.append((combo, score))
                
        if not suitable_combinations:
            return None
                
        # Sélection pondérée par le score
        total_score = sum(score for _, score in suitable_combinations)
        if total_score == 0:
            return None
                
        random_value = random.uniform(0, total_score)
        current_sum = 0
        
        for combo, score in suitable_combinations:
            current_sum += score
            if current_sum >= random_value:
                return combo
                    
        return suitable_combinations[-1][0] if suitable_combinations else None

    def _calculate_combination_score(self, combo: str, doctor_state: Dict,
                                half_parts: int) -> float:
        """
        Calcule un score de pertinence pour une combinaison.
        Prend en compte:
        - L'écart aux intervalles idéaux
        - Le nombre de demi-parts du médecin
        - L'historique des attributions
        """
        score = 10.0  # Score de base
        
        # Pénaliser si proche des maximums
        for post in self._get_posts_from_combo(combo):
            if post in doctor_state['intervals']:
                current = doctor_state['posts'].get(post, 0)
                max_val = doctor_state['intervals'][post]['max']
                if max_val > 0:
                    ratio = current / max_val
                    score *= (1 - ratio)  # Réduction progressive du score
        
        # Bonus pour les combinaisons moins utilisées
        combo_count = doctor_state['combinations'].get(combo, 0)
        score *= (1 + (3 - combo_count) * 0.2)  # +20% par combo manquant
        
        # Ajustement selon les demi-parts
        score *= 1.2 if half_parts == 2 else 0.8
        
        # Facteur aléatoire (±10%)
        score *= 1 + (random.random() * 0.2 - 0.1)
        
        return max(0.1, score)  # Score minimum pour garder une chance

    def _distribute_remaining_combinations(self, doctor_counts: Dict,
                                    available_combinations: Dict,
                                    planning: Planning) -> bool:
        """
        Distribution des combinaisons restantes de manière équilibrée.
        """
        try:
            remaining_dates = self._get_remaining_weekend_dates(planning)
            if not remaining_dates:
                return True
                
            # Organisation par type de jour
            dates_by_type = {
                "saturday": [],
                "sunday_holiday": []
            }
            
            for date in remaining_dates:
                if date.weekday() == 5 and not self.is_bridge_day(date):
                    dates_by_type["saturday"].append(date)
                else:
                    dates_by_type["sunday_holiday"].append(date)
                    
            # Distribution pour chaque type de jour
            for day_type, dates in dates_by_type.items():
                if not dates:
                    continue
                    
                logger.info(f"\nDistribution {day_type}:")
                random.shuffle(dates)  # Ordre aléatoire
                
                for date in dates:
                    available_doctors = self._get_available_doctors_weighted(
                        date, doctor_counts, planning
                    )
                    
                    if not available_doctors:
                        logger.warning(f"Aucun médecin disponible pour {date}")
                        continue
                        
                    # Distribution pondérée
                    assignments_made = self._distribute_day_combinations(
                        date, available_doctors, doctor_counts,
                        available_combinations[day_type], planning
                    )
                    
                    if not assignments_made:
                        logger.warning(f"Impossible de distribuer pour {date}")
                        
            return True
            
        except Exception as e:
            logger.error(f"Erreur distribution générale: {e}")
            return False
    def _get_available_doctors_weighted(self, date: date, doctor_counts: Dict,
                                    planning: Planning) -> List[Tuple[Doctor, float]]:
        """
        Retourne les médecins disponibles avec leur pondération.
        """
        weighted_doctors = []
        
        for doctor in self.doctors:
            if not self._is_doctor_available_for_date(doctor, date, planning):
                continue
                
            # Calcul du poids basé sur plusieurs facteurs
            weight = self._calculate_doctor_weight(
                doctor, doctor_counts[doctor.name], date, planning
            )
            
            if weight > 0:
                weighted_doctors.append((doctor, weight))
                
        return sorted(weighted_doctors, key=lambda x: x[1], reverse=True)

    def _calculate_doctor_weight(self, doctor: Doctor, doctor_state: Dict, 
                            date: date, planning: Planning) -> float:
        """
        Calcule le poids d'un médecin pour la distribution.
        Prend en compte:
        - Le nombre de combinaisons reçues
        - Les demi-parts du médecin 
        - Le temps depuis la dernière attribution
        - L'atteinte des intervalles cibles
        """
        # 1. Calcul du poids basé sur les combinaisons reçues
        total_combos = doctor_state.get('total_combinations', 0)
        max_combos = max((state.get('total_combinations', 0) 
                for state in self._get_all_doctor_states(planning)), default=1)
        combo_weight = 1 - (total_combos / max_combos) if max_combos > 0 else 1.0

        # 2. Poids basé sur les demi-parts
        half_parts_weight = 1.2 if doctor.half_parts == 2 else 0.8

        # 3. Poids basé sur le temps depuis la dernière attribution
        last_weekend = self._get_last_weekend_date(doctor, planning)
        if last_weekend:
            days_since = (date - last_weekend).days
            time_weight = min(1.5, days_since / 14)  # Bonus max après 2 semaines
        else:
            time_weight = 1.5  # Bonus pour première attribution

        # 4. Poids basé sur les intervalles
        interval_weights = []
        for post_type, interval in doctor_state['intervals'].items():
            current = doctor_state['posts'].get(post_type, 0)
            if interval['max'] > 0:
                ratio = current / interval['max']
                interval_weights.append(1 - ratio)
        
        interval_weight = (sum(interval_weights) / len(interval_weights)) if interval_weights else 1.0
        
        # Combinaison des facteurs avec pondération
        base_weight = (combo_weight * 0.4 + 
                    half_parts_weight * 0.2 + 
                    time_weight * 0.2 + 
                    interval_weight * 0.2)
        
        random_factor = 1 + (random.random() * 0.2 - 0.1)  # ±10%
        return max(0.1, base_weight * random_factor)


    def _get_last_weekend_date(self, doctor: Doctor, planning: Planning) -> Optional[date]:
        """
        Trouve la date du dernier weekend où le médecin a été assigné.
        """
        last_date = None
        for day in reversed(planning.days):
            if not (day.date.weekday() >= 5 or 
                    self.cal.is_holiday(day.date) or
                    self.is_bridge_day(day.date)):
                continue
                
            if any(slot.assignee == doctor.name for slot in day.slots):
                last_date = day.date
                break
                
        return last_date

    def _distribute_day_combinations(self, date: date, 
                                weighted_doctors: List[Tuple[Doctor, float]],
                                doctor_counts: Dict, 
                                available_combinations: List[str],
                                planning: Planning) -> bool:
        """
        Distribue les combinaisons pour un jour donné aux médecins en trois passes :
        1. Première passe : priorité aux médecins sans combinaison
        2. Deuxième passe : compléter pour les médecins sous la moyenne
        3. Troisième passe : maximiser l'utilisation des combinaisons restantes
        """
        try:
            assignments_made = False
            remaining_combinations = available_combinations.copy()
            if not remaining_combinations:
                return False

            # Calculer la moyenne actuelle des combinaisons
            total_combinations = sum(state['total_combinations'] 
                                for state in doctor_counts.values())
            nb_doctors = len(self.doctors)
            average_combinations = total_combinations / nb_doctors if nb_doctors > 0 else 0
            
            logger.debug(f"Moyenne actuelle: {average_combinations:.2f} combinaisons par médecin")

            # Première passe : médecins sans combinaison
            doctors_no_combo = sorted(
                [d for d, w in weighted_doctors if doctor_counts[d.name]['total_combinations'] == 0],
                key=lambda d: doctor_counts[d.name]['total_combinations']
            )
            
            if doctors_no_combo:
                logger.debug(f"Passe 1: {len(doctors_no_combo)} médecins sans combinaison")
                for doctor in doctors_no_combo:
                    if not remaining_combinations:
                        break
                        
                    combo = self._get_best_combination_for_doctor(
                        doctor, date, remaining_combinations,
                        doctor_counts[doctor.name], planning
                    )
                    
                    if combo and self._try_assign_combination(
                        doctor, combo, date, doctor_counts[doctor.name], planning
                    ):
                        remaining_combinations.remove(combo)
                        assignments_made = True
                        logger.info(f"Passe 1: {doctor.name}: {combo} attribué")

            # Deuxième passe : médecins sous la moyenne
            if remaining_combinations:
                doctors_under_avg = sorted(
                    [d for d, w in weighted_doctors 
                    if doctor_counts[d.name]['total_combinations'] < average_combinations],
                    key=lambda d: doctor_counts[d.name]['total_combinations']
                )
                
                if doctors_under_avg:
                    logger.debug(f"Passe 2: {len(doctors_under_avg)} médecins sous la moyenne")
                    for doctor in doctors_under_avg:
                        if not remaining_combinations:
                            break
                            
                        combo = self._get_best_combination_for_doctor(
                            doctor, date, remaining_combinations,
                            doctor_counts[doctor.name], planning
                        )
                        
                        if combo and self._try_assign_combination(
                            doctor, combo, date, doctor_counts[doctor.name], planning
                        ):
                            remaining_combinations.remove(combo)
                            assignments_made = True
                            logger.info(f"Passe 2: {doctor.name}: {combo} attribué")

            # Troisième passe : tenter d'attribuer les combinaisons restantes
            if remaining_combinations:
                # Filtrer les médecins qui peuvent encore recevoir des combinaisons
                available_doctors = [
                    d for d, w in weighted_doctors
                    if self._can_receive_more_combinations(d, doctor_counts[d.name])
                ]
                
                if available_doctors:
                    logger.debug(f"Passe 3: {len(available_doctors)} médecins disponibles "
                            f"pour {len(remaining_combinations)} combinaisons restantes")
                    
                    # Trier par nombre croissant de combinaisons pour maintenir l'équilibre
                    available_doctors.sort(
                        key=lambda d: doctor_counts[d.name]['total_combinations']
                    )
                    
                    for doctor in available_doctors:
                        if not remaining_combinations:
                            break
                            
                        combo = self._get_best_combination_for_doctor(
                            doctor, date, remaining_combinations,
                            doctor_counts[doctor.name], planning
                        )
                        
                        if combo and self._try_assign_combination(
                            doctor, combo, date, doctor_counts[doctor.name], planning
                        ):
                            remaining_combinations.remove(combo)
                            assignments_made = True
                            logger.info(f"Passe 3: {doctor.name}: {combo} attribué")

            # Log du résultat
            combinations_used = len(available_combinations) - len(remaining_combinations)
            if assignments_made:
                logger.info(f"Distribution réussie pour {date}: {combinations_used} "
                        f"combinaisons attribuées sur {len(available_combinations)}")
            else:
                logger.warning(f"Aucune attribution pour {date}")

            return assignments_made

        except Exception as e:
            logger.error(f"Erreur dans la distribution des combinaisons du jour {date}: {e}")
            return False

    def _can_receive_more_combinations(self, doctor: Doctor, doctor_state: Dict) -> bool:
        """
        Vérifie si un médecin peut encore recevoir des combinaisons
        en fonction de ses limites pour chaque type de poste.
        """
        for post_type, interval in doctor_state['intervals'].items():
            current = doctor_state['posts'].get(post_type, 0)
            if current < interval['max']:
                return True
        return False
    def _can_assign_combination(self, doctor: Doctor, combo: str, date: date,
                            doctor_state: Dict, planning: Planning) -> bool:
        """
        Vérifie si une combinaison peut être attribuée à un médecin.
        """
        try:
            # Vérification des desiderata
            if not self._is_doctor_available_for_date(doctor, date, planning):
                return False
            
            # Vérifier si c'est une combinaison personnalisée
            if combo in sum([list(p.possible_combinations.values()) 
                            for p in self.custom_posts.values()], []):
                for custom_post in self.custom_posts.values():
                    if combo in custom_post.possible_combinations.values():
                        first_post = custom_post.name
                        second_post = next(post for post, combo_name 
                                        in custom_post.possible_combinations.items() 
                                        if combo_name == combo)
                        break
            else:
                first_post, second_post = combo[:2], combo[2:]
            
            # Vérification des limites maximales pour chaque poste
            for post in [first_post, second_post]:
                current_count = doctor_state['posts'].get(post, 0)
                if post in doctor_state['intervals']:
                    max_allowed = doctor_state['intervals'][post]['max']
                    if current_count >= max_allowed:
                        logger.debug(f"{doctor.name}: Maximum atteint pour {post}")
                        return False
                        
            # Vérification des contraintes de temps
            day = planning.get_day(date)
            if not day:
                return False
                
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)
                            
            if not (first_slot and second_slot):
                return False
                
            # Vérification des contraintes globales
            if not (self.constraints.can_assign_to_assignee(doctor, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(doctor, date, second_slot, planning)):
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Erreur vérification combinaison {combo} pour {doctor.name}: {e}")
            return False

    def _try_assign_combination(self, doctor: Doctor, combo: str, date: date,
                            doctor_state: Dict, planning: Planning) -> bool:
        """
        Tente d'attribuer une combinaison à un médecin.
        """
        try:
            day = planning.get_day(date)
            if not day:
                return False
                
            # Extraction des postes de la combinaison
            if combo in sum([list(p.possible_combinations.values()) 
                            for p in self.custom_posts.values()], []):
                for custom_post in self.custom_posts.values():
                    if combo in custom_post.possible_combinations.values():
                        first_post = custom_post.name
                        second_post = next(post for post, combo_name 
                                        in custom_post.possible_combinations.items() 
                                        if combo_name == combo)
                        break
            else:
                first_post, second_post = combo[:2], combo[2:]
            
            # Recherche des slots disponibles
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)
                            
            if not (first_slot and second_slot):
                return False
                
            # Attribution des slots
            first_slot.assignee = doctor.name
            second_slot.assignee = doctor.name
            
            # Mise à jour des compteurs
            doctor_state['posts'][first_post] = doctor_state['posts'].get(first_post, 0) + 1
            doctor_state['posts'][second_post] = doctor_state['posts'].get(second_post, 0) + 1
            doctor_state['combinations'][combo] = doctor_state['combinations'].get(combo, 0) + 1
            doctor_state['total_combinations'] += 1
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur attribution {combo} à {doctor.name}: {e}")
            return False

    def _get_available_doctor_combinations(self, planning: Planning) -> Dict[str, List[str]]:
        """
        Récupère les combinaisons disponibles pour les médecins sur le weekend.
        Retourne un dictionnaire séparé pour samedi et dimanche/férié.
        """
        combinations = {
            "saturday": [],
            "sunday_holiday": []
        }
        
        pre_analysis = planning.pre_analysis_results
        if not pre_analysis or 'adjusted_posts' not in pre_analysis:
            return combinations
        
        # Récupération des quotas ajustés pour les médecins
        for day_type in ["saturday", "sunday_holiday"]:
            quotas = pre_analysis['adjusted_posts'][day_type]
            
            # Ajout des combinaisons standards
            for combo in WEEKEND_COMBINATIONS:
                first_post, second_post = combo[:2], combo[2:]
                if quotas.get(first_post, 0) > 0 and quotas.get(second_post, 0) > 0:
                    combinations[day_type].append(combo)
                    
            # Ajout des combinaisons personnalisées
            for post_name, custom_post in self.custom_posts.items():
                if custom_post.assignment_type in ['doctors', 'both']:
                    if day_type in custom_post.day_types:
                        quota_custom = quotas.get(post_name, 0)
                        if quota_custom > 0:
                            for other_post, combo_name in custom_post.possible_combinations.items():
                                if quotas.get(other_post, 0) > 0:
                                    combinations[day_type].append(combo_name)
        
        return combinations

    def _get_remaining_weekend_dates(self, planning: Planning) -> List[date]:
        """
        Récupère les dates weekend restantes où il y a encore des slots non assignés.
        """
        remaining_dates = []
        
        for day in planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge):
                continue
                
            # Vérifier s'il reste des slots non assignés
            unassigned_slots = [slot for slot in day.slots if not slot.assignee]
            if unassigned_slots:
                remaining_dates.append(day.date)
        
        return remaining_dates

    def _get_posts_from_combo(self, combo: str) -> Tuple[str, str]:
        """
        Extrait les deux postes d'une combinaison, en gérant les cas personnalisés.
        Retourne un tuple (premier_poste, second_poste).
        """
        # Vérifier si c'est une combinaison personnalisée
        for custom_post in self.custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post
        
        # Combinaison standard
        return combo[:2], combo[2:]
    def _get_all_doctor_states(self, planning: Planning) -> List[Dict]:
        """
        Récupère l'état de distribution pour tous les médecins.
        Utilisé pour calculer les maximums globaux.
        """
        states = []
        for day in planning.days:
            for slot in day.slots:
                if slot.assignee:
                    doctor_state = next(
                        (state for state in states 
                        if state.get('doctor_name') == slot.assignee),
                        None
                    )
                    if not doctor_state:
                        doctor_state = {
                            'doctor_name': slot.assignee,
                            'total_combinations': 0
                        }
                        states.append(doctor_state)
                    # Compte uniquement les combinaisons weekend
                    if day.is_weekend or day.is_holiday_or_bridge:
                        doctor_state['total_combinations'] += 1
        return states


    def _verify_doctor_distribution(self, doctor_counts: Dict, planning: Planning) -> bool:
        """
        Vérifie et log la distribution finale des combinaisons aux médecins.
        """
        logger.info("\nVÉRIFICATION FINALE DE LA DISTRIBUTION")
        logger.info("=" * 60)
        
        all_ok = True
        for doctor in self.doctors:
            logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
            state = doctor_counts[doctor.name]
            
            # Vérification des postes
            logger.info("Postes attribués:")
            for post_type, count in sorted(state['posts'].items()):
                if count > 0:
                    if post_type in state['intervals']:
                        min_val = state['intervals'][post_type]['min']
                        max_val = state['intervals'][post_type]['max']
                        status = "OK"
                        if count < min_val:
                            status = "SOUS MIN"
                            all_ok = False
                        elif count > max_val:
                            status = "SUR MAX"
                            all_ok = False
                        logger.info(f"{post_type:4}: {count:2d} [{min_val}-{max_val}] {status}")
                    else:
                        logger.info(f"{post_type:4}: {count:2d}")
            
            # Vérification des combinaisons
            logger.info("\nCombinaisons utilisées:")
            for combo, count in sorted(state['combinations'].items()):
                if count > 0:
                    logger.info(f"{combo}: {count}")
            logger.info(f"Total combinaisons: {state['total_combinations']}")
            
        return all_ok

# core/Constantes/data_persistence.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/data_persistence.py
import logging
import datetime
import pickle
import os
from core.Constantes.models import Doctor, CAT, DailyPostConfiguration, PostConfig, create_default_post_configuration, Desiderata, SpecificPostConfig
from core.Constantes.custom_post import CustomPost

logger = logging.getLogger(__name__)

class DataPersistence:
    def __init__(self, filename='app_data.pkl'):
        self.filename = filename
        self.custom_posts_filename = 'custom_posts.pkl'
        

    def save_data(self, doctors, cats, post_configuration):
        logger.info("Starting save_data process")
        data = {
            'version': 1,
            'doctors': [{
                'name': d.name,
                'half_parts': d.half_parts,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period
                } for des in d.desiderata]
            } for d in doctors],
            'cats': [{
                'name': c.name,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period
                } for des in c.desiderata]
            } for c in cats],
            'post_configuration': self.serialize_post_configuration(post_configuration)
        }
        
        with open(self.filename, 'wb') as file:
            pickle.dump(data, file)
        logger.info("Data saved successfully")

    def save_custom_posts(self, custom_posts_data):
        """Sauvegarde les postes personnalisés dans un fichier séparé"""
        try:
            with open(self.custom_posts_filename, 'wb') as file:
                pickle.dump(custom_posts_data, file)
            logger.info("Custom posts saved successfully")
        except Exception as e:
            logger.error(f"Error saving custom posts: {e}")

    def load_custom_posts(self):
        """Charge les postes personnalisés"""
        try:
            if os.path.exists(self.custom_posts_filename):
                with open(self.custom_posts_filename, 'rb') as file:
                    custom_posts_data = pickle.load(file)
                    # Conversion explicite en objets CustomPost
                    custom_posts = {}
                    for name, data in custom_posts_data.items():
                        try:
                            if isinstance(data, dict):
                                # Si c'est un dictionnaire, convertir en CustomPost
                                custom_posts[name] = CustomPost.from_dict(data)
                            else:
                                # Si c'est déjà un CustomPost, l'utiliser tel quel
                                custom_posts[name] = data
                            logger.info(f"Poste personnalisé chargé: {name}")
                        except Exception as e:
                            logger.error(f"Erreur lors de la conversion du poste {name}: {e}")
                            continue
                    return custom_posts
            return {}
        except Exception as e:
            logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")
            return {}

    def load_data(self):
        logger.info("Starting load_data process")
        if os.path.exists(self.filename):
            try:
                with open(self.filename, 'rb') as file:
                    data = pickle.load(file)
                
                logger.debug(f"Raw loaded data: {data}")
                
                data = self.migrate_data(data)
                
                # Charger les médecins et CAT d'abord
                doctors = [Doctor(d['name'], d['half_parts'], [
                    Desiderata(
                        datetime.date.fromisoformat(des['start_date']),
                        datetime.date.fromisoformat(des['end_date']),
                        des['type'],
                        des['period']
                    )
                    for des in d.get('desiderata', [])
                ]) for d in data.get('doctors', [])]
                
                cats = [CAT(
                    c['name'],
                    desiderata=[
                        Desiderata(
                            datetime.date.fromisoformat(des['start_date']),
                            datetime.date.fromisoformat(des['end_date']),
                            des['type'],
                            des['period']
                        )
                        for des in c.get('desiderata', [])
                    ]
                ) for c in data.get('cats', [])]
                
                # Charger la configuration des postes
                post_config_data = data.get('post_configuration', {})
                post_configuration = DailyPostConfiguration()
                
                if isinstance(post_config_data, dict):
                    post_configuration.weekday = self._deserialize_post_config(post_config_data.get('weekday', {}))
                    post_configuration.saturday = self._deserialize_post_config(post_config_data.get('saturday', {}))
                    post_configuration.sunday_holiday = self._deserialize_post_config(post_config_data.get('sunday_holiday', {}))
                    post_configuration.cat_weekday = self._deserialize_post_config(post_config_data.get('cat_weekday', {}))
                    post_configuration.cat_saturday = self._deserialize_post_config(post_config_data.get('cat_saturday', {}))
                    post_configuration.cat_sunday_holiday = self._deserialize_post_config(post_config_data.get('cat_sunday_holiday', {}))

                    # Charger les configurations spécifiques avec validation des dates
                    specific_configs = []
                    for config in post_config_data.get('specific_configs', []):
                        try:
                            start_date = datetime.date.fromisoformat(config['start_date'])
                            end_date = datetime.date.fromisoformat(config['end_date'])
                            
                            # Vérifier et corriger l'ordre des dates si nécessaire
                            if end_date < start_date:
                                start_date, end_date = end_date, start_date
                                logger.warning(f"Dates inversées corrigées : {start_date} - {end_date}")
                            
                            specific_configs.append(
                                SpecificPostConfig(
                                    start_date=start_date,
                                    end_date=end_date,
                                    apply_to=config.get('apply_to', config.get('day_type')),
                                    post_counts=config['post_counts']
                                )
                            )
                        except ValueError as e:
                            logger.error(f"Erreur lors du chargement d'une configuration spécifique : {e}")
                            logger.error(f"Configuration ignorée : {config}")
                            continue

                    post_configuration.specific_configs = specific_configs

                logger.info("Data loaded successfully")
                return doctors, cats, post_configuration

            except Exception as e:
                logger.error(f"Erreur lors du chargement des données : {e}")
                # Créer une nouvelle configuration par défaut
                logger.warning("Création d'une nouvelle configuration par défaut")
                return [], [], create_default_post_configuration()

        logger.warning("No data file found, returning default values")
        return [], [], create_default_post_configuration()

    def parse_date(self, date_input):
        if isinstance(date_input, datetime.date):
            return date_input
        elif isinstance(date_input, str):
            try:
                return datetime.date.fromisoformat(date_input)
            except ValueError:
                try:
                    return datetime.date.fromtimestamp(float(date_input))
                except ValueError:
                    print(f"Impossible de parser la date: {date_input}. Utilisation de la date actuelle.")
                    return datetime.date.today()
        else:
            print(f"Type de date inattendu: {type(date_input)}. Utilisation de la date actuelle.")
            return datetime.date.today()
            
    def migrate_data(self, data):
        version = data.get('version', 0)
        if version < 1:
            # Migration vers la version 1
            for doctor in data.get('doctors', []):
                for des in doctor.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            for cat in data.get('cats', []):
                for des in cat.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            data['version'] = 1
            
            # Ajout de la structure pour les postes personnalisés si elle n'existe pas
            if 'custom_posts' not in data:
                data['custom_posts'] = {}
                
        return data
    
    def serialize_post_configuration(self, post_configuration):
        """Sérialise la configuration des postes"""
        config_data = {
            'weekday': self._serialize_post_config(post_configuration.weekday),
            'saturday': self._serialize_post_config(post_configuration.saturday),
            'sunday_holiday': self._serialize_post_config(post_configuration.sunday_holiday),
            'cat_weekday': self._serialize_post_config(post_configuration.cat_weekday),
            'cat_saturday': self._serialize_post_config(post_configuration.cat_saturday),
            'cat_sunday_holiday': self._serialize_post_config(post_configuration.cat_sunday_holiday),
            'specific_configs': []
        }

        # Sérialisation des configurations spécifiques
        if hasattr(post_configuration, 'specific_configs'):
            config_data['specific_configs'] = [{
                'start_date': config.start_date.isoformat(),
                'end_date': config.end_date.isoformat(),
                'apply_to': config.apply_to,
                'post_counts': config.post_counts
            } for config in post_configuration.specific_configs]

        return config_data

    def deserialize_post_configuration(self, config_data):
        """Désérialise la configuration des postes"""
        post_configuration = DailyPostConfiguration()
        
        if isinstance(config_data, dict):
            # Configuration standard
            post_configuration.weekday = self._deserialize_post_config(config_data.get('weekday', {}))
            post_configuration.saturday = self._deserialize_post_config(config_data.get('saturday', {}))
            post_configuration.sunday_holiday = self._deserialize_post_config(config_data.get('sunday_holiday', {}))
            post_configuration.cat_weekday = self._deserialize_post_config(config_data.get('cat_weekday', {}))
            post_configuration.cat_saturday = self._deserialize_post_config(config_data.get('cat_saturday', {}))
            post_configuration.cat_sunday_holiday = self._deserialize_post_config(config_data.get('cat_sunday_holiday', {}))
            
            # Désérialisation des configurations spécifiques
            post_configuration.specific_configs = []
            for config in config_data.get('specific_configs', []):
                try:
                    specific_config = SpecificPostConfig(
                        start_date=datetime.date.fromisoformat(config['start_date']),
                        end_date=datetime.date.fromisoformat(config['end_date']),
                        apply_to=config['apply_to'],
                        post_counts=config['post_counts']
                    )
                    post_configuration.specific_configs.append(specific_config)
                except (ValueError, KeyError) as e:
                    self.logger.error(f"Erreur lors de la désérialisation d'une configuration spécifique : {e}")
                    self.logger.error(f"Configuration ignorée : {config}")
                    continue

        return post_configuration

    def _serialize_post_config(self, config):
        """Sérialise une configuration de poste simple"""
        return {post_type: post_config.total for post_type, post_config in config.items()}

    def _deserialize_post_config(self, data):
        """Désérialise une configuration de poste simple"""
        return {post_type: PostConfig(total=total) for post_type, total in data.items()}

    def debug_dates(self, doctors, cats):
        print("Debugging dates:")
        for doctor in doctors:
            for des in doctor.desiderata:
                print(f"{doctor.name}: {des}")
        for cat in cats:
            for des in cat.desiderata:
                print(f"{cat.name}: {des}")

# core/Constantes/custom_post.py

# core/Constantes/custom Custom_Post.py


from dataclasses import dataclass, field
from datetime import time
from typing import List, Set, Dict, Optional
from PyQt6.QtGui import QColor

@dataclass
class CustomPost:
    name: str
    start_time: time
    end_time: time
    day_types: Set[str]  # "weekday", "saturday", "sunday_holiday"
    assignment_type: str  # "doctors", "cats", "both"
    possible_combinations: Dict[str, str]  # {post_code: resulting_combination}
    statistic_group: Optional[str]
    color: QColor = field(default_factory=lambda: QColor("#E6F3FF"))

    def __post_init__(self):
        self.validate()

    def validate(self):
        if not 2 <= len(self.name) <= 4:
            raise ValueError("Le nom du poste doit contenir entre 2 et 4 caractères")
        
        if not self.name.replace("_", "").isalnum():
            raise ValueError("Le nom ne peut contenir que des lettres, des chiffres et des underscores")
        
        if not self.day_types:
            raise ValueError("Au moins un type de jour doit être sélectionné")
        
        if self.start_time >= self.end_time:
            raise ValueError("L'heure de début doit être antérieure à l'heure de fin")

    def overlaps_with(self, other_post) -> bool:
        """Vérifie si les horaires se chevauchent avec un autre poste"""
        return not (self.end_time < other_post.start_time or 
                   self.start_time > other_post.end_time)

    def can_combine_with(self, other_post) -> bool:
        """Vérifie si le poste peut être combiné avec un autre poste"""
        if isinstance(other_post, str):
            # Si c'est un poste standard, vérifier dans la configuration standard
            # Vous devrez implémenter cette logique selon vos besoins
            return True
        else:
            # Vérifie que les horaires ne se chevauchent pas
            return not (self.start_time < other_post.end_time and
                    self.end_time > other_post.start_time)

    def to_dict(self) -> dict:
        """Convertit le poste en dictionnaire pour la sauvegarde"""
        return {
            'name': self.name,
            'start_time': self.start_time.strftime('%H:%M'),
            'end_time': self.end_time.strftime('%H:%M'),
            'day_types': list(self.day_types),
            'assignment_type': self.assignment_type,
            'possible_combinations': self.possible_combinations,
            'statistic_group': self.statistic_group,
            'color': self.color.name()
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'CustomPost':
        """Crée un poste à partir d'un dictionnaire"""
        return cls(
            name=data['name'],
            start_time=time.fromisoformat(data['start_time']),
            end_time=time.fromisoformat(data['end_time']),
            day_types=set(data['day_types']),
            assignment_type=data['assignment_type'],
            possible_combinations=data['possible_combinations'],
            statistic_group=data['statistic_group'],
            color=QColor(data['color'])
        )

# core/Constantes/models.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/models.py
from dataclasses import dataclass, field
from datetime import date, datetime, time
from enum import Enum
from typing import List, Dict, Optional, TYPE_CHECKING, Union
import logging
import datetime

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from .models import TimeSlot

ALL_POST_TYPES = [
    "ML","MC", "MM", "CM", "HM", "RM", "SM", "CA", "HA", "RA", "SA", "CS", "HS", "RS", "SS","AL", "AC",
    "NC", "NA", "NM", "NL", "CT"
]
WEEKEND_COMBINATIONS = [
    "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA",
    "CMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS",
    "CMAC", "CMAL", "HMAL", "HMAC", "RMAL", "RMAC", "SMAL", "SMAC",
    "SANA", "RANA", "CANA", "HANA"
]

WEEKDAY_COMBINATIONS = [
    "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA",
    "CMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS",
    "CMAC", "CMAL", "HMAL", "HMAC", "RMAL", "RMAC", "SMAL", "SMAC",
    "SANA", "RANA", "CANA", "HANA"
]

ALL_COMBINATIONS = WEEKEND_COMBINATIONS + [combo for combo in WEEKDAY_COMBINATIONS if combo not in WEEKEND_COMBINATIONS]

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

class DesiderataPeriod(Enum):
    MORNING = 1
    AFTERNOON = 2
    NIGHT = 3



class Desiderata:
    def __init__(self, start_date, end_date, type: str, period: int):
        self.start_date = self._ensure_date(start_date)
        self.end_date = self._ensure_date(end_date)
        self.type = type
        self.period = period


    @staticmethod
    def _ensure_date(date_input):
        if isinstance(date_input, datetime.date):
            return date_input
        elif isinstance(date_input, str):
            try:
                return datetime.date.fromisoformat(date_input)
            except ValueError:
                try:
                    return datetime.datetime.strptime(date_input, "%Y-%m-%d").date()
                except ValueError:
                    return datetime.date.today()
        return datetime.date.today()

    def __repr__(self):
        return f"Desiderata(start_date={self.start_date}, end_date={self.end_date}, type='{self.type}', period={self.period})"

    def overlaps_with_slot(self, slot: 'TimeSlot') -> bool:
        if self.start_date <= slot.start_time.date() <= self.end_date:
            if slot.abbreviation == "CT":
                # Pour CT, vérifier si le desiderata couvre soit le matin soit l'après-midi
                return self.period in [1, 2]  # 1 pour matin, 2 pour après-midi
            else:
                slot_period = self.get_slot_period(slot)
                return self.period == slot_period
        return False

    @staticmethod
    def get_slot_period(slot: 'TimeSlot') -> int:
        if slot.abbreviation == "CT":
            return 4  # Période spéciale pour CT
        start_hour = slot.start_time.hour
        if 7 <= start_hour < 13:
            return 1  # Matin
        elif 13 <= start_hour < 18:
            return 2  # Après-midi
        else:
            return 3  # Soir/Nuit
        
@dataclass
class Doctor:
    name: str
    half_parts: int
    desiderata: List[Desiderata] = field(default_factory=list)
    
    
    # Gardes de nuit pour le weekend
    weekend_night_shifts: Dict[str, int] = field(default_factory=lambda: {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0})
    min_nlw: int = 0
    max_nlw: int = 0
    nam_shifts: Dict[str, int] = field(default_factory=lambda: {'NMs': 0, 'NMd': 0, 'NAs': 0, 'NAd': 0, 'total': 0})

    # Pour NLw
    nl_subtypes_counts: Dict[str, int] = field(default_factory=lambda: {
        'NLv': 0,  # Vendredi
        'NLs': 0,  # Samedi
        'NLd': 0   # Dimanche/Férié
    })
    
    # Pour NAMw
    nam_subtypes_counts: Dict[str, int] = field(default_factory=lambda: {
        'NA': 0,  # Nuit courte
        'NM': 0   # Nuit moyenne
    })
    
    # Gardes de nuit pour la semaine
    weekday_night_shifts: Dict[str, int] = field(default_factory=lambda: {'NL': 0, 'total': 0})
    min_nlw_weekday: int = 0
    max_nlw_weekday: int = 0
    
    # Gardes NM pour le weekend
    nam_shifts: Dict[str, int] = field(default_factory=lambda: {'NMs': 0, 'NMd': 0, 'NAs': 0, 'NAd': 0, 'total': 0})
    min_nam: int = 0
    max_nam: int = 0
    
    # Combinaisons pour le weekend
    combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS})
    min_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS})
    max_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: float('inf') for combo in WEEKEND_COMBINATIONS})
    # Ajout de l'attribut manquant pour les combinaisons weekend
    weekend_combo_counts: Dict[str, int] = field(
        default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS}
    )
    # Combinaisons pour la semaine
    weekday_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKDAY_COMBINATIONS})
    min_weekday_combos: Dict[str, int] = field(default_factory=dict)
    max_weekday_combos: Dict[str, int] = field(default_factory=dict)
    
    # Groupes pour le weekend
    group_counts: Dict[str, Union[int, Dict[str, int]]] = field(default_factory=lambda: {
        "CsSD": {"CS": 0, "HS": 0, "RS": 0, "SS": 0, "total": 0},
        "VmS": 0, "VmD": 0, "VaSD": 0, "CmS": 0, "CmD": 0, "CaSD": 0, "NAMw": 0, "NLw": 0
    })
    
    # Groupes pour la semaine
    weekday_group_counts: Dict[str, int] = field(default_factory=lambda: {
    group: 0 for group in ["XM", "XA", "XS", "MM", "NM", "NC", "ML"]  # Vérifions ici
    })
    
    # Nouveaux attributs pour les postes de semaine
    weekday_post_counts: Dict[str, int] = field(default_factory=lambda: {post_type: 0 for post_type in ALL_POST_TYPES})
    min_weekday_posts: Dict[str, int] = field(default_factory=lambda: {post_type: 0 for post_type in ALL_POST_TYPES})
    max_weekday_posts: Dict[str, int] = field(default_factory=lambda: {post_type: float('inf') for post_type in ALL_POST_TYPES})
    
    cs_count: int = 0
    post_type_counts: Dict[str, int] = field(default_factory=dict)
    min_combos: Dict[str, int] = field(default_factory=dict)
    max_combos: Dict[str, int] = field(default_factory=dict)
    min_weekday_combos: Dict[str, int] = field(default_factory=dict)
    max_weekday_combos: Dict[str, int] = field(default_factory=dict)

    def __post_init__(self):
        """Initialisation post-création"""
        # S'assurer que toutes les combinaisons possibles sont initialisées
        for combo in WEEKEND_COMBINATIONS:
            if combo not in self.combo_counts:
                self.combo_counts[combo] = 0
            if combo not in self.min_combo_counts:
                self.min_combo_counts[combo] = 0
            if combo not in self.max_combo_counts:
                self.max_combo_counts[combo] = float('inf')
        
        for combo in WEEKDAY_COMBINATIONS:
            if combo not in self.weekday_combo_counts:
                self.weekday_combo_counts[combo] = 0
            if combo not in self.min_weekday_combos:
                self.min_weekday_combos[combo] = 0
            if combo not in self.max_weekday_combos:
                self.max_weekday_combos[combo] = float('inf')
            
    def can_work_shift(self, date: date, shift: 'TimeSlot') -> bool:
        if shift.abbreviation == "CT":
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.period in [1, 2]:  # Matin ou après-midi
                        return False
            return True
        else:
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.overlaps_with_slot(shift):
                        return False
            return True

    def update_shift_count(self, shift_type: str, is_weekend: bool):
        if is_weekend:
            if shift_type.startswith('NL'):
                self.weekend_night_shifts[shift_type] += 1
                self.weekend_night_shifts['total'] += 1
            elif shift_type.startswith('NM'):
                self.nm_shifts[shift_type] += 1
                self.nm_shifts['total'] += 1
        else:
            if shift_type == 'NL':
                self.weekday_night_shifts['NL'] += 1
                self.weekday_night_shifts['total'] += 1
            elif shift_type == 'NM':
                self.weekday_nm_shifts['NM'] += 1
                self.weekday_nm_shifts['total'] += 1

        self.post_type_counts[shift_type] = self.post_type_counts.get(shift_type, 0) + 1

    def update_combo_count(self, combo: str, is_weekend: bool):
        if is_weekend:
            self.combo_counts[combo] = self.combo_counts.get(combo, 0) + 1
        else:
            self.weekday_combo_counts[combo] = self.weekday_combo_counts.get(combo, 0) + 1

    def update_group_count(self, group: str, is_weekend: bool):
        if is_weekend:
            self.group_counts[group] = self.group_counts.get(group, 0) + 1
        else:
            self.weekday_group_counts[group] = self.weekday_group_counts.get(group, 0) + 1
    
@dataclass
class CAT:
    def __init__(self, name, desiderata=None):
        self.name = name
        self.posts = {}
        self.weekday_posts = {}  # Ajoutez cette ligne
        self.desiderata = desiderata if desiderata is not None else []

class SlotType(Enum):
    CONSULTATION = "Consultation"
    VISITE = "Visite"

class Site(Enum):
    CENON = "Cenon"
    BEYCHAC_ET_CAILLAU = "Beychac et Caillau"
    ST_ANDRE_DE_CUBZAC = "St André de Cubzac"
    CREON = "Créon"
    VISITES = "Visites"

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

@dataclass
class DayPlanning:
    date: date
    slots: List[TimeSlot] = field(default_factory=list)
    is_weekend: bool = False
    is_holiday_or_bridge: bool = False
    planning: Optional['Planning'] = None  # Ajout de la référence au planning parent



@dataclass
class Planning:
    def __init__(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.days: List[DayPlanning] = []
        self.pre_analysis_results = None

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def get_day(self, date: date) -> Optional[DayPlanning]:
        return next((day for day in self.days if day.date == date), None)
    

@dataclass
class CATPostConfiguration:
    weekday: Dict[str, int] = field(default_factory=dict)
    saturday: Dict[str, int] = field(default_factory=dict)
    sunday_holiday: Dict[str, int] = field(default_factory=dict)

@dataclass
class PostConfig:
    total: int = 0

@dataclass
class SpecificPostConfig:
    start_date: date
    end_date: date
    apply_to: str
    post_counts: Dict[str, int]

    # Mapping des types de jours
    DAY_TYPE_MAPPING = {
        "weekday": "Semaine",
        "Semaine": "Semaine",
        "saturday": "Samedi",
        "Samedi": "Samedi",
        "sunday_holiday": "Dimanche/Férié",
        "Dimanche/Férié": "Dimanche/Férié"
    }

    def __post_init__(self):
        """Validation et normalisation après l'initialisation"""
        # Normaliser le type de jour
        normalized_type = self.DAY_TYPE_MAPPING.get(self.apply_to)
        if normalized_type is None:
            raise ValueError(f"Type de jour invalide : {self.apply_to}")
        self.apply_to = normalized_type

        # Vérifier les dates
        if self.start_date.year < 2024:
            if 1900 <= self.start_date.year < 2000:
                self.start_date = self.start_date.replace(year=self.start_date.year + 100)

        if self.end_date.year < 2024:
            if 1900 <= self.end_date.year < 2000:
                self.end_date = self.end_date.replace(year=self.end_date.year + 100)

        # Si les dates sont inversées, les échanger
        if self.end_date < self.start_date:
            self.start_date, self.end_date = self.end_date, self.start_date
            logger.warning(f"Dates inversées automatiquement corrigées pour la période {self.start_date} - {self.end_date}")

    def to_dict(self):
        """Convertit l'objet en dictionnaire"""
        return {
            'start_date': self.start_date.isoformat(),
            'end_date': self.end_date.isoformat(),
            'apply_to': self.apply_to,
            'post_counts': self.post_counts
        }
    @classmethod
    def normalize_day_type(cls, day_type: str) -> str:
        """Normalise le type de jour"""
        normalized = cls.DAY_TYPE_MAPPING.get(day_type)
        if normalized is None:
            raise ValueError(f"Type de jour invalide : {day_type}")
        return normalized

   

    @classmethod
    def from_dict(cls, data):
        """Crée une instance à partir d'un dictionnaire"""
        return cls(
            start_date=datetime.date.fromisoformat(data['start_date']),
            end_date=datetime.date.fromisoformat(data['end_date']),
            apply_to=data['apply_to'],
            post_counts=data['post_counts']
        )

@dataclass
class DailyPostConfiguration:
    weekday: Dict[str, PostConfig] = field(default_factory=dict)
    saturday: Dict[str, PostConfig] = field(default_factory=dict)
    sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_weekday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_saturday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)
    specific_configs: List[SpecificPostConfig] = field(default_factory=list)

    def get_config_for_day_type(self, day_type: str) -> Dict[str, PostConfig]:
        if day_type == "weekday":
            return self.weekday
        elif day_type == "saturday":
            return self.saturday
        elif day_type == "sunday_holiday":
            return self.sunday_holiday
        else:
            raise ValueError(f"Invalid day type: {day_type}")

    def add_specific_config(self, specific_config: SpecificPostConfig):
        self.specific_configs.append(specific_config)
        print(f"Configuration ajoutée : {specific_config}")  # Pour le débogage

    def remove_specific_config(self, specific_config: SpecificPostConfig):
        self.specific_configs.remove(specific_config)

    def get_post_count(self, date: date, day_type: str, post_type: str) -> int:
        # Priorité à la configuration spécifique, si elle existe pour cette date et type de jour
        for config in self.specific_configs:
            if (config.start_date <= date <= config.end_date and
                config.apply_to == day_type and
                post_type in config.post_counts):
                return config.post_counts[post_type]

        # Utilisation de la configuration générale si aucune configuration spécifique n'est trouvée
        if day_type == "weekday":
            return self.weekday.get(post_type, PostConfig()).total
        elif day_type == "saturday":
            return self.saturday.get(post_type, PostConfig()).total
        elif day_type == "sunday_holiday":
            return self.sunday_holiday.get(post_type, PostConfig()).total
        else:
            raise ValueError(f"Invalid day type: {day_type}")


        
    def get_cat_post_count(self, date: date, day_type: str, post_type: str) -> int:
        # Chercher d'abord une configuration spécifique
        for config in self.specific_configs:
            if (config.start_date <= date <= config.end_date and
                config.day_type == day_type and
                config.post_type == post_type):
                return config.count

        # Si aucune configuration spécifique n'est trouvée, utiliser la configuration standard pour les CAT
        if day_type == "weekday":
            return self.cat_weekday.get(post_type, PostConfig()).total
        elif day_type == "saturday":
            return self.cat_saturday.get(post_type, PostConfig()).total
        elif day_type == "sunday_holiday":
            return self.cat_sunday_holiday.get(post_type, PostConfig()).total
        else:
            raise ValueError(f"Invalid day type: {day_type}")
        
def create_default_post_configuration():
    weekday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=0),
        "NC": PostConfig(total=1),
        "AC": PostConfig(total=0),
        "AL": PostConfig(total=0),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=0),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=0),
        "SA": PostConfig(total=0),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=0),
        "RA": PostConfig(total=0),
        "RS": PostConfig(total=1)      
    }

    saturday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=1),
        "NC": PostConfig(total=0),
        "AC": PostConfig(total=1),
        "AL": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=0),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=0),
        "SA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=0),
        "RA": PostConfig(total=1),
        "RS": PostConfig(total=1) 
    }

    sunday_holiday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=1),
        "NC": PostConfig(total=0),
        "AC": PostConfig(total=1),
        "AL": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=1),
        "MM": PostConfig(total=0),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=1),
        "SA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=1),
        "RA": PostConfig(total=1),
        "RS": PostConfig(total=1) 
    }

    # Configuration par défaut pour les CAT
    cat_weekday_config = {
        "NL": PostConfig(total=1),
        "NLv": PostConfig(total=1),  # Ajout de la configuration NLv
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NC": PostConfig(total=1)
    }

    cat_saturday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    cat_sunday_holiday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    return DailyPostConfiguration(
        weekday=weekday_config,
        saturday=saturday_config,
        sunday_holiday=sunday_holiday_config,
        cat_weekday=cat_weekday_config,
        cat_saturday=cat_saturday_config,
        cat_sunday_holiday=cat_sunday_holiday_config
    )



class PostManager:
    """Classe pour gérer les différents types de postes et leurs horaires en fonction du jour de la semaine."""
    
    def __init__(self):
        # Dictionnaire contenant les types de poste pour la semaine
        self.weekday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Créon"},
        }

        # Dictionnaire pour les postes du samedi
        self.saturday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

        # Dictionnaire pour les postes du dimanche et jours fériés
        self.sunday_holiday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

    def get_post_details(self, post_type, day_type):
        """Retourne les détails d'un poste spécifique en fonction du jour (weekday, samedi, dimanche)."""
        if day_type == "weekday":
            return self.weekday_posts.get(post_type, None)
        elif day_type == "saturday":
            return self.saturday_posts.get(post_type, None)
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts.get(post_type, None)

    def get_posts_for_day(self, day_type):
        """Retourne tous les postes disponibles pour un jour donné (semaine, samedi, ou dimanche/jour férié)."""
        if day_type == "weekday":
            return self.weekday_posts
        elif day_type == "saturday":
            return self.saturday_posts
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts


# core/Constantes/day_type.py

#core/Constantes//day_type.py

from datetime import date
from workalendar.europe import France
from typing import List
import logging

logger = logging.getLogger(__name__)

class DayType:
    @staticmethod
    def get_day_type(date: date, cal: France) -> str:
        """
        Détermine le type de jour de manière cohérente.
        Ordre de priorité : pont > férié > dimanche > samedi > semaine
        """
        if DayType.is_bridge_day(date, cal):
            logger.debug(f"{date} est un jour de pont")
            return "sunday_holiday"
        elif cal.is_holiday(date):
            logger.debug(f"{date} est un jour férié")
            return "sunday_holiday"
        elif date.weekday() == 6:  # Dimanche
            return "sunday_holiday"
        elif date.weekday() == 5:  # Samedi
            return "saturday"
        else:
            return "weekday"

    @staticmethod
    def is_bridge_day(day: date, cal: France) -> bool:
        """Détermine si une date est un jour de pont"""
        from datetime import timedelta
        
        # 1) Lundi avant un mardi férié
        if day.weekday() == 0 and cal.is_holiday(day + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if day.weekday() in [4, 5] and cal.is_holiday(day - timedelta(days=1 if day.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if day.weekday() == 5 and cal.is_holiday(day - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= day.weekday() <= 4:
            if (cal.is_holiday(day - timedelta(days=1)) and 
                cal.is_holiday(day + timedelta(days=1))):
                return True
        
        return False

# core/Constantes/constraints.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/Constaints.py
from datetime import datetime, timedelta, date
from typing import Union
from core.Constantes.models import Doctor, CAT, TimeSlot, DayPlanning, Planning

class PlanningConstraints:
    def __init__(self):
        pass

    def can_assign_to_assignee(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        return all([
            self.check_nl_constraint(assignee, date, slot, planning),
            self.check_nm_constraint(assignee, date, slot, planning),
            self.check_nm_na_constraint(assignee, date, slot, planning),
            self.check_time_overlap(assignee, date, slot, planning),
            self.check_max_posts_per_day(assignee, date, slot, planning),
            self.check_desiderata(assignee, date, slot, planning),
            self.check_no_morning_consult_after_nm(assignee, date, slot, planning),
            self.check_consecutive_night_shifts(assignee, date, slot, planning),
            self.check_consecutive_working_days(assignee, date, slot, planning)
        ])


    def check_nl_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        # Vérifier si l'assigné a un NL le jour même ou la veille
        today = planning.get_day(date)
        yesterday = planning.get_day(date - timedelta(days=1))
        tomorrow = planning.get_day(date + timedelta(days=1))

        if today:
            if any(s.assignee == assignee.name and s.abbreviation == "NL" for s in today.slots):
                return False
        if yesterday:
            if any(s.assignee == assignee.name and s.abbreviation == "NL" for s in yesterday.slots):
                return False
        if tomorrow and slot.abbreviation == "NL":
            if any(s.assignee == assignee.name for s in tomorrow.slots):
                return False
        return True
    
    def check_nm_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        today = planning.get_day(date)
        tomorrow = planning.get_day(date + timedelta(days=1))
        
        if today:
            for other_slot in today.slots:
                if other_slot.assignee == assignee.name:
                    if (slot.abbreviation == 'NM' or other_slot.abbreviation == 'NM') and \
                    (slot.start_time < other_slot.end_time and slot.end_time > other_slot.start_time):
                        return False
        
        if tomorrow and slot.abbreviation == 'NM':
            for other_slot in tomorrow.slots:
                if other_slot.assignee == assignee.name:
                    if slot.end_time > other_slot.start_time:
                        return False
        
        return True
    
    def check_nm_na_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            # Si le nouveau poste est NM, vérifier qu'aucun autre poste n'est assigné ce jour-là
            if slot.abbreviation == 'NM':
                return not any(s.assignee == assignee.name for s in day.slots)
            
            # Si un NM est déjà assigné ce jour-là, aucun autre poste ne peut être ajouté
            if any(s.abbreviation == 'NM' and s.assignee == assignee.name for s in day.slots):
                return False
        
        return True

    def check_no_morning_consult_after_nm(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        yesterday = planning.get_day(date - timedelta(days=1))
        tomorrow = planning.get_day(date + timedelta(days=1))
        morning_consults = ['ML', 'MC', 'MM', 'CM', 'HM', 'SM', 'RM']

        # Vérifier si un NM était attribué la veille
        if yesterday and any(s.assignee == assignee.name and s.abbreviation == 'NM' for s in yesterday.slots):
            if slot.abbreviation in morning_consults:
                return False

        # Si on attribue un NM, vérifier qu'il n'y a pas de poste du matin le lendemain
        if slot.abbreviation == 'NM' and tomorrow:
            if any(s.assignee == assignee.name and s.abbreviation in morning_consults for s in tomorrow.slots):
                return False

        return True
    
    def check_consecutive_night_shifts(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        if slot.abbreviation in ['CS', 'HS', 'RS', 'SS', 'NC', 'NM', 'NL', 'NA']:
            count = 0
            for i in range(4):  # Vérifier les 4 jours précédents
                prev_day = planning.get_day(date - timedelta(days=i))
                if prev_day:
                    if any(s.assignee == assignee.name and s.abbreviation in ['CS', 'HS', 'RS', 'SS', 'NC', 'NM', 'NL', 'NA'] for s in prev_day.slots):
                        count += 1
                    else:
                        break
            return count < 5
        return True

    def check_consecutive_working_days(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        count = 0
        for i in range(6):  # Vérifier les 6 jours précédents
            prev_day = planning.get_day(date - timedelta(days=i))
            if prev_day:
                if any(s.assignee == assignee.name for s in prev_day.slots):
                    count += 1
                else:
                    break
        return count < 6

    def check_time_overlap(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            for existing_slot in day.slots:
                if existing_slot.assignee == assignee.name:
                    if (slot.start_time < existing_slot.end_time and 
                        slot.end_time > existing_slot.start_time):
                        return False
        return True

    def check_max_posts_per_day(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            assigned_posts = sum(1 for s in day.slots if s.assignee == assignee.name)
            # On vérifie si le nombre de postes déjà assignés plus le nouveau poste dépasse 2
            return assigned_posts + 1 <= 2
        return True

    def check_desiderata(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        for desiderata in assignee.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                slot_start_hour = slot.start_time.hour
                slot_end_hour = slot.end_time.hour
                if desiderata.period == 1 and slot_start_hour < 13:  # Matin
                    return False
                if desiderata.period == 2 and 13 <= slot_start_hour < 18:  # Après-midi
                    return False
                if desiderata.period == 3 and (slot_start_hour >= 18 or slot_end_hour <= 7):  # Nuit
                    return False
        return True

    

# core/Analyzer/pre_analyzer.py

# core/Analyzer/pre_analyzer.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/pre_analyzer.py

from datetime import date, timedelta, time
from typing import List, Dict, Tuple
from core.Constantes.models import Doctor, CAT, DailyPostConfiguration, Desiderata, PostManager, WEEKEND_COMBINATIONS, WEEKDAY_COMBINATIONS, ALL_COMBINATIONS, ALL_POST_TYPES, PostConfig
from workalendar.europe import France
from core.Constantes.custom_post import CustomPost
from core.Constantes.day_type import DayType
from core.Analyzer.combinations_analyzer import CombinationsAnalyzer
from core.Analyzer.availability_matrix import AvailabilityMatrix


import logging
import math
from core.Constantes.data_persistence import DataPersistence


class PlanningPreAnalyzer:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration: DailyPostConfiguration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.start_date = None
        self.end_date = None 
        self.total_days = 0
        self.cal = France()
        self.logger = logging.getLogger(__name__)
        self.post_manager = PostManager()
        self.custom_posts = self.load_custom_posts()
        self.clean_invalid_custom_posts()
        self.combinations_cache = {"weekday": {}, "weekend": {}}
        # Nouveau : calculer le total des demi-parts
        self.total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        self.full_time_doctors = len([d for d in self.doctors if d.half_parts == 2])
        self.half_time_doctors = len([d for d in self.doctors if d.half_parts == 1])
        self.availability_matrix = None  # Ajout de l'attribut

    
    def clean_invalid_custom_posts(self):
        """Nettoie les postes personnalisés invalides"""
        if not self.custom_posts:
            return

        self.logger.info("Nettoyage des postes personnalisés")
        invalid_posts = []
        valid_config = set()

        # Collecter tous les postes valides depuis la configuration
        for config in [
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday,
            self.post_configuration.cat_weekday,
            self.post_configuration.cat_saturday,
            self.post_configuration.cat_sunday_holiday
        ]:
            valid_config.update(config.keys())

        # Ajouter les postes standard
        valid_config.update(ALL_POST_TYPES)

        # Identifier les postes invalides
        for name in self.custom_posts.keys():
            if name not in valid_config:
                invalid_posts.append(name)
                self.logger.debug(f"Poste personnalisé invalide trouvé: {name}")

        # Supprimer les postes invalides
        for name in invalid_posts:
            del self.custom_posts[name]
            self.logger.info(f"Suppression du poste personnalisé invalide: {name}")

        # Sauvegarder les modifications
        data_persistence = DataPersistence()
        custom_posts_data = {
            name: post.to_dict() 
            for name, post in self.custom_posts.items()
        }
        data_persistence.save_custom_posts(custom_posts_data)
        self.logger.info(f"Postes personnalisés nettoyés. {len(invalid_posts)} postes supprimés")

    def load_custom_posts(self):
        """Charge la configuration des postes personnalisés"""
        data_persistence = DataPersistence()
        custom_posts_data = data_persistence.load_custom_posts()
        
        # Convertir les données en objets CustomPost si ce n'est pas déjà fait
        if custom_posts_data and isinstance(next(iter(custom_posts_data.values())), dict):
            from core.Constantes.custom_post import CustomPost
            return {
                name: CustomPost.from_dict(data) 
                for name, data in custom_posts_data.items()
            }
        return custom_posts_data
    
    def calculate_total_days(self):
        if self.start_date and self.end_date:
            return (self.end_date - self.start_date).days + 1
        return 0

    def set_date_range(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.total_days = self.calculate_total_days()
        # Initialiser la matrice de disponibilités
        self.availability_matrix = AvailabilityMatrix(
            start_date=self.start_date,
            end_date=self.end_date,
            doctors=self.doctors,
            cats=self.cats
        )

    def analyze(self) -> Dict:
        if not self.start_date or not self.end_date or self.start_date > self.end_date:
            raise ValueError("Invalid date range. Please set valid start and end dates.")

        self.logger.info("=" * 100)
        self.logger.info(f"ANALYSE DU PLANNING: {self.start_date.strftime('%d/%m/%Y')} - {self.end_date.strftime('%d/%m/%Y')}")
        self.logger.info("=" * 100)

        # 1. Distribution des jours
        self._log_days_distribution()
        
        # 2. Vérification des configurations spécifiques
        config_errors = self.validate_specific_configs()
        if config_errors:
            self.logger.warning("\nAttention : Des configurations spécifiques se chevauchent !")
            for error in config_errors:
                self.logger.warning(error)

        # 3. Calcul du total des postes
        self.logger.info("\nÉTAPE 1: Calcul du nombre total de postes")
        total_posts = self.analyze_posts()
        self._log_total_posts_distribution(total_posts)

        # 4. Analyse des postes CAT
        self.logger.info("\nÉTAPE 2: Analyse des postes réservés aux CAT")
        cat_posts = self.analyze_cat_posts()
        self._log_cat_posts_distribution(cat_posts)

        # 5. Ajustement des postes après soustraction CAT
        self.logger.info("\nÉTAPE 3: Ajustement des postes pour les médecins")
        adjusted_posts = self.adjust_posts_for_cats(total_posts, cat_posts)
        self._log_adjusted_posts_distribution(adjusted_posts)

        # 6. Analyse du personnel et calcul de la distribution idéale
        personnel_analysis = self.analyze_personnel()
        ideal_distribution = self.analyze_ideal_distribution(adjusted_posts)
        self._log_ideal_distribution(adjusted_posts)

        # 7. Analyse des indisponibilités
        unavailability = self.analyze_unavailability()

        # 8. Distribution des jours
        days_distribution = self._collect_days_distribution()
        
        self._log_analysis_summary(total_posts, cat_posts, adjusted_posts)


        # 9. Analyse des combinaisons - après avoir calculé ideal_distribution
        self.logger.info("\nÉTAPE 4: ANALYSE DES COMBINAISONS")
        combinations_analyzer = CombinationsAnalyzer(
            self.doctors,
            self.cats,
            self.availability_matrix,
            {
                "ideal_distribution": ideal_distribution,
                "weekend_posts": adjusted_posts["saturday"],
                "weekday_posts": adjusted_posts["weekday"],
                "weekend_groups": adjusted_posts["weekend_groups"],
                "weekday_groups": adjusted_posts["weekday_groups"]
            }
        )
        combinations_analysis = combinations_analyzer.analyze()

        return {
            "personnel": personnel_analysis,
            "total_posts": total_posts,
            "cat_posts": cat_posts,
            "adjusted_posts": adjusted_posts,
            "ideal_distribution": ideal_distribution,
            "unavailability": unavailability,
            "days_distribution": days_distribution,
            "combinations_analysis": combinations_analysis
        }

    def _collect_days_distribution(self) -> Dict:
        """Collecte les informations sur la distribution des jours."""
        distribution = {
            'weekdays': [],
            'saturdays': [],
            'sundays': [],
            'holidays': [],
            'bridges': [],
            'specific_dates': {}
        }

        current_date = self.start_date
        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date, self.cal)
            
            if day_type == "sunday_holiday":
                if current_date.weekday() == 6:
                    distribution['sundays'].append(current_date)
                elif self.cal.is_holiday(current_date):
                    distribution['holidays'].append(current_date)
                else:  # C'est un pont
                    distribution['bridges'].append(current_date)
            elif day_type == "saturday":
                distribution['saturdays'].append(current_date)
            else:
                distribution['weekdays'].append(current_date)

            # Ajouter les configurations spécifiques
            if hasattr(self.post_configuration, 'specific_configs'):
                for config in self.post_configuration.specific_configs:
                    if config.start_date <= current_date <= config.end_date:
                        if current_date not in distribution['specific_dates']:
                            distribution['specific_dates'][current_date] = []
                        distribution['specific_dates'][current_date].append({
                            'apply_to': config.apply_to,
                            'post_counts': config.post_counts
                        })

            current_date += timedelta(days=1)

        return distribution
    
    def validate_specific_configs(self) -> List[str]:
        """Vérifie la cohérence des configurations spécifiques"""
        errors = []
        
        # Définir le mapping de normalisation des types de jours
        day_type_mapping = {
            "weekday": "Semaine",
            "Semaine": "Semaine",
            "saturday": "Samedi",
            "Samedi": "Samedi",
            "sunday_holiday": "Dimanche/Férié",
            "Dimanche/Férié": "Dimanche/Férié"
        }
        
        grouped_configs = {
            "Semaine": [],
            "Samedi": [],
            "Dimanche/Férié": []
        }

        # Grouper les configurations par type de jour avec normalisation
        for config in self.post_configuration.specific_configs:
            normalized_type = day_type_mapping.get(config.apply_to)
            if normalized_type is None:
                errors.append(f"Type de jour invalide détecté : {config.apply_to}")
                continue
            grouped_configs[normalized_type].append(config)

        # Vérifier les chevauchements dans chaque groupe
        for day_type, configs in grouped_configs.items():
            sorted_configs = sorted(configs, key=lambda x: x.start_date)
            for i in range(len(sorted_configs) - 1):
                current = sorted_configs[i]
                next_config = sorted_configs[i + 1]
                if current.end_date >= next_config.start_date:
                    errors.append(
                        f"Chevauchement détecté pour {day_type} entre : \n"
                        f"  - {current.start_date.strftime('%d/%m/%Y')} → {current.end_date.strftime('%d/%m/%Y')}\n"
                        f"  - {next_config.start_date.strftime('%d/%m/%Y')} → {next_config.end_date.strftime('%d/%m/%Y')}"
                    )

        # Log des erreurs si présentes
        if errors:
            self.logger.error("\nERREURS DE CONFIGURATION SPÉCIFIQUE:")
            for error in errors:
                self.logger.error(error)

        return errors
    def calculate_total_posts(self) -> Dict:
        """Calculate the total number of posts for the entire period based on the configuration."""
        self.logger.info("Calculating total posts to distribute.")
        total_posts = {"weekday": {}, "saturday": {}, "sunday_holiday": {}}
        current_date = self.start_date

        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date)
            config = self.post_configuration.get_config_for_day_type(day_type)

            for post_type, post_config in config.items():
                if post_type not in total_posts[day_type]:
                    total_posts[day_type][post_type] = 0
                total_posts[day_type][post_type] += post_config.total

            current_date += timedelta(days=1)

        self.logger.info(f"Total posts calculated: {total_posts}")
        return total_posts
    
    def analyze_cat_posts(self) -> Dict:
        """Calculate the total number of posts reserved for CATs."""
        self.logger.info("Analyzing CAT posts.")
        cat_posts = {"weekday": {}, "saturday": {}, "sunday_holiday": {}}

        for day_type in ["weekday", "saturday", "sunday_holiday"]:
            config = getattr(self.post_configuration, f"cat_{day_type}")
            for post_type, post_config in config.items():
                if post_type not in cat_posts[day_type]:
                    cat_posts[day_type][post_type] = 0
                cat_posts[day_type][post_type] += post_config.total

        self.logger.info(f"CAT posts calculated: {cat_posts}")
        return cat_posts

    

    def analyze_reserved_posts_distribution(self, cat_posts: Dict) -> Dict:
        """Analyse la distribution optimale des postes réservés"""
        total_days = (self.end_date - self.start_date).days + 1
        
        # Calculer le nombre total de postes réservés
        total_reserved = sum(sum(posts.values()) for posts in cat_posts.values())
        
        # Calculer l'espacement optimal
        optimal_spacing = max(1, total_days // total_reserved) if total_reserved > 0 else 1
        
        
        
        return {
            "total_reserved": total_reserved,
            "optimal_spacing": optimal_spacing,
           
        }

    



    def analyze_personnel(self) -> Dict:
        total_doctors = len(self.doctors)
        doctors_one_half_part = sum(1 for doctor in self.doctors if doctor.half_parts == 1)
        doctors_two_half_parts = sum(1 for doctor in self.doctors if doctor.half_parts == 2)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        total_cats = len(self.cats)

        self.logger.info("EFFECTIFS:")
        self.logger.info(f"Médecins plein temps: {doctors_two_half_parts:2d}")
        self.logger.info(f"Médecins mi-temps  : {doctors_one_half_part:2d}")
        self.logger.info(f"Total parts        : {total_half_parts:2d}")
        self.logger.info("=" * 100)

        return {
            "total_doctors": total_doctors,
            "doctors_one_half_part": doctors_one_half_part,
            "doctors_two_half_parts": doctors_two_half_parts,
            "total_half_parts": total_half_parts,
            "total_cats": total_cats
        }
 
    def analyze_posts(self) -> Dict:
        """Analyse complète des postes sur la période donnée"""
        self.logger.info("\n" + "="*100)
        self.logger.info(f"ANALYSE DES POSTES: {self.start_date.strftime('%d/%m/%Y')} - {self.end_date.strftime('%d/%m/%Y')}")
        self.logger.info("="*100)

        # Initialisation des compteurs
        all_possible_posts = set(ALL_POST_TYPES)
        if hasattr(self, 'custom_posts'):
            all_possible_posts.update(self.custom_posts.keys())
            self.logger.debug(f"Postes personnalisés ajoutés à l'analyse: {[p for p in self.custom_posts.keys()]}")
        
        posts_analysis = {
            "weekday": {post_type: 0 for post_type in all_possible_posts},
            "saturday": {post_type: 0 for post_type in all_possible_posts},
            "sunday_holiday": {post_type: 0 for post_type in all_possible_posts},
            "weekend_groups": {
                "CmS": 0, "CmD": 0, "CaSD": 0, "CsSD": 0,
                "VmS": 0, "VmD": 0, "VaSD": 0, "NAMw": 0, "NLw": 0
            },
            "weekday_groups": {
                "XmM": 0, "XM": 0, "XA": 0, "XS": 0,
                "NMC": 0, "Vm": 0, "NL": 0, "NLv": 0
            }
        }

        current_date = self.start_date
        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date, self.cal)
            
            normalized_day_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }.get(day_type)
            
            # Recherche de configuration spécifique
            specific_config = next(
                (sc for sc in self.post_configuration.specific_configs 
                if sc.start_date <= current_date <= sc.end_date 
                and sc.apply_to == normalized_day_type),
                None
            )

            for post_type in all_possible_posts:
                # Déterminer le nombre de postes
                if specific_config and post_type in specific_config.post_counts:
                    post_count = specific_config.post_counts[post_type]
                else:
                    config = getattr(self.post_configuration, day_type)
                    post_count = config.get(post_type, PostConfig()).total

                # Traitement spécial des NL
                if post_type == "NL" and day_type == "weekday":
                    if current_date.weekday() == 4:  # Vendredi
                        posts_analysis["weekday_groups"]["NLv"] += post_count
                        posts_analysis["weekend_groups"]["NLw"] += post_count
                    else:
                        posts_analysis["weekday_groups"]["NL"] += post_count
                    posts_analysis["weekday"][post_type] += post_count
                    
                else:
                    posts_analysis[day_type][post_type] += post_count
                    
                    # Mise à jour des groupes selon le type de poste
                    if post_type in self.custom_posts:
                        custom_post = self.custom_posts[post_type]
                        if custom_post.statistic_group:
                            group = custom_post.statistic_group.strip()
                            if day_type == "weekday" and group in posts_analysis["weekday_groups"]:
                                posts_analysis["weekday_groups"][group] += post_count
                            elif day_type in ["saturday", "sunday_holiday"] and group in posts_analysis["weekend_groups"]:
                                posts_analysis["weekend_groups"][group] += post_count
                                self.logger.debug(f"Groupe {group} mis à jour pour {post_type}: +{post_count}")
                    else:
                        # Postes standards
                        if day_type == "weekday":
                            self._update_weekday_group_counts(posts_analysis["weekday_groups"], post_type, post_count)
                        else:
                            self._update_weekend_group_counts(posts_analysis["weekend_groups"], post_type, post_count, day_type, current_date)

            current_date += timedelta(days=1)

        # Log des résultats
        self.logger.info("\nTOTAL DES POSTES PAR TYPE:")
        self.logger.info("\nWEEKDAY:")
        nl_count = posts_analysis["weekday_groups"]["NL"]
        nlv_count = posts_analysis["weekday_groups"]["NLv"]
        self.logger.info(f"NL (lundi-jeudi) : {nl_count:3d}")
        self.logger.info(f"NLv (vendredi)   : {nlv_count:3d}")
        self.logger.info(f"Total NL semaine : {nl_count + nlv_count:3d}")

        # Log des postes de semaine
        for post_type, count in sorted(posts_analysis["weekday"].items()):
            if count > 0 and post_type != "NL":
                if post_type in self.custom_posts:
                    self.logger.info(f"{post_type:4}: {count:3d} (Personnalisé)")
                else:
                    self.logger.info(f"{post_type:4}: {count:3d}")

        # Log des postes de weekend
        if any(posts_analysis["saturday"].values()) or any(posts_analysis["sunday_holiday"].values()):
            self.logger.info("\nPOSTES WEEKEND:")
            for post_type in all_possible_posts:
                total = posts_analysis["saturday"].get(post_type, 0) + posts_analysis["sunday_holiday"].get(post_type, 0)
                if total > 0:
                    if post_type in self.custom_posts:
                        self.logger.info(f"{post_type:4}: {total:3d} (Personnalisé)")
                    else:
                        self.logger.info(f"{post_type:4}: {total:3d}")

        self.logger.info("\nGROUPES WEEKEND:")
        for group, count in posts_analysis["weekend_groups"].items():
            if count > 0:
                self.logger.info(f"{group:6}: {count:3d}")

        self.logger.info("\nGROUPES SEMAINE:")
        for group, count in posts_analysis["weekday_groups"].items():
            if count > 0:
                self.logger.info(f"{group:6}: {count:3d}")

        return posts_analysis
    def calculate_cat_group_count(self, group: str, cat_posts: Dict) -> int:
        """Calcule le nombre de postes CAT pour un groupe donné"""
        total = 0
        
        # Définition des mappings de postes pour chaque groupe
        group_mappings = {
            # Groupes Weekend (uniquement samedi et dimanche/férié)
            "CmS": ["CM", "HM","SM", "RM", "MM"],  # Uniquement samedi
            "CmD": ["CM", "HM", "SM", "RM"],  # Uniquement dimanche
            "CaSD": ["CA", "HA", "SA", "RA"],  # Samedi + Dimanche
            "CsSD": ["CS", "HS", "SS", "RS"],  # Samedi + Dimanche
            "VmS": ["ML","MC"],  # Uniquement samedi
            "VmD": ["ML", "MC"],  # Uniquement dimanche
            "VaSD": ["AL", "AC"],  # Samedi + Dimanche
            "NAMw": ["NM", "NA", "NC"],  # Samedi + Dimanche
            "NLw": ["NL"],  # NLw = NLs + NLd + NLv
            
            # Groupes Semaine (uniquement weekday)
            "XmM": ["MM", "SM"],
            "XM": ["CM", "HM", "RM"],
            "XA": ["CA", "HA", "SA","RA"],
            "XS": ["CS", "HS", "SS", "RS"],
            "NMC": ["NM", "NC","NA"],
            "Vm": ["ML", "MC"],
            "NL": ["NL"],
            "NLv": ["NL"]
        }
        
        if group in group_mappings:
            if group == "NLw":
                # NLs + NLd + NLv
                total = (
                    cat_posts["saturday"].get("NL", 0) +          # NLs
                    cat_posts["sunday_holiday"].get("NL", 0) +    # NLd
                    cat_posts["weekday"].get("NLv", 0)           # NLv
                )
            elif group in ["CmS", "VmS"]:
                # Groupes uniquement samedi
                for post_type in group_mappings[group]:
                    total += cat_posts["saturday"].get(post_type, 0)
            elif group in ["CmD", "VmD"]:
                # Groupes uniquement dimanche
                for post_type in group_mappings[group]:
                    total += cat_posts["sunday_holiday"].get(post_type, 0)
            elif group in ["CaSD", "CsSD", "VaSD", "NAMw"]:
                # Groupes samedi + dimanche
                for post_type in group_mappings[group]:
                    total += (cat_posts["saturday"].get(post_type, 0) +
                            cat_posts["sunday_holiday"].get(post_type, 0))
            else:
                # Groupes semaine (uniquement weekday)
                for post_type in group_mappings[group]:
                    total += cat_posts["weekday"].get(post_type, 0)
        
        return total
    def _update_weekend_group_counts(self, groups: Dict, post_type: str, count: int, day_type: str, current_date: date):
        """
        Met à jour les compteurs de groupes pour le weekend.
        Les jours de pont sont traités comme des fériés, même les samedis.
        """
        is_bridge = self.is_bridge_day(current_date)
        is_holiday = self.cal.is_holiday(current_date)
        is_sunday = current_date.weekday() == 6
        
        # Un samedi qui est un jour de pont est traité comme un férié
        is_saturday = day_type == "saturday" and not (is_bridge or is_holiday)
        is_sunday_or_holiday = (day_type == "sunday_holiday" or is_bridge or is_holiday or is_sunday)

        # Gestion des postes personnalisés
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            if custom_post.statistic_group:
                if custom_post.statistic_group in ["CmS", "VmS"] and is_saturday:
                    groups[custom_post.statistic_group] += count
                elif custom_post.statistic_group in ["CmD", "VmD"] and is_sunday_or_holiday:
                    groups[custom_post.statistic_group] += count
                elif custom_post.statistic_group in ["CaSD", "CsSD", "VaSD", "NAMw", "NLw"]:
                    groups[custom_post.statistic_group] += count
            return

        # Gestion des postes standards
        if post_type in ["MM", "CM", "HM", "SM", "RM"]:
            if is_saturday:
                groups["CmS"] += count
            elif is_sunday_or_holiday:
                groups["CmD"] += count
        elif post_type in ["CA", "HA", "SA", "RA"]:
            groups["CaSD"] += count
        elif post_type in ["CS", "HS", "SS", "RS"]:
            groups["CsSD"] += count
        elif post_type == "ML":
            if is_saturday:
                groups["VmS"] += count
            elif is_sunday_or_holiday:
                groups["VmD"] += count
        elif post_type == "MC":
            if is_sunday_or_holiday:
                groups["VmD"] += count
        elif post_type in ["AL", "AC"]:
            groups["VaSD"] += count
        elif post_type in ["NM", "NA"]:
            groups["NAMw"] += count
        elif post_type == "NL":  # NLw inclut maintenant NLv + NLs + NLd
            groups["NLw"] += count

    def _update_weekday_group_counts(self, groups: Dict, post_type: str, count: int):
        """Met à jour les compteurs de groupes pour la semaine"""
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            period = self.get_post_period(custom_post.start_time, custom_post.end_time)
            
            statistic_group = custom_post.statistic_group
            
            if statistic_group:
                if period == 0:  # Matin
                    if statistic_group == "XmM":
                        groups["XmM"] += count
                    elif statistic_group == "XM":
                        groups["XM"] += count
                    elif statistic_group == "Vm":
                        groups["Vm"] += count
                elif period == 1:  # Après-midi
                    if statistic_group == "XA":
                        groups["XA"] += count
                elif period == 2:  # Soir
                    if statistic_group == "XS":
                        groups["XS"] += count
                    elif statistic_group == "NMC":
                        groups["NMC"] += count
            return

        # Gestion des postes standards
        else:
            period = self.get_post_period_static(post_type)
        if post_type == "MM":
            groups["XmM"] += count
        elif post_type in ["CM", "HM", "SM", "RM"]:
            groups["XM"] += count
        elif post_type in ["CA", "HA", "SA", "RA"]:
            groups["XA"] += count
        elif post_type in ["CS", "HS", "SS", "RS"]:
            groups["XS"] += count
        elif post_type in ["ML", "MC"]:
            groups["Vm"] += count
        elif post_type in ["NM", "NC", "NA"]:
            groups["NMC"] += count

    def _update_cat_groups(self, cat_posts: Dict):
        """Met à jour les groupes pour les postes CAT"""
        # Groupes de semaine
        cat_posts["weekday_groups"]["XmM"] = cat_posts["weekday"]["MM"]
        cat_posts["weekday_groups"]["XM"] = cat_posts["weekday"]["CM"] + cat_posts["weekday"]["HM"]
        cat_posts["weekday_groups"]["XA"] = cat_posts["weekday"]["CA"] + cat_posts["weekday"]["HA"]
        cat_posts["weekday_groups"]["XS"] = cat_posts["weekday"]["CS"] + cat_posts["weekday"]["HS"]
        cat_posts["weekday_groups"]["NMC"] = cat_posts["weekday"]["NM"] + cat_posts["weekday"]["NC"]
        cat_posts["weekday_groups"]["Vm"] = cat_posts["weekday"]["ML"] + cat_posts["weekday"]["MC"]

        # Groupes de weekend
        weekend_nl = cat_posts["saturday"]["NL"] + cat_posts["sunday_holiday"]["NL"]
        cat_posts["weekend_groups"]["NLw"] = weekend_nl

        cat_posts["weekend_groups"]["CmS"] = cat_posts["saturday"]["CM"] + cat_posts["saturday"]["HM"] + cat_posts["saturday"]["MM"]
        cat_posts["weekend_groups"]["CmD"] = (cat_posts["sunday_holiday"]["CM"] + 
                                            cat_posts["sunday_holiday"]["HM"] + 
                                            cat_posts["sunday_holiday"]["SM"] + 
                                            cat_posts["sunday_holiday"]["RM"])

        weekend_ca = (cat_posts["saturday"]["CA"] + cat_posts["saturday"]["HA"] +
                    cat_posts["sunday_holiday"]["CA"] + cat_posts["sunday_holiday"]["HA"])
        cat_posts["weekend_groups"]["CaSD"] = weekend_ca

        weekend_cs = (cat_posts["saturday"]["CS"] + cat_posts["saturday"]["HS"] +
                    cat_posts["sunday_holiday"]["CS"] + cat_posts["sunday_holiday"]["HS"])
        cat_posts["weekend_groups"]["CsSD"] = weekend_cs

        cat_posts["weekend_groups"]["VmS"] = cat_posts["saturday"]["ML"]
        cat_posts["weekend_groups"]["VmD"] = cat_posts["sunday_holiday"]["ML"] + cat_posts["sunday_holiday"]["MC"]
        
        weekend_va = (cat_posts["saturday"]["AL"] + cat_posts["saturday"]["AC"] +
                    cat_posts["sunday_holiday"]["AL"] + cat_posts["sunday_holiday"]["AC"])
        cat_posts["weekend_groups"]["VaSD"] = weekend_va

        weekend_nam = (cat_posts["saturday"]["NA"] + cat_posts["saturday"]["NM"] +
                    cat_posts["sunday_holiday"]["NA"] + cat_posts["sunday_holiday"]["NM"])
        cat_posts["weekend_groups"]["NAMw"] = weekend_nam

    
    
    
    def _log_days_distribution(self):
        """Log la répartition des jours sur la période"""
        details = {
            'weekdays': [],
            'saturdays': [],
            'sundays': [],
            'holidays': [],
            'bridges': [],
            'sunday_holiday_total': [],  # Pour compter tous les jours traités comme dimanche/férié
            'saturday_bridges': [],  # Samedis de pont spécifiquement
            'specific_configs': []
        }

        # Analyser d'abord les configurations spécifiques
        if hasattr(self.post_configuration, 'specific_configs'):
            for config in self.post_configuration.specific_configs:
                start = max(config.start_date, self.start_date)
                end = min(config.end_date, self.end_date)
                
                # Compter les jours spécifiques
                matching_days = 0
                current_date = start
                while current_date <= end:
                    counts_as_match = False
                    
                    if config.apply_to == "Semaine":
                        if current_date.weekday() < 5 and not self.cal.is_holiday(current_date) and not self.is_bridge_day(current_date):
                            counts_as_match = True
                    elif config.apply_to == "Samedi":
                        if current_date.weekday() == 5 and not self.cal.is_holiday(current_date) and not self.is_bridge_day(current_date):
                            counts_as_match = True
                    elif config.apply_to == "Dimanche/Férié":
                        if current_date.weekday() == 6 or self.cal.is_holiday(current_date) or self.is_bridge_day(current_date):
                            counts_as_match = True
                    
                    if counts_as_match:
                        matching_days += 1
                    current_date += timedelta(days=1)

                details['specific_configs'].append({
                    'start_date': config.start_date,
                    'end_date': config.end_date,
                    'apply_to': config.apply_to,
                    'posts': config.post_counts,
                    'matching_days': matching_days
                })

        # Collecte des jours normaux
        current_date = self.start_date
        while current_date <= self.end_date:
            if DayType.is_bridge_day(current_date, self.cal):
                details['bridges'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
                if current_date.weekday() == 5:
                    details['saturday_bridges'].append(current_date)
            elif self.cal.is_holiday(current_date):
                details['holidays'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
            elif current_date.weekday() == 6:  # Dimanche
                details['sundays'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
            elif current_date.weekday() == 5 and not self.is_bridge_day(current_date):  # Samedi normal
                details['saturdays'].append(current_date)
            else:
                details['weekdays'].append(current_date)

            current_date += timedelta(days=1)

        # Affichage standard
        self.logger.info("\nDÉTAIL DES JOURS")
        self.logger.info("="*80)
        self.logger.info(f"Jours de semaine      : {len(details['weekdays']):3d}")
        self.logger.info(f"Samedis normaux       : {len(details['saturdays']):3d}")
        self.logger.info("\nJOURS TRAITÉS COMME DIMANCHE/FÉRIÉ:")
        self.logger.info(f"Dimanches             : {len(details['sundays']):3d}")
        self.logger.info(f"Jours fériés          : {len(details['holidays']):3d}")
        self.logger.info(f"Jours de pont         : {len(details['bridges']):3d}")
        self.logger.info(f"   dont samedis       : {len(details['saturday_bridges']):3d}")
        self.logger.info(f"TOTAL Dim/Férié/Pont  : {len(details['sunday_holiday_total']):3d}")

        # Affichage des configurations spécifiques
        if details['specific_configs']:
            self.logger.info("\nCONFIGURATIONS SPÉCIFIQUES:")
            self.logger.info("-"*80)
            for config in details['specific_configs']:
                # Formatage des postes prévus
                posts_detail = ", ".join([f"{count}{post}" for post, count in config['posts'].items()])
                
                self.logger.info(
                    f"* du {config['start_date'].strftime('%d/%m/%Y')} "
                    f"au {config['end_date'].strftime('%d/%m/%Y')} "
                    f"- {config['apply_to']} : {len(config['posts'])} postes "
                    f"({posts_detail})"
                )
                self.logger.info(f"  → {config['matching_days']} jours concernés")

        self.logger.info("-"*80)
        self.logger.info(f"Total jours période   : {self.total_days:3d}")

        self.logger.info("="*80)
        
    def _log_total_posts_distribution(self, total_posts: Dict):
        self.logger.info("\nDISTRIBUTION TOTALE DES POSTES")
        self.logger.info("=" * 80)
        # Affichage détaillé des postes par type de jour
    
    def _log_cat_posts_distribution(self, cat_posts: Dict):
        self.logger.info("\nDISTRIBUTION DES POSTES CAT")
        self.logger.info("=" * 80)
        # Affichage des postes réservés aux CAT

    def _log_adjusted_posts_distribution(self, adjusted_posts: Dict):
        """Affiche les détails de la distribution ajustée pour les médecins"""
        self.logger.info("\nDISTRIBUTION AJUSTÉE POUR LES MÉDECINS")
        self.logger.info("=" * 80)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)

        # Postes de semaine
        self.logger.info("\nWEEKDAY:")
        self.logger.info("-" * 60)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<25} {'Mi-temps (min-max)':<25}"
        self.logger.info(header)
        
        for post_type, count in sorted(adjusted_posts["weekday"].items()):
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{post_type:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

        # Postes de samedi et dimanche séparément
        for day_type in ["saturday", "sunday_holiday"]:
            day_name = "SATURDAY:" if day_type == "saturday" else "SUNDAY/HOLIDAY:"
            self.logger.info(f"\n{day_name}")
            self.logger.info("-" * 60)
            self.logger.info(header)
            
            for post_type, count in sorted(adjusted_posts[day_type].items()):
                if count > 0:
                    full_time_range = self.round_ideal(count, 2)
                    half_time_range = self.round_ideal(count, 1)
                    self.logger.info(
                        f"{post_type:<6} {count:>8} "
                        f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                        f"{' '*15}"
                        f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                    )

        # Groupes de semaine
        self.logger.info("\nGROUPES SEMAINE:")
        self.logger.info("-" * 60)
        self.logger.info(header)
        
        for group, count in adjusted_posts["weekday_groups"].items():
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{group:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

        # Groupes weekend (fusion des groupes samedi et dimanche)
        self.logger.info("\nGROUPES WEEKEND:")
        self.logger.info("-" * 60)
        self.logger.info(header)
        
        weekend_groups = adjusted_posts["weekend_groups"]
        # Correction du calcul de NLw
        weekend_groups["NLw"] = (
            adjusted_posts["saturday"].get("NL", 0) +  # NLs
            adjusted_posts["sunday_holiday"].get("NL", 0) +  # NLd
            adjusted_posts["weekday_groups"].get("NLv", 0)  # NLv
        )
        
        for group, count in weekend_groups.items():
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{group:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

    def _log_ideal_distribution(self, adjusted_posts: Dict):
        """Affiche la distribution idéale des postes par type de médecin"""
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        full_time_count = sum(1 for d in self.doctors if d.half_parts == 2)
        half_time_count = sum(1 for d in self.doctors if d.half_parts == 1)

        self.logger.info("\nDISTRIBUTION IDÉALE PAR MÉDECIN TYPE")
        self.logger.info("=" * 100)

        # En-tête avec le nombre de médecins
        self.logger.info(f"Nombre de médecins plein temps: {full_time_count}")
        self.logger.info(f"Nombre de médecins mi-temps: {half_time_count}")
        self.logger.info(f"Total demi-parts: {total_half_parts}")
        self.logger.info("")

        header = "{:<8} {:<10} {:<25} {:<25}".format(
            "Type", "Total", "Plein temps", "Mi-temps"
        )

        def log_section(title: str, items: Dict[str, int]):
            """Affiche une section des résultats"""
            self.logger.info(f"\n{title}")
            self.logger.info("-" * 100)
            self.logger.info(header)
            self.logger.info("-" * 100)

            for post_type, total in sorted(items.items()):
                if total > 0:
                    # Utiliser round_ideal pour les deux calculs
                    full_time_range = self.round_ideal(total, 2)
                    half_time_range = self.round_ideal(total, 1)

                    self.logger.info("{:<8} {:<10.1f} [{:>2d}-{:<2d}] ({:.1f})           [{:>2d}-{:<2d}] ({:.1f})".format(
                        post_type,
                        total,
                        full_time_range['min'], full_time_range['max'], full_time_range['target'],
                        half_time_range['min'], half_time_range['max'], half_time_range['target']
                    ))

        # Gardes de nuit semaine
        night_posts = {
            "NL": adjusted_posts["weekday"]["NL"],
            "NLv": adjusted_posts["weekday_groups"]["NLv"]
        }
        log_section("GARDES DE NUIT SEMAINE", night_posts)

        # Autres postes semaine
        weekday_posts = {
            k: v for k, v in adjusted_posts["weekday"].items() 
            if k not in ["NL", "NLv"]
        }
        log_section("AUTRES POSTES SEMAINE", weekday_posts)

        # Groupes semaine
        weekday_groups = {
            k: v for k, v in adjusted_posts["weekday_groups"].items() 
            if k not in ["NL", "NLv"]
        }
        log_section("GROUPES SEMAINE", weekday_groups)

        # Postes weekend
        weekend_posts = {}
        for post_type in set(list(adjusted_posts["saturday"].keys()) + 
                            list(adjusted_posts["sunday_holiday"].keys())):
            total = (adjusted_posts["saturday"].get(post_type, 0) + 
                    adjusted_posts["sunday_holiday"].get(post_type, 0))
            if total > 0:
                weekend_posts[post_type] = total
        log_section("POSTES WEEKEND", weekend_posts)

        # Groupes weekend
        log_section("GROUPES WEEKEND", adjusted_posts["weekend_groups"])
    
        
    def _log_weekend_posts(self, total_posts: Dict, total_parts: int):
        """Affiche les statistiques des postes du weekend"""
        self.logger.info("\nPOSTES WEEKEND")
        self.logger.info("="*80)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.info(f"\n{day_type.upper()}:")
            self.logger.info("-"*80)
            
            for post_type, count in sorted(total_posts[day_type].items()):
                if count > 0:
                    full_time, half_time = self._calculate_ranges(count, total_parts)
                    self.logger.info(
                        f"{post_type:<6} {count:<8} "
                        f"[{full_time['min']}-{full_time['max']}]"
                        f"{' '*8}"
                        f"[{half_time['min']}-{half_time['max']}]"
                    )

    def _log_weekend_groups(self, groups: Dict, total_parts: int):
        """Affiche les statistiques des groupes du weekend"""
        self.logger.info("\nGROUPES WEEKEND")
        self.logger.info("="*80)
        header = f"{'Groupe':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        self.logger.info("-"*80)
        
        for group, count in sorted(groups.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{group:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )

    def _log_weekday_distribution(self, weekday_posts: Dict, weekday_groups: Dict, total_parts: int):
        """Affiche les statistiques des postes et groupes de semaine"""
        self.logger.info("\nDISTRIBUTION SEMAINE")
        self.logger.info("="*80)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        
        self.logger.info("\nPOSTES:")
        self.logger.info("-"*80)
        for post_type, count in sorted(weekday_posts.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{post_type:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )
        
        self.logger.info("\nGROUPES:")
        self.logger.info("-"*80)
        for group, count in sorted(weekday_groups.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{group:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )




    def is_bridge_day(self, day: date) -> bool:
        return DayType.is_bridge_day(day, self.cal)

    def get_post_period(self, start_time: time, end_time: time) -> int:
        """
        Détermine la période d'un poste basé sur ses horaires.
        Retourne:
            0: Matin (7h-13h)
            1: Après-midi (13h-18h)
            2: Soir (18h-7h)
        """
        # Si le poste traverse minuit
        if end_time < start_time:
            hours_range = list(range(start_time.hour, 24)) + list(range(0, end_time.hour + 1))
        else:
            hours_range = list(range(start_time.hour, end_time.hour + 1))
        
        # Compte les heures dans chaque période
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        # Retourne la période avec le plus d'heures
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        if max_hours == morning_hours:
            return 0
        elif max_hours == afternoon_hours:
            return 1
        else:
            return 2

    def get_post_period_static(self, post_type: str) -> int:
        """
        Détermine la période d'un poste standard basé sur son type.
        Retourne:
            0: Matin (ML, MC, MM, CM, HM, SM, RM)
            1: Après-midi (CA, HA, SA, RA, AL, AC)
            2: Soir (autres)
        """
        if post_type in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return 0
        elif post_type in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1
        else:
            return 2
        
    def analyze_unavailability(self) -> Dict:
        """
        Analyse les indisponibilités des médecins sur la période.
        Calcule le pourcentage brut d'indisponibilité et ajoute le pourcentage ajusté pour les mi-temps.
        """
        unavailability = {}
        daily_availability = {(self.start_date + timedelta(days=i)): 0 
                            for i in range((self.end_date - self.start_date).days + 1)}
        
        total_days = (self.end_date - self.start_date).days + 1
        total_periods = total_days * 3  # 3 périodes par jour dans le planning complet

        self.logger.info(f"Analyzing unavailability for {len(self.doctors)} doctors over {total_days} days ({total_periods} total periods)")

        for doctor in self.doctors:
            unavailable_periods = 0
            for desiderata in doctor.desiderata:
                if self.overlaps(desiderata, self.start_date, self.end_date):
                    start = max(desiderata.start_date, self.start_date)
                    end = min(desiderata.end_date, self.end_date)
                    days = (end - start).days + 1
                    
                    # Compte une période par jour d'indisponibilité
                    unavailable_periods += days
                    
                    # Mise à jour du compteur quotidien
                    for day in (start + timedelta(n) for n in range(days)):
                        daily_availability[day] += 1

            # Calcul du pourcentage brut d'indisponibilité
            raw_percentage = round((unavailable_periods / total_periods) * 100, 2)
            
            # Pour les mi-temps, ajouter le pourcentage ajusté
            if doctor.half_parts == 1:
                adjusted_percentage = round(raw_percentage / 2, 2)
                unavailability[doctor.name] = {
                    "raw": raw_percentage,
                    "adjusted": adjusted_percentage,
                    "periods": unavailable_periods,
                    "is_half_time": True
                }
                self.logger.debug(
                    f"Doctor {doctor.name} (mi-temps): "
                    f"{unavailable_periods} périodes indisponibles, "
                    f"{raw_percentage}% brut ({adjusted_percentage}% ajusté)")
            else:
                unavailability[doctor.name] = {
                    "raw": raw_percentage,
                    "adjusted": raw_percentage,
                    "periods": unavailable_periods,
                    "is_half_time": False
                }
                self.logger.debug(
                    f"Doctor {doctor.name}: "
                    f"{unavailable_periods} périodes indisponibles, "
                    f"{raw_percentage}%")

        # Trier les médecins par pourcentage brut d'indisponibilité
        sorted_unavailability = sorted(
            unavailability.items(),
            key=lambda x: x[1]["raw"],
            reverse=True
        )

        # Log des résultats
        self.logger.info("\nINDISPONIBILITÉS DES MÉDECINS:")
        self.logger.info("-" * 60)
        for doctor_name, data in sorted_unavailability:
            if data["is_half_time"]:
                self.logger.info(
                    f"{doctor_name:<15}: {data['raw']:>5.2f}% ({data['adjusted']:>5.2f}% ajusté) "
                    f"- {data['periods']} périodes")
            else:
                self.logger.info(
                    f"{doctor_name:<15}: {data['raw']:>5.2f}% "
                    f"- {data['periods']} périodes")

        # Identifier les jours critiques
        least_available_days = sorted(
            daily_availability.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:5]

        self.logger.info("\nJOURS LES PLUS CRITIQUES:")
        self.logger.info("-" * 60)
        for day, count in least_available_days:
            self.logger.info(f"{day.strftime('%d/%m/%Y')} : {count} médecins indisponibles")

        return {
            "doctor_unavailability": unavailability,
            "least_available_days": least_available_days
        }
    
    def overlaps(self, desiderata: Desiderata, start: date, end: date) -> bool:
        return max(desiderata.start_date, start) <= min(desiderata.end_date, end)

    import math

    def analyze_ideal_distribution(self, adjusted_posts: Dict) -> Dict:
        """Calcule la distribution idéale des postes et groupes pour chaque médecin"""
        ideal_distribution = {}
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)

        # Définition des groupes weekend et semaine
        weekend_groups = ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]
        weekday_groups = ["XmM", "XM", "XA", "XS", "NMC", "Vm", "NL", "NLv"]

        for doctor in self.doctors:
            # Initialisation de la structure pour chaque médecin
            ideal_distribution[doctor.name] = {
                "weekday_posts": {},
                "weekend_posts": {},
                "weekday_groups": {},
                "weekend_groups": {}
            }

            # Calcul du ratio basé sur les demi-parts
            doctor_ratio = doctor.half_parts / total_half_parts

            # Traitement des postes de weekend
            for post_type in adjusted_posts.get("saturday", {}).keys():
                total = (adjusted_posts["saturday"].get(post_type, 0) + 
                        adjusted_posts["sunday_holiday"].get(post_type, 0))
                if total > 0:
                    base_value = total * doctor_ratio
                    ideal_distribution[doctor.name]["weekend_posts"][post_type] = {
                        "min": max(0, math.floor(base_value * 0.8)),  # 80% de la valeur de base
                        "max": math.ceil(base_value * 1.2),  # 120% de la valeur de base
                        "target": base_value
                    }

            # Traitement des postes de semaine
            for post_type in adjusted_posts.get("weekday", {}).keys():
                total = adjusted_posts["weekday"].get(post_type, 0)
                if total > 0:
                    base_value = total * doctor_ratio
                    ideal_distribution[doctor.name]["weekday_posts"][post_type] = {
                        "min": max(0, math.floor(base_value * 0.8)),
                        "max": math.ceil(base_value * 1.2),
                        "target": base_value
                    }

            # Traitement des groupes weekend
            for group in weekend_groups:
                total = adjusted_posts.get("weekend_groups", {}).get(group, 0)
                if total > 0:
                    base_value = total * doctor_ratio
                    ideal_distribution[doctor.name]["weekend_groups"][group] = {
                        "min": max(0, math.floor(base_value * 0.8)),
                        "max": math.ceil(base_value * 1.2),
                        "target": base_value
                    }

            # Traitement des groupes semaine
            for group in weekday_groups:
                total = adjusted_posts.get("weekday_groups", {}).get(group, 0)
                if total > 0:
                    base_value = total * doctor_ratio
                    ideal_distribution[doctor.name]["weekday_groups"][group] = {
                        "min": max(0, math.floor(base_value * 0.8)),
                        "max": math.ceil(base_value * 1.2),
                        "target": base_value
                    }

        return ideal_distribution

    def _get_combo_groups(self, combo: str) -> List[str]:
        """Retourne les groupes impliqués dans une combinaison"""
        group_mapping = {
            # Premier poste
            "ML": ["VmS", "VmD"],
            "MC": ["VmD"],
            "CM": ["CmS"],
            "HM": ["CmS"],
            "SM": ["CmD"],
            "RM": ["CmD"],
            # Second poste
            "CA": ["CaSD"],
            "HA": ["CaSD"],
            "SA": ["CaSD"],
            "RA": ["CaSD"],
            "CS": ["CsSD"],
            "HS": ["CsSD"],
            "SS": ["CsSD"],
            "RS": ["CsSD"],
            "AL": ["VaSD"],
            "AC": ["VaSD"],
            "NA": ["NAMw"]
        }
        
        first_post = combo[:2]
        second_post = combo[2:]
        
        groups = set()
        if first_post in group_mapping:
            groups.update(group_mapping[first_post])
        if second_post in group_mapping:
            groups.update(group_mapping[second_post])
            
        return list(groups)

    def _calculate_combo_total(self, combo: str, adjusted_posts: Dict) -> int:
        """Calcule le total possible pour une combinaison"""
        first_post = combo[:2]
        second_post = combo[2:]
        
        first_total = (
            adjusted_posts["saturday"].get(first_post, 0) +
            adjusted_posts["sunday_holiday"].get(first_post, 0)
        )
        second_total = (
            adjusted_posts["saturday"].get(second_post, 0) +
            adjusted_posts["sunday_holiday"].get(second_post, 0)
        )
        
        return min(first_total, second_total)
    def _calculate_combo_base_value(self, combo: str, adjusted_posts: Dict, half_parts: int) -> float:
        """Calcule la valeur de base pour une combinaison"""
        # Trouver les postes constituant la combinaison
        first_post, second_post = combo[:2], combo[2:]
        
        # Calculer le total disponible
        total_first = (
            adjusted_posts["saturday"].get(first_post, 0) +
            adjusted_posts["sunday_holiday"].get(first_post, 0)
        )
        total_second = (
            adjusted_posts["saturday"].get(second_post, 0) +
            adjusted_posts["sunday_holiday"].get(second_post, 0)
        )
        
        total_combo = min(total_first, total_second)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        
        # Retourne la valeur proportionnelle aux demi-parts
        return total_combo * (half_parts / total_half_parts)
    
    def adjust_posts_for_cats(self, total_posts_analysis: Dict, cat_posts: Dict) -> Dict:
        """Ajuste les totaux de postes en soustrayant les postes CAT, avec chaque CAT recevant son quota complet"""
        self.logger.info("\nAjustement des postes pour les médecins")
        
        # Nombre de CAT
        num_cats = len(self.cats)
        
        # Initialisation des dictionnaires de résultats
        adjusted_posts = {
            "weekday": {},
            "saturday": {},
            "sunday_holiday": {},
            "weekend_groups": {},
            "weekday_groups": {}
        }
        
        # 1. Ajustement des postes de semaine
        self.logger.info("\nAJUSTEMENT POSTES SEMAINE:")
        for post_type in total_posts_analysis["weekday"]:
            if post_type not in ["NL", "NLv"]:  # Traitement spécial pour NL/NLv
                total_count = total_posts_analysis["weekday"].get(post_type, 0)
                cat_count = cat_posts["weekday"].get(post_type, 0)
                cat_total = cat_count * num_cats  # Multiplier par le nombre de CAT
                adjusted_count = max(0, total_count - cat_total)
                adjusted_posts["weekday"][post_type] = adjusted_count
                if total_count > 0 or cat_count > 0:
                    self.logger.info(f"{post_type:4}: Total={total_count:3d}, CAT={cat_count:2d} x {num_cats} = {cat_total:2d}, Ajusté={adjusted_count:3d}")

        # 2. Ajustement spécial pour NL et NLv de semaine
        total_nl = total_posts_analysis["weekday_groups"]["NL"]
        total_nlv = total_posts_analysis["weekday_groups"]["NLv"]
        cat_nl = cat_posts["weekday"].get("NL", 0) * num_cats
        cat_nlv = cat_posts["weekday"].get("NLv", 0) * num_cats

        adjusted_nl = max(0, total_nl - cat_nl)
        adjusted_nlv = max(0, total_nlv - cat_nlv)

        adjusted_posts["weekday"]["NL"] = adjusted_nl
        adjusted_posts["weekday_groups"]["NL"] = adjusted_nl
        adjusted_posts["weekday_groups"]["NLv"] = adjusted_nlv

        self.logger.info(f"NL  : Total={total_nl:3d}, CAT={cat_nl//num_cats:2d} x {num_cats} = {cat_nl:2d}, Ajusté={adjusted_nl:3d}")
        self.logger.info(f"NLv : Total={total_nlv:3d}, CAT={cat_nlv//num_cats:2d} x {num_cats} = {cat_nlv:2d}, Ajusté={adjusted_nlv:3d}")

        # 3. Ajustement des postes de weekend (samedi et dimanche séparément)
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.info(f"\nAJUSTEMENT POSTES {day_type.upper()}:")
            for post_type in total_posts_analysis[day_type]:
                total_count = total_posts_analysis[day_type].get(post_type, 0)
                cat_count = cat_posts[day_type].get(post_type, 0)
                cat_total = cat_count * num_cats
                adjusted_count = max(0, total_count - cat_total)
                adjusted_posts[day_type][post_type] = adjusted_count
                if total_count > 0 or cat_count > 0:
                    self.logger.info(f"{post_type:4}: Total={total_count:3d}, CAT={cat_count:2d} x {num_cats} = {cat_total:2d}, Ajusté={adjusted_count:3d}")

        # 4. Ajustement des groupes de semaine
        self.logger.info("\nAJUSTEMENT GROUPES SEMAINE:")
        for group in total_posts_analysis["weekday_groups"]:
            if group not in ["NL", "NLv"]:  # Déjà traités
                cat_group_count = self.calculate_cat_group_count(group, cat_posts) * num_cats
                total_group_count = total_posts_analysis["weekday_groups"][group]
                adjusted_count = max(0, total_group_count - cat_group_count)
                adjusted_posts["weekday_groups"][group] = adjusted_count
                if total_group_count > 0 or cat_group_count > 0:
                    self.logger.info(f"{group:6}: Total={total_group_count:3d}, CAT={cat_group_count//num_cats:2d} x {num_cats} = {cat_group_count:2d}, Ajusté={adjusted_count:3d}")

        # 5. Ajustement des groupes de weekend
        self.logger.info("\nAJUSTEMENT GROUPES WEEKEND:")
        for group in total_posts_analysis["weekend_groups"]:
            if group != "NLw":  # Traitement spécial pour NLw
                cat_group_count = self.calculate_cat_group_count(group, cat_posts) * num_cats
                total_group_count = total_posts_analysis["weekend_groups"][group]
                adjusted_count = max(0, total_group_count - cat_group_count)
                adjusted_posts["weekend_groups"][group] = adjusted_count
                if total_group_count > 0 or cat_group_count > 0:
                    self.logger.info(f"{group:6}: Total={total_group_count:3d}, CAT={cat_group_count//num_cats:2d} x {num_cats} = {cat_group_count:2d}, Ajusté={adjusted_count:3d}")

        # 6. Calcul spécial pour NLw
        total_nls = total_posts_analysis["saturday"].get("NL", 0)
        total_nld = total_posts_analysis["sunday_holiday"].get("NL", 0)
        total_nlv = total_posts_analysis["weekday_groups"].get("NLv", 0)
        total_nlw = total_nls + total_nld + total_nlv

        cat_nls = cat_posts["saturday"].get("NL", 0) * num_cats
        cat_nld = cat_posts["sunday_holiday"].get("NL", 0) * num_cats
        cat_nlv = cat_posts["weekday"].get("NLv", 0) * num_cats
        cat_total = cat_nls + cat_nld + cat_nlv

        adjusted_nls = max(0, total_nls - cat_nls)
        adjusted_nld = max(0, total_nld - cat_nld)
        adjusted_nlv = max(0, total_nlv - cat_nlv)
        adjusted_total = adjusted_nls + adjusted_nld + adjusted_nlv

        adjusted_posts["weekend_groups"]["NLw"] = adjusted_total

        self.logger.info(
            f"NLw    : Total={total_nlw:3d} (NLs {total_nls} + NLd {total_nld} + NLv {total_nlv})  "
            f"CAT={cat_total//num_cats:2d} (NLs {cat_nls//num_cats} + NLd {cat_nld//num_cats} + NLv {cat_nlv//num_cats}) x {num_cats} = {cat_total:2d}  "
            f"Ajusté={adjusted_total:3d}"
        )

        return adjusted_posts
    

    def round_ideal(self, total_posts: float, half_parts: int) -> Dict[str, float]:
        """
        Calcule la répartition idéale des postes basée sur le nombre de demi-parts
        avec un intervalle serré (±1 autour de la moyenne arrondie)
        
        Args:
            total_posts: Nombre total de postes à répartir
            half_parts: Nombre de demi-parts du médecin (1 ou 2)
                
        Returns:
            Dict avec min, max et target (moyenne exacte)
        """
        # Calcul de la moyenne exacte
        base_value = total_posts * (half_parts / self.total_half_parts)
        
        # Arrondir au plus proche
        rounded = round(base_value)
        
        # Si la moyenne est inférieure à la valeur arrondie
        # l'intervalle sera [rounded-1, rounded]
        if base_value < rounded:
            return {
                "min": max(0, rounded - 1),  # Éviter les valeurs négatives
                "max": rounded,
                "target": base_value
            }
        # Si la moyenne est supérieure ou égale à la valeur arrondie
        # l'intervalle sera [rounded, rounded+1]
        else:
            return {
                "min": rounded,
                "max": rounded + 1,
                "target": base_value
            }
        
    

    
    
    
    
    def _log_analysis_summary(self, total_posts: Dict, cat_posts: Dict, adjusted_posts: Dict):
        """Affiche un tableau récapitulatif de l'analyse complète"""
        
        def print_header():
            headers = [
                "Type", "Total", "CAT", "Médecins", 
                "Temps Plein [min-max]", "Mi-temps [min-max]"
            ]
            header = "{:<20} {:>8} {:>8} {:>10} {:>20} {:>20}".format(*headers)
            self.logger.info("\n" + "=" * 90)
            self.logger.info(header)
            self.logger.info("-" * 90)

        def print_section(title):
            self.logger.info("\n" + title)
            self.logger.info("-" * 90)
            print_header()

        def format_line(post_type, total, cat, med, full_range, half_range):
            return "{:<20} {:>8d} {:>8d} {:>10d} {:>20} {:>20}".format(
                post_type, total, cat, med,
                f"[{full_range['min']}-{full_range['max']}]",
                f"[{half_range['min']}-{half_range['max']}]"
            )

        self.logger.info("\nTABLEAU RÉCAPITULATIF DE L'ANALYSE")
        self.logger.info("=" * 90)

        # SEMAINE
        print_section("POSTES SEMAINE")
        for post in sorted(total_posts["weekday"]):
            if total_posts["weekday"][post] > 0:
                total = total_posts["weekday"][post]
                cat = cat_posts["weekday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["weekday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # GROUPES SEMAINE
        print_section("GROUPES SEMAINE")
        for group in sorted(total_posts["weekday_groups"]):
            total = total_posts["weekday_groups"][group]
            cat = self.calculate_cat_group_count(group, cat_posts) * len(self.cats)
            med = adjusted_posts["weekday_groups"][group]
            full_range = self.round_ideal(med, 2)
            half_range = self.round_ideal(med, 1)
            self.logger.info(format_line(group, total, cat, med, full_range, half_range))

        # WEEKEND (SAMEDI)
        print_section("POSTES SAMEDI")
        for post in sorted(total_posts["saturday"]):
            if total_posts["saturday"][post] > 0:
                total = total_posts["saturday"][post]
                cat = cat_posts["saturday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["saturday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # WEEKEND (DIMANCHE)
        print_section("POSTES DIMANCHE/FÉRIÉS")
        for post in sorted(total_posts["sunday_holiday"]):
            if total_posts["sunday_holiday"][post] > 0:
                total = total_posts["sunday_holiday"][post]
                cat = cat_posts["sunday_holiday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["sunday_holiday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # GROUPES WEEKEND
        print_section("GROUPES WEEKEND")
        for group in sorted(total_posts["weekend_groups"]):
            total = total_posts["weekend_groups"][group]
            cat = self.calculate_cat_group_count(group, cat_posts) * len(self.cats)
            med = adjusted_posts["weekend_groups"][group]
            full_range = self.round_ideal(med, 2)
            half_range = self.round_ideal(med, 1)
            self.logger.info(format_line(group, total, cat, med, full_range, half_range))
            
            
            
            
    def get_all_post_types(self, day_type: str) -> List[str]:
        """Retourne tous les types de postes pour un type de jour donné"""
        all_posts = set(ALL_POST_TYPES)  # Utiliser un set pour éviter les doublons
        
        # Ajouter les postes personnalisés
        if hasattr(self, 'custom_posts'):
            custom_posts = [
                post_name
                for post_name, post in self.custom_posts.items()
                if hasattr(post, 'day_types') and day_type in post.day_types
            ]
            all_posts.update(custom_posts)
            
        return list(all_posts)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    def analyze_weekend_combinations_distribution(self, adjusted_posts: Dict) -> Dict:
        """Analyse la distribution des combinaisons de postes pour le weekend"""
        self.logger.info("\nANALYSE DES COMBINAISONS WEEKEND")
        self.logger.info("=" * 100)

        # Structure pour les postes disponibles (sans réduction)
        available_posts = {
            "saturday": adjusted_posts["saturday"].copy(),
            "sunday_holiday": adjusted_posts["sunday_holiday"].copy()
        }
        
        # Structure pour les postes CAT
        cat_posts = {
            "saturday": {},
            "sunday_holiday": {}
        }
        for post_type in ALL_POST_TYPES:
            for day_type in ["saturday", "sunday_holiday"]:
                config = getattr(self.post_configuration, f"cat_{day_type}")
                if hasattr(config, post_type):  # Voici le problème !
                    cat_posts[day_type][post_type] = config[post_type].total * len(self.cats)

        combinations_analysis = {}
        priority_combinations = self._get_post_combinations()

        # En-tête du tableau modifié
        header = "{:<10} {:<8} {:<25} {:<25} {:<40}".format(
            "Combo", "Total", "Plein temps (moy)", "Mi-temps (moy)", "CAT (S/D/Total)"
        )
        self.logger.info("\n" + header)
        self.logger.info("-" * len(header))

        for priority, combinations in priority_combinations.items():
            if combinations:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                priority_results = {}

                for combo in combinations:
                    first_post, second_post = combo[:2], combo[2:]
                    
                    # Calcul des combinaisons possibles pour médecins
                    med_combinations = self._calculate_possible_combinations(
                        first_post, second_post, available_posts
                    )
                    
                    # Calcul détaillé des combinaisons CAT
                    cat_detail = self._calculate_cat_combinations(
                        first_post, second_post, cat_posts
                    )

                    # Calcul des intervalles
                    intervals = self._calculate_combination_intervals(
                        med_combinations,
                        cat_detail['total']
                    )

                    # Affichage avec détail CAT
                    cat_display = (f"{cat_detail['saturday']}/{cat_detail['sunday_holiday']}/"
                                f"{cat_detail['total']}" if self.cats else "N/A")
                    
                    self.logger.info(
                        "{:<10} {:<8d} {:<25} {:<25} {:<40}".format(
                            combo,
                            med_combinations,
                            f"{self._format_interval(intervals['full_time'])}",
                            f"{self._format_interval(intervals['half_time'])}",
                            cat_display
                        )
                    )

                    # Stockage des résultats
                    priority_results[combo] = {
                        "total": med_combinations,
                        "cat_detail": cat_detail,
                        "intervals": intervals
                    }

                if priority_results:
                    combinations_analysis[priority] = priority_results

        return combinations_analysis

    def _calculate_possible_combinations(self, first_post: str, second_post: str, 
                                    posts: Dict[str, Dict[str, int]]) -> int:
        """
        Calcule le nombre de combinaisons possibles entre deux postes
        """
        # Log des postes disponibles
        self.logger.debug(f"\nAnalyse combinaison {first_post}+{second_post}:")
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.debug(f"{day_type} - {first_post}: {posts[day_type].get(first_post, 0)}, "
                            f"{second_post}: {posts[day_type].get(second_post, 0)}")

        # Somme des postes disponibles sur samedi et dimanche
        first_count = sum(posts[day].get(first_post, 0) for day in ["saturday", "sunday_holiday"])
        second_count = sum(posts[day].get(second_post, 0) for day in ["saturday", "sunday_holiday"])

        self.logger.debug(f"Totaux: {first_post}={first_count}, {second_post}={second_count}")

        # Vérifier la compatibilité temporelle
        compatible = any(self._are_posts_compatible(first_post, second_post, day_type) 
                        for day_type in ["saturday", "sunday_holiday"])
        self.logger.debug(f"Compatible: {compatible}")

        if not compatible:
            return 0

        # Pour les combinaisons avec visites
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            result = min(first_count, second_count, 
                        math.floor(min(first_count, second_count) * 0.8))
            self.logger.debug(f"Combinaison avec visite: {result}")
            return result
        
        result = min(first_count, second_count)
        self.logger.debug(f"Combinaison standard: {result}")
        return result

    def _calculate_combination_intervals(self, total_combinations: int, cat_combinations: int) -> Dict:
        """
        Calcule les intervalles pour les combinaisons de postes
        """
        # Pour les médecins temps plein
        full_time_value = total_combinations * (2 / self.total_half_parts)
        full_time_interval = self.round_ideal(total_combinations, 2)

        # Pour les médecins mi-temps
        half_time_value = total_combinations * (1 / self.total_half_parts)
        half_time_interval = self.round_ideal(total_combinations, 1)

        # Pour les CAT
        cat_interval = {
            "min": math.floor(cat_combinations / len(self.cats)) if self.cats else 0,
            "max": math.ceil(cat_combinations / len(self.cats)) if self.cats else 0
        }

        return {
            "full_time": full_time_interval,
            "half_time": half_time_interval,
            "cat": cat_interval
        }
    
    def _calculate_cat_combinations(self, first_post: str, second_post: str, cat_posts: Dict) -> Dict:
        """
        Calcule et détaille les combinaisons possibles pour les CAT par jour.
        """
        self.logger.debug(f"\nCalcul combinaisons CAT pour {first_post}+{second_post}:")
        
        cat_detail = {
            "saturday": 0,
            "sunday_holiday": 0,
            "total": 0
        }
        
        num_cats = len(self.cats)
        if num_cats == 0:
            return cat_detail
            
        for day_type in ["saturday", "sunday_holiday"]:
            # Log des postes disponibles pour CAT
            first_count = cat_posts[day_type].get(first_post, 0) // num_cats
            second_count = cat_posts[day_type].get(second_post, 0) // num_cats
            
            self.logger.debug(f"{day_type} - Postes disponibles:")
            self.logger.debug(f"{first_post}: {first_count} par CAT ({cat_posts[day_type].get(first_post, 0)} total)")
            self.logger.debug(f"{second_post}: {second_count} par CAT ({cat_posts[day_type].get(second_post, 0)} total)")
                
            # Vérifier la compatibilité temporelle
            if self._are_posts_compatible(first_post, second_post, day_type):
                # Calculer les combinaisons possibles
                day_combinations = min(first_count, second_count)
                
                # Pour les visites, réduire de 20%
                if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
                    day_combinations = math.floor(day_combinations * 0.8)
                    
                cat_detail[day_type] = day_combinations * num_cats
                cat_detail["total"] += cat_detail[day_type]
                
                self.logger.debug(f"Combinaisons pour {day_type}: {day_combinations} par CAT ({cat_detail[day_type]} total)")

        self.logger.debug(f"Total combinaisons CAT: {cat_detail['total']}")
        return cat_detail
    
    def _format_interval(self, interval: Dict) -> str:
        """Formate un intervalle pour l'affichage"""
        return f"[{interval['min']:2d}-{interval['max']:2d}]"

    def _get_post_combinations(self) -> Dict[str, List[str]]:
        """
        Retourne les combinaisons de postes organisées par priorité.
        Les combinaisons sont ordonnées selon leur importance stratégique dans le planning.
        """
        return {
            # Priorité 1: Combinaisons stratégiques principales
            "priority1": [
                # Combinaisons St André et Créon soir
                "SASS", "RARS",  # Combinaisons après-midi/soir pour les sites distants
                "SMSA", "RMRA",  # Combinaisons après-midi/soir pour les sites distants
                "MLCA",         # Visite longue avec consultation Cenon
                "CMAL",         # Consultation Cenon avec visite après-midi
                "HMAL",         # Consultation Beychac avec visite après-midi
                "HAHS",         # Beychac après-midi/soir
                "HMAC",         # Beychac matin avec visite
                "SMAC",         # St André matin avec visite
                "CMAC"          # Cenon matin avec visite
            ],
            
            # Priorité 2: Combinaisons visites-consultations
            "priority2": [
                "MLHA",  # Visite longue avec Beychac après-midi
                "MLSA",  # Visite longue avec St André après-midi
                "MLRA",  # Visite longue avec Créon après-midi
                "MCCA",  # Visite courte avec Cenon après-midi
                "MCHA",  # Visite courte avec Beychac après-midi
                "MCRA",  # Visite courte avec Créon après-midi
                "MCSA"   # Visite courte avec St André après-midi
            ],
            
            # Priorité 3: Combinaisons matin-après-midi visites
            "priority3": [
                "MCAL",  # Visite courte matin avec visite après-midi
                "CMAL",  # Cenon matin avec visite après-midi
                "CACS",  # Cenon matin avec visite après-midi
                "HMAL",  # Beychac matin avec visite après-midi
                "HMAC",  # Beychac matin avec visite courte
                "RMAL",  # Créon matin avec visite après-midi
                "RMAC",  # Créon matin avec visite courte
                "SMAL",  # St André matin avec visite après-midi
                "SMAC"   # St André matin avec visite courte
            ],
            
            # Priorité 5: Combinaisons avec nuit courte (NA)
            "priority5": [
                "SANA",  # St André après-midi + nuit courte
                "RANA",  # Créon après-midi + nuit courte
                "CANA",  # Cenon après-midi + nuit courte
                "HANA"   # Beychac après-midi + nuit courte
            ]
        }
    def _are_posts_compatible(self, post1: str, post2: str, day_type: str) -> bool:
        """Vérifie si deux postes sont compatibles dans le même jour"""
        # Récupérer les détails des postes depuis le PostManager
        post1_details = self.post_manager.get_post_details(post1, day_type)
        post2_details = self.post_manager.get_post_details(post2, day_type)
        
        self.logger.debug(f"\nVérification compatibilité {post1}-{post2} ({day_type}):")
        self.logger.debug(f"Post1 {post1}: {post1_details}")
        self.logger.debug(f"Post2 {post2}: {post2_details}")
        
        if not (post1_details and post2_details):
            self.logger.debug("Un des postes n'a pas de détails")
            return False
            
        # Vérifier le chevauchement des horaires
        compatible = (post1_details["end_time"] <= post2_details["start_time"] or
                    post2_details["end_time"] <= post1_details["start_time"])
        self.logger.debug(f"Compatibilité: {compatible}")
        return compatible
    
    
    def _check_combination_compatibility(self, first_post: str, second_post: str, 
                                    day_type: str, remaining_posts: Dict) -> int:
        """
        Vérifie la compatibilité d'une combinaison de postes et retourne le nombre possible.
        
        Args:
            first_post: Premier poste de la combinaison
            second_post: Second poste de la combinaison
            day_type: Type de jour (saturday/sunday_holiday)
            remaining_posts: Dictionnaire des postes restants disponibles
        
        Returns:
            Nombre de combinaisons possibles
        """
        # Vérifier si les postes existent et sont disponibles
        if first_post not in remaining_posts[day_type] or second_post not in remaining_posts[day_type]:
            return 0
            
        first_count = remaining_posts[day_type][first_post]
        second_count = remaining_posts[day_type][second_post]
        
        # Vérifier la compatibilité temporelle des postes
        if not self._are_posts_compatible(first_post, second_post, day_type):
            return 0
            
        # Pour les combinaisons avec visites (ML, MC, AL, AC)
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            # Réduire le nombre possible pour tenir compte des temps de déplacement
            return min(first_count, second_count, math.floor(min(first_count, second_count) * 0.8))
        
        return min(first_count, second_count)

    def _log_combinations_analysis(self, analysis: Dict):
        """Affiche les résultats de l'analyse des combinaisons"""
        headers = ["Combinaison", "Total", "Plein temps", "Mi-temps", "CAT"]
        format_str = "{:<12} {:<8} {:<15} {:<15} {:<15}"
        
        self.logger.info(format_str.format(*headers))
        self.logger.info("-" * 70)
        
        for priority in ["priority1", "priority2", "priority3", "priority4", "priority5"]:
            if analysis[priority]:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                for combo, data in analysis[priority].items():
                    intervals = data["intervals"]
                    self.logger.info(format_str.format(
                        combo,
                        data["total"],
                        f"[{intervals['full_time']['min']}-{intervals['full_time']['max']}]",
                        f"[{intervals['half_time']['min']}-{intervals['half_time']['max']}]",
                        f"[{intervals['cat']['min']}-{intervals['cat']['max']}]"
                    ))
                    
    
    def analyze_weekday_combinations_distribution(self, adjusted_posts: Dict) -> Dict:
        """Analyse la distribution des combinaisons de postes pour les jours de semaine"""
        self.logger.info("\nANALYSE DES COMBINAISONS SEMAINE")
        self.logger.info("=" * 100)

        # Structure pour les postes disponibles
        available_posts = {
            "weekday": adjusted_posts["weekday"].copy()
        }
        
        # Structure pour les postes CAT
        cat_posts = {"weekday": {}}
        for post_type in ALL_POST_TYPES:
            config = getattr(self.post_configuration, "cat_weekday")
            if hasattr(config, post_type):
                cat_posts["weekday"][post_type] = config[post_type].total * len(self.cats)

        combinations_analysis = {}
        priority_combinations = self._get_weekday_post_combinations()

        # En-tête du tableau
        header = "{:<10} {:<8} {:<25} {:<25} {:<25}".format(
            "Combo", "Total", "Plein temps (moy)", "Mi-temps (moy)", "CAT (moy)"
        )
        self.logger.info("\n" + header)
        self.logger.info("-" * len(header))

        # Traiter les combinaisons par priorité
        for priority, combinations in priority_combinations.items():
            if combinations:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                priority_results = {}

                for combo in combinations:
                    first_post, second_post = combo[:2], combo[2:]
                    
                    # Calcul des combinaisons possibles pour médecins
                    med_combinations = self._calculate_weekday_possible_combinations(
                        first_post, second_post, available_posts
                    )
                    
                    # Calcul des combinaisons possibles pour CAT
                    cat_combinations = self._calculate_weekday_possible_combinations(
                        first_post, second_post, cat_posts
                    )

                    if med_combinations > 0 or cat_combinations > 0:
                        intervals = self._calculate_combination_intervals(
                            med_combinations,
                            cat_combinations
                        )
                        priority_results[combo] = {
                            "total": med_combinations,
                            "cat_total": cat_combinations,
                            "intervals": intervals
                        }

                        # Dans l'affichage des résultats
                        self.logger.info(
                            "{:<10} {:<8d} {:<25} {:<25} {:<10}".format(
                                combo,
                                med_combinations,
                                f"{self._format_interval(intervals['full_time'])}",
                                f"{self._format_interval(intervals['half_time'])}",
                                f"{intervals['cat']['total']}" if self.cats else "N/A"
                            )

                            )
                        

                if priority_results:
                    combinations_analysis[priority] = priority_results

        return combinations_analysis

    def _get_weekday_post_combinations(self) -> Dict[str, List[str]]:
        """
        Retourne les combinaisons de postes pour les jours de semaine.
        Les combinaisons sont organisées par priorité.
        """
        return {
            "priority1": [
                "MLCA", "MLHA",  # Visite longue avec consultations après-midi
                "MLSA", "MLRA", 
                "MCCA", "MCHA",  # Visite courte avec consultations après-midi
                "MCRA", "MCSA"
            
            ],
            "priority2": [
                "CMCA", "CACS","MMCA",  # Cenon matin-après-midi et après-midi-soir
                "HMHA", "HAHS",  # Beychac matin-après-midi et après-midi-soir
                "SMSA", "SASS",  # St André matin-après-midi et après-midi-soir
                "RMRA", "RARS"   # Créon matin-après-midi et après-midi-soir
            ],
            "priority3": [
                "MCAL", "CMAL",  # Combinaisons avec visites après-midi
                "HMAL", "HMAC", 
                "RMAL", "RMAC",
                "SMAL", "SMAC"
            ],
            "priority5": [
                "SANA", "RANA",  # Combinaisons avec nuit courte
                "CANA", "HANA"
            ]
        }

    def _calculate_weekday_possible_combinations(self, first_post: str, second_post: str, 
                                            posts: Dict[str, Dict[str, int]]) -> int:
        """
        Calcule le nombre de combinaisons possibles entre deux postes pour les jours de semaine
        """
        # Obtenir le nombre de postes disponibles
        first_count = posts["weekday"].get(first_post, 0)
        second_count = posts["weekday"].get(second_post, 0)

        # Vérifier la compatibilité temporelle
        if not self._are_posts_compatible(first_post, second_post, "weekday"):
            return 0

        # Ajustement pour les visites
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            return min(first_count, second_count, 
                    math.floor(min(first_count, second_count) * 0.8))
        
        return min(first_count, second_count)

# core/Analyzer/combinations_analyzer.py

# core/Analyzer/combinations_analyzer.py

from typing import Dict, List, Tuple, Optional
from datetime import date, timedelta
from core.Constantes.models import (Doctor, CAT, WEEKEND_COMBINATIONS, 
                        WEEKDAY_COMBINATIONS, ALL_POST_TYPES)
from core.Analyzer.availability_matrix import AvailabilityMatrix
import logging

class CombinationsAnalyzer:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], 
                availability_matrix: AvailabilityMatrix, 
                pre_analysis_results: Dict):
        self.doctors = doctors
        self.cats = cats
        self.availability_matrix = availability_matrix
        self.pre_analysis_results = pre_analysis_results
        self.logger = logging.getLogger(__name__)
        
        # Vérification détaillée de la structure pre_analysis_results
        self.logger.info("\nVérification structure pre_analysis_results:")
        if "ideal_distribution" in pre_analysis_results:
            first_doctor = next(iter(pre_analysis_results["ideal_distribution"].values()))
            if "weekday_groups" in first_doctor:
                self.logger.info("Structure weekday_groups pour le premier médecin:")
                for group, value in first_doctor["weekday_groups"].items():
                    self.logger.info(f"- {group}: {value}")
            else:
                self.logger.error("weekday_groups non trouvé dans ideal_distribution")
        else:
            self.logger.error("ideal_distribution non trouvé dans pre_analysis_results")

    def analyze(self) -> Dict:
        """Point d'entrée principal de l'analyse des combinaisons."""
        self.logger.info("\nANALYSE GLOBALE DES COMBINAISONS")
        self.logger.info("=" * 100)

        # Ajout de la vérification des groupes disponibles
        if "ideal_distribution" in self.pre_analysis_results:
            first_doctor = next(iter(self.pre_analysis_results["ideal_distribution"].values()))
            self.logger.info("Groupes disponibles dans weekday_groups:")
            for group in first_doctor.get("weekday_groups", {}):
                self.logger.info(f"- {group}")

        analysis_results = {
            "weekend": self.analyze_weekend_combinations(),
            "weekday": self.analyze_weekday_combinations()
        }

        self._log_summary(analysis_results)
        return analysis_results

    def analyze_weekend_combinations(self) -> Dict:
        """Analyse toutes les combinaisons weekend."""
        self._log_analysis_header("weekend")
        results = {}
        
        for combo in WEEKEND_COMBINATIONS:
            results[combo] = self._analyze_combination(combo, "weekend")
            self._log_combination_analysis(combo, results[combo], "weekend")
        
        return results

    def analyze_weekday_combinations(self) -> Dict:
        """Analyse toutes les combinaisons semaine."""
        self._log_analysis_header("weekday")
        results = {}
        
        for combo in WEEKDAY_COMBINATIONS:
            results[combo] = self._analyze_combination(combo, "weekday")
            self._log_combination_analysis(combo, results[combo], "weekday")
        
        return results

    def _analyze_combination(self, combo: str, day_type: str) -> Dict:
        """Analyse détaillée d'une combinaison spécifique."""
        eligible_doctors = self._get_eligible_doctors(combo, day_type)
        groups = self._get_combo_groups(combo, day_type)  # Ajout du day_type ici
        posts = self._get_combo_posts(combo)
        requirements = self._get_posts_requirements(combo, day_type)
        
        ratio = self._calculate_combination_ratio(combo, len(eligible_doctors), day_type)
        status = self._determine_combination_status(ratio)
        
        return {
            "eligible_doctors": [doc.name for doc in eligible_doctors],
            "groups": groups,
            "posts": posts,
            "requirements": requirements,
            "ratio": ratio,
            "status": status
        }

    def _get_eligible_doctors(self, combo: str, day_type: str) -> List[Doctor]:
        """Retourne la liste des médecins pouvant prendre cette combinaison."""
        return [
            doctor for doctor in self.doctors
            if self._can_doctor_take_combo(doctor, combo, day_type)
        ]

    def _can_doctor_take_combo(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """Vérifie si un médecin peut prendre une combinaison."""
        groups = self._get_combo_groups(combo, day_type)  # Ajout day_type
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]

        for group in groups:
            if day_type == "weekend":
                max_allowed = doctor_limits["weekend_groups"][group]["max"]
                current = doctor.weekend_combo_counts.get(group, 0)
            else:
                max_allowed = doctor_limits["weekday_groups"][group]["max"]
                current = doctor.weekday_combo_counts.get(group, 0)
                
            if current >= max_allowed:
                return False
                
        return self._check_doctor_availability(doctor, combo, day_type)

    def _check_doctor_availability(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """Vérifie les disponibilités du médecin pour la combinaison."""
        post1, post2 = self._get_combo_posts(combo)
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]
        
        if day_type == "weekend":
            max_post1 = doctor_limits["weekend_posts"].get(post1, {}).get("max", 0)
            max_post2 = doctor_limits["weekend_posts"].get(post2, {}).get("max", 0)
        else:
            max_post1 = doctor_limits["weekday_posts"].get(post1, {}).get("max", 0)
            max_post2 = doctor_limits["weekday_posts"].get(post2, {}).get("max", 0)
            
        return max_post1 > 0 and max_post2 > 0

    def _check_group_limits(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """
        Vérifie les limites de groupes pour le médecin.
        """
        groups = self._get_combo_groups(combo, day_type)
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]
        
        for group in groups:
            try:
                if day_type == "weekend":
                    current = doctor.weekend_combo_counts.get(group, 0)
                    max_allowed = doctor_limits["weekend_groups"][group]["max"]
                else:
                    current = doctor.weekday_combo_counts.get(group, 0)
                    # Si le groupe n'existe pas ou a une limite de 0, 
                    # la combinaison n'est pas possible
                    if group not in doctor_limits["weekday_groups"]:
                        max_allowed = 0
                    else:
                        max_allowed = doctor_limits["weekday_groups"].get(group, {}).get("max", 0)

                # Si max_allowed est 0, cette combinaison n'est pas possible
                if max_allowed == 0:
                    return False
                    
                if current >= max_allowed:
                    return False
                    
            except KeyError:
                # Si une clé n'existe pas, c'est que le groupe n'est pas disponible
                self.logger.debug(f"Groupe {group} non disponible pour {doctor.name}")
                return False
                    
        return True

    def _get_combo_groups(self, combo: str, day_type: str) -> List[str]:
        """
        Identifie les groupes impactés par une combinaison selon le type de jour.
        """
        groups = set()
        first_post = combo[:2]
        second_post = combo[2:]
        
        if day_type == "weekend":
            # Mapping des postes vers les groupes weekend
            WEEKEND_MAPPING = {
                "ML": "VmS",
                "MC": "VmD",
                "CM": "CmS",
                "HM": "CmS",
                "SM": "CmD",
                "RM": "CmD",
                "CA": "CaSD",
                "HA": "CaSD",
                "SA": "CaSD",
                "RA": "CaSD",
                "CS": "CsSD",
                "HS": "CsSD",
                "SS": "CsSD",
                "RS": "CsSD",
                "AL": "VaSD",
                "AC": "VaSD"
            }
            
            if first_post in WEEKEND_MAPPING:
                groups.add(WEEKEND_MAPPING[first_post])
            if second_post in WEEKEND_MAPPING:
                groups.add(WEEKEND_MAPPING[second_post])
                
        else:
            # Mapping des postes vers les groupes semaine
            WEEKDAY_MAPPING = {
                "MM": "XmM",
                "SM": "XmM",
                "RM": "XmM",
                "CM": "XM",
                "HM": "XM",
                "CA": "XA",
                "HA": "XA",
                "SA": "XA",
                "RA": "XA",
                "CS": "XS",
                "HS": "XS",
                "SS": "XS",
                "RS": "XS",
                "ML": "Vm",
                "MC": "Vm",
            }
            
            if first_post in WEEKDAY_MAPPING:
                groups.add(WEEKDAY_MAPPING[first_post])
            if second_post in WEEKDAY_MAPPING:
                groups.add(WEEKDAY_MAPPING[second_post])

        if not groups:
            self.logger.warning(f"Aucun groupe identifié pour la combinaison {combo} ({day_type})")
        
        return list(groups)
    def _get_combo_posts(self, combo: str) -> Tuple[str, str]:
        """Sépare une combinaison en ses deux postes."""
        return combo[:2], combo[2:]

    def _get_posts_requirements(self, combo: str, day_type: str) -> Dict:
        """Récupère les besoins en postes pour cette combinaison."""
        post1, post2 = self._get_combo_posts(combo)
        if day_type == "weekend":
            return {
                post1: self.pre_analysis_results["weekend_posts"].get(post1, 0),
                post2: self.pre_analysis_results["weekend_posts"].get(post2, 0)
            }
        return {
            post1: self.pre_analysis_results["weekday_posts"].get(post1, 0),
            post2: self.pre_analysis_results["weekday_posts"].get(post2, 0)
        }

    def _calculate_combination_ratio(self, combo: str, eligible_count: int, day_type: str) -> float:
        """Calcule le ratio de disponibilité/besoin pour une combinaison."""
        requirements = self._get_posts_requirements(combo, day_type)
        groups = self._get_combo_groups(combo, day_type)  # Ajout day_type
        needed = max(requirements.values()) if requirements else 0
        return eligible_count / needed if needed > 0 else float('inf')

    def _determine_combination_status(self, ratio: float) -> str:
        """Détermine le statut d'une combinaison basé sur son ratio."""
        if ratio >= 1.2:
            return "OK"
        elif ratio >= 0.8:
            return "ATTENTION"
        return "CRITIQUE"

    def _log_analysis_header(self, day_type: str):
        """Affiche l'en-tête de l'analyse."""
        self.logger.info(f"\nANALYSE DES COMBINAISONS {day_type.upper()}")
        self.logger.info("=" * 100)
        self.logger.info("{:<8} {:<15} {:<25} {:<12} {:<10}".format(
            "COMBO", "ÉLIGIBLES", "GROUPES", "RATIO", "STATUT"
        ))
        self.logger.info("-" * 80)

    def _log_combination_analysis(self, combo: str, analysis: Dict, day_type: str):
        """Log les résultats d'analyse d'une combinaison."""
        self.logger.info("{:<8} {:<15} {:<25} {:<12.2f} {:<10}".format(
            combo,
            f"{len(analysis['eligible_doctors'])}/{len(self.doctors)}",
            "+".join(analysis['groups']),
            analysis['ratio'],
            analysis['status']
        ))


    def _log_summary(self, all_analysis: Dict):
        """Affiche un résumé de l'analyse complète."""
        self.logger.info("\nRÉSUMÉ DE L'ANALYSE DES COMBINAISONS")
        self.logger.info("=" * 100)
        
        for day_type, combinations in all_analysis.items():
            critical = sum(1 for c in combinations.values() if c['status'] == "CRITIQUE")
            attention = sum(1 for c in combinations.values() if c['status'] == "ATTENTION")
            ok = sum(1 for c in combinations.values() if c['status'] == "OK")
            
            self.logger.info(f"\n{day_type.upper()}:")
            self.logger.info(f"Critiques  : {critical}")
            self.logger.info(f"Attention  : {attention}")
            self.logger.info(f"OK        : {ok}")
            
            

# core/Analyzer/availability_matrix.py

# core/Analyzer/availability_matrix.py

from datetime import date, timedelta
from typing import Dict, List, Tuple, Optional, Union
from core.Constantes.models import Doctor, CAT, Planning, TimeSlot, DayPlanning
from workalendar.europe import France
import logging

logger = logging.getLogger(__name__)

class AvailabilityMatrix:
    def __init__(self, start_date: date = None, end_date: date = None, doctors: List[Doctor] = None, cats: List[CAT] = None):
        self.start_date = start_date
        self.end_date = end_date
        self.doctors = doctors or []
        self.cats = cats or []
        self.cal = France()
        self.availability_matrix = {}
        self.critical_periods = []
        self._initialize_matrix()  # Renommé de init_matrix à _initialize_matrix
        
    def _initialize_matrix(self):  # Correction du nom de la méthode
        """Initialise la matrice de disponibilité"""
        self.availability_matrix = {
            person.name: {} for person in self.doctors + self.cats
        }
        
        if not (self.start_date and self.end_date):
            return

        # Initialiser la matrice avec les dates
        for person_name in self.availability_matrix:
            current_date = self.start_date
            while current_date <= self.end_date:
                self.availability_matrix[person_name][current_date] = {
                    1: True,  # Matin
                    2: True,  # Après-midi
                    3: True   # Soir/Nuit
                }
                current_date += timedelta(days=1)

        self._apply_desiderata()
        self._identify_critical_periods()

    def _apply_desiderata(self):
        """Applique les desiderata à la matrice"""
        if not (self.start_date and self.end_date):
            return
            
        for person in self.doctors + self.cats:
            for des in person.desiderata:
                current_date = max(des.start_date, self.start_date)
                end_date = min(des.end_date, self.end_date)
                while current_date <= end_date:
                    if current_date in self.availability_matrix[person.name]:
                        self.availability_matrix[person.name][current_date][des.period] = False
                    current_date += timedelta(days=1)

    def _identify_critical_periods(self):
        """Identifie les périodes critiques (≥35% d'indisponibilité)"""
        import random  # Ajouter en haut du fichier si pas déjà présent
        
        self.critical_periods = []
        
        if not (self.start_date and self.end_date):
            return

        current_date = self.start_date
        while current_date <= self.end_date:
            for period in [1, 2, 3]:  # Matin, Après-midi, Soir
                # Calculer le nombre de personnes disponibles
                available_count = sum(
                    1 for person in self.availability_matrix 
                    if current_date in self.availability_matrix[person] and 
                    self.availability_matrix[person][current_date][period]
                )
                
                total_personnel = len(self.doctors) + len(self.cats)
                if total_personnel == 0:
                    continue
                    
                # Calculer le pourcentage d'indisponibilité
                unavailability_percentage = ((total_personnel - available_count) / total_personnel) * 100
                
                # Ajouter si indisponibilité ≥ 35%
                if unavailability_percentage >= 35:
                    self.critical_periods.append((
                        current_date,
                        period,
                        unavailability_percentage,
                        available_count
                    ))
                    
            current_date += timedelta(days=1)

        # Trier d'abord par pourcentage d'indisponibilité (du plus critique au moins critique)
        self.critical_periods.sort(key=lambda x: (-x[2], x[3]))  # -x[2] pour ordre décroissant
        
        # Regrouper les périodes similaires (marge de 5%)
        if self.critical_periods:
            groups = []
            current_group = [self.critical_periods[0]]
            
            for i in range(1, len(self.critical_periods)):
                current = self.critical_periods[i]
                previous = current_group[0]
                
                if abs(current[2] - previous[2]) <= 5:  # Marge de 5%
                    current_group.append(current)
                else:
                    if len(current_group) > 1:
                        random.shuffle(current_group)
                    groups.extend(current_group)
                    current_group = [current]
            
            # Ne pas oublier le dernier groupe
            if len(current_group) > 1:
                random.shuffle(current_group)
            groups.extend(current_group)
            
            self.critical_periods = groups

        logger.debug(f"Périodes critiques identifiées : {len(self.critical_periods)}")
        for date, period, unavail_pct, available in self.critical_periods:
            period_name = {1: "Matin", 2: "Après-midi", 3: "Soir"}[period]
          

    def update_matrix(self, start_date: date, end_date: date):
        """Met à jour la matrice avec de nouvelles dates"""
        self.start_date = start_date
        self.end_date = end_date
        self._initialize_matrix()  # Utilisation du nouveau nom

    def get_period_availability(self, person: str, date: date, period: Union[int, str]) -> bool:
        """Vérifie la disponibilité d'une personne pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return (self.availability_matrix.get(person, {})
                .get(date, {})
                .get(period, False))

    def get_period_from_text(self, period_text: str) -> int:
        """Convertit une période textuelle en numéro"""
        period_mapping = {
            "morning": 1,
            "afternoon": 2,
            "evening": 3,
            "M": 1,
            "AM": 2,
            "S": 3,
        }
        return period_mapping.get(period_text, 1)

    def get_available_personnel(self, date: date, period: Union[int, str]) -> List[str]:
        """Retourne la liste du personnel disponible pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return [
            person for person in self.availability_matrix 
            if date in self.availability_matrix[person] and 
            self.availability_matrix[person][date][period]
        ]

    def update_availability(self, person: str, date: date, period: int, available: bool):
        """Met à jour la disponibilité"""
        try:
            if (person in self.availability_matrix and 
                date in self.availability_matrix[person]):
                self.availability_matrix[person][date][period] = available
                self._identify_critical_periods()  # Mettre à jour les périodes critiques
        except Exception as e:
            logger.error(f"Erreur mise à jour disponibilité pour {person} le {date}: {e}")
        
    def get_period_from_slot(self, slot: TimeSlot) -> int:
        """Détermine la période d'un slot"""
        start_hour = slot.start_time.hour
        if 7 <= start_hour < 13:
            return 1  # Matin
        elif 13 <= start_hour < 18:
            return 2  # Après-midi
        else:
            return 3  # Soir/Nuit

    def get_available_personnel(self, date: date, period: Union[int, str]) -> List[str]:
        """Retourne la liste du personnel disponible pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return [
            person for person in self.availability_matrix 
            if self.availability_matrix[person][date][period]
        ]


    def _update_critical_periods(self, date: date, period: int):
        """Met à jour les périodes critiques après une modification"""
        # Recalculer la disponibilité pour cette période
        available_count = sum(
            1 for person in self.availability_matrix 
            if self.availability_matrix[person][date][period]
        )
        
        # Mettre à jour la liste des périodes critiques
        self.critical_periods = [
            (d, p, c) for d, p, c in self.critical_periods 
            if d != date or p != period
        ]
        
        total_personnel = len(self.doctors) + len(self.cats)
        if available_count < total_personnel * 0.5:
            self.critical_periods.append((date, period, available_count))
            self.critical_periods.sort(key=lambda x: x[2])


   
    

# gui/main_window.py


# © 2024 HILAL Arkane. Tous droits réservés.
# .gui/main_window.py
from PyQt6.QtWidgets import QMainWindow, QTabWidget, QPushButton, QVBoxLayout, QWidget
from PyQt6.QtCore import Qt, QDate, QSize
from PyQt6.QtGui import QIcon
from .personnel_management import PersonnelManagementWidget
from .planning_view import PlanningViewWidget
from .desiderata_management import DesiderataManagementWidget
from .post_configuration import PostConfigurationWidget
from core.Constantes.data_persistence import DataPersistence
from .stats_view import StatsView
from .doctor_planning_view import DoctorPlanningView
from .planning_comparison_view import PlanningComparisonView
from .detached_stats_window import DetachedStatsWindow
from .planning_management import PlanningManagementWidget
from core.utils import resource_path



class MainWindow(QMainWindow):
    def __init__(self, doctors, cats, post_configuration):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.data_persistence = DataPersistence()
        self.detached_stats_window = None
        self.init_ui()
        
        self.planning_tab.dates_changed.connect(self.on_planning_dates_changed)

    def init_ui(self):
        self.setWindowTitle('Planificateur SOS Médecins')
        self.setGeometry(100, 100, 1200, 800)

        self.tab_widget = QTabWidget()
        self.tab_widget.setIconSize(QSize(32, 32))  # Définir la taille des icônes pour tous les onglets
        self.setCentralWidget(self.tab_widget)

        # Onglet Planning (créé en premier pour pouvoir accéder aux dates)
        self.planning_tab = PlanningViewWidget(self.doctors, self.cats, self.post_configuration, self)
        
        # Onglet Gestion du personnel
        self.personnel_tab = PersonnelManagementWidget(self.doctors, self.cats, self.post_configuration, self)
        self.tab_widget.addTab(self.personnel_tab, self.create_tab_icon("icons/personnel.png"), "Gestion du personnel")

        # Onglet Gestion des desiderata
        self.desiderata_tab = DesiderataManagementWidget(self.doctors, self.cats, self.planning_tab.start_date.date().toPyDate(), self.planning_tab.end_date.date().toPyDate(), self)
        self.tab_widget.addTab(self.desiderata_tab, self.create_tab_icon("icons/desiderata.png"), "Gestion des desiderata")

        # Ajout de l'onglet Planning
        self.tab_widget.addTab(self.planning_tab, self.create_tab_icon("icons/planning.png"), "Planning")

        # Onglet Planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        self.tab_widget.addTab(self.doctor_planning_view, self.create_tab_icon("icons/doctor_planning.png"), "Planning par médecin")

        # Onglet Statistiques
        self.stats_tab = StatsView(doctors=self.doctors, cats=self.cats)
        stats_container = QWidget()
        stats_layout = QVBoxLayout(stats_container)
        detach_button = QPushButton("Détacher les statistiques")
        detach_button.clicked.connect(self.detach_stats)
        stats_layout.addWidget(detach_button)
        stats_layout.addWidget(self.stats_tab)
        self.stats_index = self.tab_widget.addTab(stats_container, self.create_tab_icon("icons/statistics.png"), "Statistiques")

        # Onglet Comparaison des plannings
        self.comparison_view = PlanningComparisonView(None, self.doctors, self.cats, self)
        self.tab_widget.addTab(self.comparison_view, self.create_tab_icon("icons/comparaison.png"), "Comparaison des plannings")

        # Onglet Exporter
        self.planning_management_tab = PlanningManagementWidget(self)
        self.tab_widget.addTab(self.planning_management_tab, self.create_tab_icon("icons/export.png"), "Exporter")

        # Mettre à jour les dates dans PostConfigurationWidget
        start_date = self.planning_tab.start_date.date().toPyDate()
        end_date = self.planning_tab.end_date.date().toPyDate()
        self.personnel_tab.post_config_tab.update_dates(start_date, end_date)

        self.planning_tab.dates_changed.connect(self.on_planning_dates_changed)

    def create_tab_icon(self, icon_path, size=32):
        return QIcon(resource_path(icon_path))

   
    def on_planning_dates_changed(self, start_date, end_date):
        self.desiderata_tab.sync_dates_from_planning(start_date, end_date)


    def closeEvent(self, event):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        event.accept()

    def update_post_configuration(self, new_post_configuration):
        """Met à jour la configuration des postes"""
        try:
            self.post_configuration = new_post_configuration
            self.planning_tab.update_post_configuration(new_post_configuration)
            self.personnel_tab.post_config_tab.update_configuration(new_post_configuration)
            self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
            return True
        except Exception as e:
            self.logger.error(f"Erreur lors de la mise à jour de la configuration : {e}", exc_info=True)
            return False

    def update_data(self):
        self.personnel_tab.update_tables()
        self.planning_tab.update_data(self.doctors, self.cats, self.post_configuration)
        
        if hasattr(self.planning_tab, 'planning') and self.planning_tab.planning:
            start_date = self.planning_tab.planning.start_date
            end_date = self.planning_tab.planning.end_date
            
            # Mettre à jour les dates dans PlanningViewWidget
            self.planning_tab.start_date.setDate(QDate(start_date))
            self.planning_tab.end_date.setDate(QDate(end_date))
            
            # Mettre à jour les dates dans DesiderataManagementWidget
            self.desiderata_tab.sync_dates_from_planning(start_date, end_date)
            
            self.update_stats_view()
            self.comparison_view.planning = self.planning_tab.planning
            self.comparison_view.update_comparison(preserve_selection=True)
            self.doctor_planning_view.planning = self.planning_tab.planning
            self.doctor_planning_view.update_table()
        else:
            # Réinitialiser les vues si aucun planning n'est chargé
            self.stats_tab.clear_stats()
            self.comparison_view.reset_view()
            self.doctor_planning_view.clear_view()

        self.desiderata_tab.update_stats()
        self.personnel_tab.post_config_tab.update_configuration(self.post_configuration)
    def update_stats_view(self):
        if self.detached_stats_window:
            self.detached_stats_window.update_stats()
        else:
            self.stats_tab.update_stats(self.planning_tab.planning, self.doctors, self.cats)

    def save_data(self):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        self.planning_management_tab.update_planning_list()
    def detach_stats(self):
        if not self.detached_stats_window:
            self.tab_widget.removeTab(self.stats_index)
            self.detached_stats_window = DetachedStatsWindow(self)
            self.detached_stats_window.show()
            # Assurez-vous que les statistiques sont à jour lors du détachement
            self.update_stats_view()

    def reattach_stats(self):
        if self.detached_stats_window:
            self.detached_stats_window.close()
            self.detached_stats_window = None
            stats_container = QWidget()
            stats_layout = QVBoxLayout(stats_container)
            detach_button = QPushButton("Détacher les statistiques")
            detach_button.clicked.connect(self.detach_stats)
            stats_layout.addWidget(detach_button)
            stats_layout.addWidget(self.stats_tab)
            self.stats_index = self.tab_widget.insertTab(self.stats_index, stats_container, "Statistiques")
            self.tab_widget.setCurrentIndex(self.stats_index)
            # Assurez-vous que les statistiques sont à jour lors du rattachement
            self.update_stats_view()
            

    def reset_all_views(self):
        # Réinitialiser la vue de comparaison
        self.comparison_view.reset_view()
        
        # Réinitialiser la vue des statistiques
        self.stats_tab.clear_stats()
        
        # Réinitialiser la vue du planning par médecin
        self.doctor_planning_view.clear_view()
        
        # Mettre à jour les autres vues si nécessaire
        self.update_data()

# gui/stats_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/stats_view.py

import logging
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QTabWidget, QPushButton
from PyQt6.QtGui import QColor, QBrush, QFont
from PyQt6.QtCore import Qt
from core.Constantes.models import ALL_POST_TYPES
from core.Constantes.data_persistence import DataPersistence
from gui.post_configuration import PostConfig   
import numpy as np
from datetime import datetime, time, date
from typing import List, Dict, Optional, Tuple, Union
from PyQt6.QtCore import QPropertyAnimation, QEasingCurve, QTimer, Qt, QSize
from PyQt6.QtWidgets import QLabel
from PyQt6.QtGui import QPainter, QFontMetrics

# Initialiser le logger
logger = logging.getLogger(__name__)


class StatsView(QWidget):
    def __init__(self, planning=None, doctors=None, cats=None):
        super().__init__()
        self.planning = planning
        self.doctors = doctors
        self.cats = cats
        self.data_persistence = DataPersistence()
        self.custom_posts = self.load_custom_posts()
        
        # Définition des groupes de postes comme attribut de classe
        self.post_groups = {
            'matin': {
                'label': 'Matin',
                'posts': ['MM', 'CM', 'HM', 'SM', 'RM', 'ML', 'MC'],
                'color': QColor('#E3F2FD')
            },
            'apresMidi': {
                'label': 'Après-midi',
                'posts': ['CA', 'HA', 'SA', 'RA', 'AL', 'AC'],
                'color': QColor('#FFF3E0')
            },
            'soirNuit': {
                'label': 'Soir/Nuit',
                'posts': ['CS', 'HS', 'SS', 'RS', 'NL', 'NM', 'NA', 'NC'],
                'color': QColor('#EDE7F6')
            }
        }
        
        # Ajout des postes personnalisés aux groupes
        for post_name, custom_post in self.custom_posts.items():
            start_hour = custom_post.start_time.hour
            if 7 <= start_hour < 13:
                self.post_groups['matin']['posts'].append(post_name)
            elif 13 <= start_hour < 18:
                self.post_groups['apresMidi']['posts'].append(post_name)
            else:
                self.post_groups['soirNuit']['posts'].append(post_name)
        
        self.current_filter = 'all'  # Pour suivre le filtre actif
        self.init_ui()
        
        # Ajout des attributs pour la gestion de l'expansion
        self.expanded_group = None
        self.component_columns = {}
        self.group_details = {
            'NLw': {
                'components': ['NLv', 'NLs', 'NLd'],
                'description': 'Nuits longues weekend'
            },
            'NAMw': {
                'components': ['NAs', 'NAd', 'NMs', 'NMd'],
                'description': 'Nuits courtes et moyennes weekend'
            },
            'VmS': {
                'components': ['ML', 'MC'],
                'description': 'Visites matin samedi'
            },
            'VmD': {
                'components': ['ML', 'MC'],
                'description': 'Visites matin dimanche'
            },
            'VaSD': {
                'components': ['AL', 'AC'],
                'description': 'Visites après-midi weekend'
            },
            'CmS': {
                'components': ['CM', 'HM', 'SM', 'RM'],
                'description': 'Consultations matin samedi'
            },
            'CmD': {
                'components': ['CM', 'HM', 'SM', 'RM'],
                'description': 'Consultations matin dimanche'
            },
            'CaSD': {
                'components': ['CA', 'HA', 'SA', 'RA'],
                'description': 'Consultations après-midi weekend'
            },
            'CsSD': {
                'components': ['CS', 'HS', 'SS', 'RS'],
                'description': 'Consultations soir weekend'
            }
        }

    def init_ui(self):
        """Initialise l'interface utilisateur"""
        layout = QVBoxLayout(self)
        
        # Création des tableaux
        self.stats_table = QTableWidget()
        self.weekend_stats_table = QTableWidget()
        self.detailed_stats_table = QTableWidget()
        self.weekly_stats_table = QTableWidget()
        self.weekday_group_stats_table = QTableWidget()
        
        # Création des boutons de filtrage
        filter_widget = QWidget()
        filter_layout = QHBoxLayout(filter_widget)
        filter_layout.setContentsMargins(0, 0, 0, 10)
        
        self.filter_buttons = {}
        for group_key, group in self.post_groups.items():
            btn = QPushButton(group['label'])
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, k=group_key: self.apply_filter(k))
            filter_layout.addWidget(btn)
            self.filter_buttons[group_key] = btn
        
        all_btn = QPushButton("Tous")
        all_btn.setCheckable(True)
        all_btn.setChecked(True)
        all_btn.clicked.connect(lambda: self.apply_filter('all'))
        filter_layout.addWidget(all_btn)
        self.filter_buttons['all'] = all_btn
        
        layout.addWidget(filter_widget)
        
        # Création des onglets
        tab_widget = QTabWidget()
        
        def setup_table_in_tab(table, title):
            widget = QWidget()
            layout = QVBoxLayout(widget)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.addWidget(table)
            tab_widget.addTab(widget, title)
            
            # Configuration commune des tableaux
            table.setHorizontalScrollMode(QTableWidget.ScrollMode.ScrollPerPixel)
            table.setVerticalScrollMode(QTableWidget.ScrollMode.ScrollPerPixel)
            table.horizontalHeader().setFixedHeight(30)
            table.verticalHeader().setVisible(False)
        
        # Configuration de chaque tableau dans son onglet
        setup_table_in_tab(self.stats_table, "Statistiques générales")
        setup_table_in_tab(self.weekend_stats_table, "Statistiques weekend")
        setup_table_in_tab(self.detailed_stats_table, "Groupe Weekend")
        setup_table_in_tab(self.weekly_stats_table, "Statistiques semaine")
        setup_table_in_tab(self.weekday_group_stats_table, "Groupes semaine")
        
        layout.addWidget(tab_widget)
        
        # Configuration de la synchronisation du scroll
        self.setup_scroll_sync()
        
        if self.planning and self.doctors and self.cats:
            self.update_stats()
        else:
            self.set_empty_table_message(self.stats_table)
            self.set_empty_table_message(self.detailed_stats_table)
            self.set_empty_table_message(self.weekly_stats_table)
            self.set_empty_table_message(self.weekend_stats_table)
            self.set_empty_table_message(self.weekday_group_stats_table)
    def apply_filter(self, group_key):
        """Applique le filtre à tous les tableaux"""
        # Mise à jour des boutons
        self.current_filter = group_key
        for key, btn in self.filter_buttons.items():
            btn.setChecked(key == group_key)
        
        # Application du filtre à chaque tableau
        self._apply_filter_to_table(self.stats_table)
        self._apply_filter_to_table(self.weekend_stats_table)
        self._apply_filter_to_table(self.weekly_stats_table)
        self._apply_filter_to_table(self.detailed_stats_table)
        self._apply_filter_to_table(self.weekday_group_stats_table)

    def load_custom_posts(self):
        """Charge les postes personnalisés"""
        custom_posts_data = self.data_persistence.load_custom_posts()
        logger.info(f"Chargement des postes personnalisés: {custom_posts_data}")
        if custom_posts_data:
            try:
                if isinstance(next(iter(custom_posts_data.values())), dict):
                    from core.Constantes.custom_post import CustomPost
                    self.custom_posts = {
                        name: CustomPost.from_dict(data) 
                        for name, data in custom_posts_data.items()
                    }
                    logger.info(f"Postes personnalisés chargés: {list(self.custom_posts.keys())}")
                else:
                    self.custom_posts = custom_posts_data
                # Mise à jour des groupes après chargement
                self.update_post_groups()
                return self.custom_posts
            except Exception as e:
                logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")
        return {}
    
    def update_post_groups(self):
        """Met à jour les groupes avec les postes personnalisés"""
        # Réinitialisation des listes de postes dans les groupes
        self.post_groups = {
            'matin': {
                'label': 'Matin',
                'posts': ['MM', 'CM', 'HM', 'SM', 'RM', 'ML', 'MC'],
                'color': QColor('#E3F2FD')
            },
            'apresMidi': {
                'label': 'Après-midi',
                'posts': ['CA', 'HA', 'SA', 'RA', 'AL', 'AC'],
                'color': QColor('#FFF3E0')
            },
            'soirNuit': {
                'label': 'Soir/Nuit',
                'posts': ['CS', 'HS', 'SS', 'RS', 'NL', 'NM', 'NA', 'NC'],
                'color': QColor('#EDE7F6')
            }
        }

        # Ajout des postes personnalisés aux groupes appropriés
        logger.info("Mise à jour des groupes avec les postes personnalisés")
        for post_name, custom_post in self.custom_posts.items():
            logger.info(f"Traitement du poste {post_name}")
            start_hour = custom_post.start_time.hour
            if 7 <= start_hour < 13:
                self.post_groups['matin']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe matin")
            elif 13 <= start_hour < 18:
                self.post_groups['apresMidi']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe après-midi")
            else:
                self.post_groups['soirNuit']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe soir/nuit")

    def get_all_post_types(self):
        """Retourne tous les types de postes standards et personnalisés"""
        all_posts = set(ALL_POST_TYPES)
        if self.custom_posts:
            all_posts.update(self.custom_posts.keys())
        return sorted(list(all_posts))
        
    
    def get_post_group(self, post_type: str, day_info: Union[date, int]) -> str:
        """Détermine le groupe statistique d'un poste, y compris les postes personnalisés"""
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            return custom_post.statistic_group if custom_post.statistic_group else "Other"
            
            
    def set_empty_table_message(self, table):
        table.setRowCount(1)
        table.setColumnCount(1)
        table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))

    def update_stats(self, planning=None, doctors=None, cats=None):
        """Mise à jour de tous les tableaux de statistiques"""
        if planning is not None:
            self.planning = planning
        if doctors is not None:
            self.doctors = doctors
        if cats is not None:
            self.cats = cats
        
        # Recharger les postes personnalisés et mettre à jour les groupes
        self.custom_posts = self.load_custom_posts()
        
        if self.planning and self.doctors and self.cats:
            self.create_stats_table()
            detailed_stats = self.calculate_detailed_stats()
            self.update_detailed_stats_table(detailed_stats)
            weekly_stats = self.calculate_weekday_stats()
            self.update_weekly_stats_table(weekly_stats)
            weekend_stats = self.calculate_weekend_stats()
            self.update_weekend_stats_table(weekend_stats)
            weekday_group_stats = self.calculate_weekday_group_stats()
            self.update_weekday_group_stats_table(weekday_group_stats)
        else:
            self.set_empty_table_message(self.stats_table)
            self.set_empty_table_message(self.detailed_stats_table)
            self.set_empty_table_message(self.weekly_stats_table)
            self.set_empty_table_message(self.weekend_stats_table)
            self.set_empty_table_message(self.weekday_group_stats_table)




    def update_stats_table(self, stats, table):
        sorted_doctors = sorted([d.name for d in self.doctors], key=str.lower)
        sorted_cats = sorted([c.name for c in self.cats], key=str.lower)
        sorted_assignees = sorted_doctors + sorted_cats + ["Non attribué"]
        all_posts = self.get_all_post_types()

        table.setRowCount(len(sorted_assignees) + 1)
        table.setColumnCount(len(all_posts) + 2)

        headers = ["Assigné à"] + all_posts + ["Total"]
        table.setHorizontalHeaderLabels(headers)

        total_row = {post_type: 0 for post_type in all_posts}
        total_row["Total"] = 0

        for row, assignee in enumerate(sorted_assignees):
            table.setItem(row, 0, QTableWidgetItem(str(assignee)))
            assignee_stats = stats.get(assignee, {})

            assignee_total = 0
            for col, post_type in enumerate(all_posts, start=1):
                count = assignee_stats.get(post_type, 0)
                item = QTableWidgetItem(str(count))
                
                # Appliquer la couleur de fond pour les postes personnalisés en gérant les erreurs
                if hasattr(self, 'custom_posts') and post_type in self.custom_posts:
                    custom_post = self.custom_posts[post_type]
                    if hasattr(custom_post, 'color'):
                        item.setBackground(QBrush(custom_post.color))
                    elif isinstance(custom_post, dict) and 'color' in custom_post:
                        # Si c'est encore un dictionnaire, créer la couleur à partir de la valeur
                        item.setBackground(QBrush(QColor(custom_post['color'])))
                    else:
                        # Couleur par défaut si aucune n'est définie
                        item.setBackground(QBrush(QColor("#E6F3FF")))
                
                table.setItem(row, col, item)
                assignee_total += count
                total_row[post_type] += count

            table.setItem(row, len(all_posts) + 1, QTableWidgetItem(str(assignee_total)))
            total_row["Total"] += assignee_total

            # Griser les lignes des médecins à 1 demi-part
            doctor = next((d for d in self.doctors if d.name == assignee), None)
            if doctor and doctor.half_parts == 1:
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setBackground(QBrush(QColor(240, 240, 240)))

        self.add_total_row(table, total_row, all_posts)
    
    def add_total_row(self, table, total_row, all_posts):
        """Ajoute la ligne des totaux au tableau"""
        last_row = table.rowCount() - 1
        table.setItem(last_row, 0, QTableWidgetItem("Total"))
        for col, post_type in enumerate(all_posts, start=1):
            table.setItem(last_row, col, QTableWidgetItem(str(total_row[post_type])))
        table.setItem(last_row, len(all_posts) + 1, QTableWidgetItem(str(total_row["Total"])))
        
    def create_stats_table(self):
        """Crée le tableau principal des statistiques avec le nouveau design"""
        stats = self.calculate_stats()
        self.stats_table.clear()

        # Initialisation du tableau avec toutes les colonnes
        all_posts = []
        for group in self.post_groups.values():
            all_posts.extend(group['posts'])

        self.stats_table.setColumnCount(len(all_posts) + 2)  # +2 pour nom et total
        headers = ['Assigné à'] + all_posts + ['Total']
        self.stats_table.setHorizontalHeaderLabels(headers)

        # Coloration des en-têtes selon les groupes
        for col, post in enumerate(all_posts, start=1):
            for group in self.post_groups.values():
                if post in group['posts']:
                    header_item = self.stats_table.horizontalHeaderItem(col)
                    header_item.setBackground(group['color'])
                    break

        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes du tableau
        self.stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec badge CAT si nécessaire
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                badge_font = QFont()
                badge_font.setBold(True)
                name_item.setFont(badge_font)
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.stats_table.setItem(row, 0, name_item)

            # Valeurs des postes
            row_total = 0
            for col, post in enumerate(all_posts, start=1):
                count = stats.get(person.name, {}).get(post, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                        
                    # Coloration selon les intervalles pour les médecins
                    intervals = ideal_intervals.get(person.name, {}).get('weekday_posts', {}).get(post, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                if post in self.custom_posts:
                    item.setBackground(self.custom_posts[post].color)
                    
                self.stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.stats_table.setItem(row, len(all_posts) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row(len(all_personnel), stats, all_posts)
        self._add_total_row(len(all_personnel) + 1, stats, all_posts)

        # Configuration de l'affichage
        self.stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.stats_table.verticalHeader().setVisible(False)
        self.stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.stats_table)

    def _apply_filter_to_table(self, table):
        """Applique le filtre actuel à un tableau donné"""
        if not table:
            return

        for col in range(1, table.columnCount() - 1):  # Exclure nom et total
            header_item = table.horizontalHeaderItem(col)
            if not header_item:
                continue
                
            post = header_item.text()
            is_visible = self.current_filter == 'all'
            
            if not is_visible:
                # Vérifier si le poste appartient au groupe actif
                is_visible = post in self.post_groups.get(self.current_filter, {}).get('posts', [])
            
            table.setColumnHidden(col, not is_visible)
        
        # Mise à jour des totaux
        self._update_visible_totals(table)

    def _filter_posts(self, group_key):
        """Filtre les colonnes affichées selon le groupe sélectionné"""
        # Mise à jour des boutons
        for key, btn in self.filter_buttons.items():
            btn.setChecked(key == group_key)

        # Affichage/masquage des colonnes
        for col in range(1, self.stats_table.columnCount() - 1):  # Exclure la colonne nom et total
            header_item = self.stats_table.horizontalHeaderItem(col)
            post = header_item.text()
            
            if group_key == 'all':
                self.stats_table.setColumnHidden(col, False)
            else:
                # Vérifier si le poste appartient au groupe sélectionné
                visible = False
                if group_key in self.post_groups and post in self.post_groups[group_key]['posts']:
                    visible = True
                self.stats_table.setColumnHidden(col, not visible)

        # Recalcul des totaux visibles
        self._update_visible_totals
        
    def _update_visible_totals(self, table):
        """Met à jour les totaux en fonction des colonnes visibles"""
        if not table:
            return

        # Pour chaque ligne du tableau
        for row in range(table.rowCount()):
            visible_total = 0
            
            # Calcul du total sur les colonnes visibles uniquement
            for col in range(1, table.columnCount() - 1):  # Exclure nom et total
                if not table.isColumnHidden(col):
                    item = table.item(row, col)
                    if item:
                        try:
                            visible_total += int(item.text())
                        except ValueError:
                            continue

            # Mise à jour de la cellule total
            total_item = table.item(row, table.columnCount() - 1)
            if total_item:
                # Conserver le style existant
                background = total_item.background()
                font = total_item.font()
                
                # Mise à jour du total
                total_item = QTableWidgetItem(str(visible_total))
                total_item.setBackground(background)
                total_item.setFont(font)
                table.setItem(row, table.columnCount() - 1, total_item)

    def _calculate_row_total(self, table, row):
        """Calcule le total d'une ligne en ne prenant en compte que les colonnes visibles"""
        total = 0
        for col in range(1, table.columnCount() - 1):
            if not table.isColumnHidden(col):
                item = table.item(row, col)
                if item:
                    try:
                        total += int(item.text())
                    except ValueError:
                        continue
        return total
    def _add_unassigned_row(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des postes non attribués"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par poste
        for col, post_type in enumerate(all_posts, start=1):
            count = unassigned_stats.get(post_type, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.stats_table.setItem(row_index, len(all_posts) + 1, total_item)

    def _add_total_row(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des totaux"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par poste
        grand_total = 0
        for col, post_type in enumerate(all_posts, start=1):
            total = sum(person_stats.get(post_type, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.stats_table.setItem(row_index, len(all_posts) + 1, final_total)


    def update_detailed_stats_table(self, detailed_stats):
        """Mise à jour de l'onglet des groupes weekend avec fonctionnalité d'expansion"""
        self.detailed_stats_table.clear()
        self.expanded_group = None
        self.component_columns.clear()

        # Mettre à jour les composants des groupes avec les postes personnalisés
        self._update_group_components()

        # Configuration des données de base
        weekend_groups = {
            'gardes': {
                'label': 'Gardes',
                'groups': ['NLw', 'NAMw'],
                'color': QColor('#E3F2FD')
            },
            'visites': {
                'label': 'Visites',
                'groups': ['VmS', 'VmD', 'VaSD'],
                'color': QColor('#FFF3E0')
            },
            'consultations': {
                'label': 'Consultations',
                'groups': ['CmS', 'CmD', 'CaSD', 'CsSD'],
                'color': QColor('#EDE7F6')
            }
        }
 # Collecte des groupes principaux
        all_groups = []
        for category in weekend_groups.values():
            all_groups.extend(category['groups'])

        # Configuration initiale du tableau
        self.detailed_stats_table.setColumnCount(len(all_groups) + 2)  # +2 pour nom et total
        headers = ['Assigné à'] + all_groups + ['Total']
        
        # Modifier la création des en-têtes pour utiliser AnimatedDetailedGroupHeader
        for col, group in enumerate(all_groups, start=1):
            header_item = AnimatedDetailedGroupHeader(
                group, 
                self.group_details.get(group, {}).get('components', [])
            )
            self.detailed_stats_table.setHorizontalHeaderItem(col, header_item)
        
            
            # Coloration selon la catégorie
            for category in weekend_groups.values():
                if group in category['groups']:
                    header_item.setBackground(category['color'])
                    
                    # Ajout d'une infobulle explicative
                    tooltip = self.get_group_tooltip(group)
                    header_item.setToolTip(tooltip)
                    break
                # Configuration des événements d'en-tête
        self.detailed_stats_table.horizontalHeader().sectionClicked.connect(self._handle_header_click)


        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes
        self.detailed_stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec distinction CAT/mi-temps
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.detailed_stats_table.setItem(row, 0, name_item)

            # Valeurs des groupes
            row_total = 0
            for col, group in enumerate(all_groups, start=1):
                count = detailed_stats.get(person.name, {}).get(group, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                    
                    # Coloration selon les intervalles pour les médecins
                    intervals = ideal_intervals.get(person.name, {}).get('weekend_groups', {}).get(group, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                self.detailed_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.detailed_stats_table.setItem(row, len(all_groups) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_detailed(len(all_personnel), detailed_stats, all_groups)
        self._add_total_row_detailed(len(all_personnel) + 1, detailed_stats, all_groups)

        # Configuration de l'affichage
        self.detailed_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.detailed_stats_table.verticalHeader().setVisible(False)
        self.detailed_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.detailed_stats_table)

    def get_group_tooltip(self, group):
        """Retourne l'infobulle explicative pour chaque groupe"""
        tooltips = {
            'NLw': "Gardes de nuit longues weekend (NLv + NLs + NLd)",
            'NAMw': "Gardes de nuit courtes et moyennes weekend (NA + NM)",
            'VmS': "Visites du matin samedi",
            'VmD': "Visites du matin dimanche/férié",
            'VaSD': "Visites après-midi samedi et dimanche/férié",
            'CmS': "Consultations matin samedi",
            'CmD': "Consultations matin dimanche/férié",
            'CaSD': "Consultations après-midi samedi et dimanche/férié",
            'CsSD': "Consultations soir samedi et dimanche/férié"
        }
        return tooltips.get(group, "")
    
    def _handle_header_click(self, logical_index):
        """Gère le clic sur un en-tête de colonne"""
        if logical_index == 0 or logical_index == self.detailed_stats_table.columnCount() - 1:
            return  # Ignorer les clics sur 'Assigné à' et 'Total'

        header_item = self.detailed_stats_table.horizontalHeaderItem(logical_index)
        if not isinstance(header_item, DetailedGroupHeader):
            return

        if self.expanded_group == header_item.group_name:
            # Cacher les composants du groupe actuel
            self._collapse_group(header_item.group_name)
            self.expanded_group = None
        else:
            # Cacher les composants du groupe précédent s'il y en a un
            if self.expanded_group:
                self._collapse_group(self.expanded_group)
            
            # Montrer les composants du nouveau groupe
            self._expand_group(header_item.group_name)
            self.expanded_group = header_item.group_name

    def _update_group_components(self):
        """Met à jour les composants des groupes en incluant les postes personnalisés"""
        # Copie des composants standards
        updated_details = self.group_details.copy()
        
        # Parcourir tous les postes personnalisés
        for post_name, custom_post in self.custom_posts.items():
            if custom_post.statistic_group:
                # Si le poste appartient à un groupe
                group = custom_post.statistic_group
                if group in updated_details:
                    # Ajouter le poste personnalisé aux composants du groupe
                    if 'components' not in updated_details[group]:
                        updated_details[group]['components'] = []
                    updated_details[group]['components'].append(post_name)
                    
                    # Log pour le débogage
                    logger.info(f"Ajout du poste personnalisé {post_name} au groupe {group}")
        
        self.group_details = updated_details

    def calculate_weekend_component_stats(self):
        """
        Calcule les statistiques détaillées des composants pour les groupes weekend.
        Retourne un dictionnaire avec les stats de chaque composant par personne.
        """
        stats = {}
        if not self.planning:
            return stats

        # Initialiser les statistiques pour tout le personnel
        for person in self.doctors + self.cats:
            stats[person.name] = {}
            # Initialiser les composants pour chaque groupe
            for group_name, details in self.group_details.items():
                stats[person.name][group_name] = 0  # Total du groupe
                for component in details['components']:
                    stats[person.name][component] = 0  # Composants individuels

        # Ajouter "Non attribué"
        stats["Non attribué"] = {}
        for group_name, details in self.group_details.items():
            stats["Non attribué"][group_name] = 0
            for component in details['components']:
                stats["Non attribué"][component] = 0

        for day in self.planning.days:
            is_friday = day.date.weekday() == 4
            is_saturday = day.date.weekday() == 5
            is_sunday = day.date.weekday() == 6
            is_holiday = day.is_holiday_or_bridge

            for slot in day.slots:
                assignee = slot.assignee if slot.assignee in stats else "Non attribué"
                
                # Traitement spécial pour NLw et ses composants
                if slot.abbreviation == "NL":
                    stats[assignee]["NLw"] = stats[assignee].get("NLw", 0) + 1
                    if is_friday:
                        stats[assignee]["NLv"] = stats[assignee].get("NLv", 0) + 1
                    elif is_saturday:
                        stats[assignee]["NLs"] = stats[assignee].get("NLs", 0) + 1
                    elif is_sunday or is_holiday:
                        stats[assignee]["NLd"] = stats[assignee].get("NLd", 0) + 1
                        
                # Traitement pour NAMw
                elif slot.abbreviation in ["NA", "NM"] and (is_saturday or is_sunday or is_holiday):
                    stats[assignee]["NAMw"] = stats[assignee].get("NAMw", 0) + 1
                    if is_saturday:
                        if slot.abbreviation == "NA":
                            stats[assignee]["NAs"] = stats[assignee].get("NAs", 0) + 1
                        else:  # NM
                            stats[assignee]["NMs"] = stats[assignee].get("NMs", 0) + 1
                    else:  # Dimanche ou férié
                        if slot.abbreviation == "NA":
                            stats[assignee]["NAd"] = stats[assignee].get("NAd", 0) + 1
                        else:  # NM
                            stats[assignee]["NMd"] = stats[assignee].get("NMd", 0) + 1

                # Traitement pour les autres groupes selon group_details
                for group_name, details in self.group_details.items():
                    if slot.abbreviation in details['components']:
                        # Mettre à jour le composant individuel
                        stats[assignee][slot.abbreviation] = stats[assignee].get(slot.abbreviation, 0) + 1
                        
                        # Mettre à jour le total du groupe selon les conditions spécifiques
                        if group_name in ["VmS", "CmS"] and is_saturday:
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1
                        elif group_name in ["VmD", "CmD"] and (is_sunday or is_holiday):
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1
                        elif group_name in ["VaSD", "CaSD", "CsSD"] and (is_saturday or is_sunday or is_holiday):
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1

        return stats
    def _expand_group(self, group_name):
        """Version améliorée de l'expansion de groupe avec animation"""
        components = self.group_details[group_name]['components']
        if not components:
            return

        # Trouver la colonne du groupe
        group_index = -1
        for i in range(self.detailed_stats_table.columnCount()):
            header = self.detailed_stats_table.horizontalHeaderItem(i)
            if isinstance(header, AnimatedDetailedGroupHeader) and header.group_name == group_name:
                group_index = i
                break

        if group_index == -1:
            return

        # Mettre à jour l'indicateur
        header = self.detailed_stats_table.horizontalHeaderItem(group_index)
        header.toggle_expansion()

        # Insérer et préparer les colonnes des composants
        current_column = group_index + 1
        self.component_columns[group_name] = []
        stats = self.calculate_weekend_component_stats()

        # Créer les colonnes masquées initialement
        for component in components:
            self.detailed_stats_table.insertColumn(current_column)
            header_item = QTableWidgetItem(component)
            self.detailed_stats_table.setHorizontalHeaderItem(current_column, header_item)
            
            # Remplir les données
            for row in range(self.detailed_stats_table.rowCount()):
                person_name = self.detailed_stats_table.item(row, 0).text()
                value = stats.get(person_name, {}).get(component, 0)
                self.detailed_stats_table.setItem(row, current_column, QTableWidgetItem(str(value)))
            
            self.component_columns[group_name].append(current_column)
            current_column += 1

        # Lancer l'animation d'expansion
        animation = ColumnAnimation(
            self.detailed_stats_table,
            group_index + 1,
            group_index + len(components)
        )
        animation.expand()

    def _collapse_group(self, group_name):
        """Version améliorée de la réduction de groupe avec animation"""
        if group_name not in self.component_columns:
            return

        # Mettre à jour l'indicateur
        group_index = -1
        for i in range(self.detailed_stats_table.columnCount()):
            header = self.detailed_stats_table.horizontalHeaderItem(i)
            if isinstance(header, AnimatedDetailedGroupHeader) and header.group_name == group_name:
                group_index = i
                header.toggle_expansion()
                break

        # Lancer l'animation de réduction
        columns = self.component_columns[group_name]
        animation = ColumnAnimation(
            self.detailed_stats_table,
            min(columns),
            max(columns)
        )
        animation.collapse()
        
        # Supprimer les colonnes après l'animation
        def remove_columns():
            for column in sorted(self.component_columns[group_name], reverse=True):
                self.detailed_stats_table.removeColumn(column)
            self.component_columns.pop(group_name)

        QTimer.singleShot(animation.duration + 50, remove_columns)

    
    def _add_unassigned_row_detailed(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des postes non attribués pour les groupes weekend"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.detailed_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par groupe
        for col, group in enumerate(all_groups, start=1):
            count = unassigned_stats.get(group, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.detailed_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.detailed_stats_table.setItem(row_index, len(all_groups) + 1, total_item)

    def _add_total_row_detailed(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des totaux pour les groupes weekend"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.detailed_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par groupe
        grand_total = 0
        for col, group in enumerate(all_groups, start=1):
            # Exclure "Non attribué" du calcul s'il existe
            total = sum(person_stats.get(group, 0) 
                    for name, person_stats in stats.items() 
                    if name != "Non attribué")
            
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.detailed_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.detailed_stats_table.setItem(row_index, len(all_groups) + 1, final_total)

    def update_detailed_stats_with_custom_posts(self):
        """Mise à jour des statistiques détaillées pour inclure les postes personnalisés"""
        stats = self.calculate_detailed_stats()
        
        # Ajouter les groupes statistiques des postes personnalisés
        custom_groups = set()
        for post in self.custom_posts.values():
            if post.statistic_group:
                custom_groups.add(post.statistic_group)

        # Mettre à jour les en-têtes avec les nouveaux groupes
        headers = self.get_detailed_stats_headers()
        headers.extend(list(custom_groups))

        self.detailed_stats_table.setColumnCount(len(headers))
        self.detailed_stats_table.setHorizontalHeaderLabels(headers)

        # Mise à jour des données
        self.update_detailed_stats_table(stats)

    def update_weekday_group_stats_table(self, weekday_group_stats):
        self.weekday_group_stats_table.clear()
        headers = ["Assigné à", "XM", "XA", "XS", "NAC", "VsM", "VsA", "NL"]
        self.weekday_group_stats_table.setColumnCount(len(headers))
        self.weekday_group_stats_table.setHorizontalHeaderLabels(headers)
        
        sorted_doctors = sorted([d.name for d in self.doctors], key=str.lower)
        sorted_cats = sorted([c.name for c in self.cats], key=str.lower)
        sorted_assignees = sorted_doctors + sorted_cats + ["Non attribué"]
        
        self.weekday_group_stats_table.setRowCount(len(sorted_assignees))

        # Récupérer les intervalles idéaux depuis les résultats de la pré-analyse
        ideal_distribution = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_distribution = self.planning.pre_analysis_results.get('ideal_distribution', {})

        for row, assignee in enumerate(sorted_assignees):
            self.weekday_group_stats_table.setItem(row, 0, QTableWidgetItem(assignee))
            assignee_stats = weekday_group_stats.get(assignee, {})
            ideal_ranges = ideal_distribution.get(assignee, {}).get('weekday_groups', {})

            for col, group in enumerate(headers[1:], start=1):
                value = assignee_stats.get(group, 0)
                item = QTableWidgetItem(str(value))
                self.weekday_group_stats_table.setItem(row, col, item)

                ideal_range = ideal_ranges.get(group, {})
                min_val = ideal_range.get('min', 0)
                max_val = ideal_range.get('max', float('inf'))

                if value < min_val:
                    item.setBackground(QBrush(QColor(200, 255, 200)))  # Vert clair
                elif value > max_val + 2:
                    item.setBackground(QBrush(QColor(255, 200, 200)))  # Rouge clair

            # Griser les lignes des médecins à 1 demi-part
            doctor = next((d for d in self.doctors if d.name == assignee), None)
            if doctor and doctor.half_parts == 1:
                for col in range(self.weekday_group_stats_table.columnCount()):
                    item = self.weekday_group_stats_table.item(row, col)
                    if item:
                        item.setBackground(QBrush(QColor(240, 240, 240)))  # Gris clair

        self.weekday_group_stats_table.resizeColumnsToContents()
        self.weekday_group_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

    def update_weekly_stats_table(self, weekly_stats):
        self.weekly_stats_table.clear()
        self.weekly_stats_table.setColumnCount(len(ALL_POST_TYPES) + 2)
        headers = ["Assigné à"] + ALL_POST_TYPES + ["Total"]
        self.weekly_stats_table.setHorizontalHeaderLabels(headers)

        sorted_doctors = sorted([d.name for d in self.doctors], key=str.lower)
        sorted_cats = sorted([c.name for c in self.cats], key=str.lower)
        sorted_assignees = sorted_doctors + sorted_cats + ["Non attribué"]

        self.weekly_stats_table.setRowCount(len(sorted_assignees) + 1)  # +1 for the total row

        # Récupérer les intervalles idéaux depuis les résultats de la pré-analyse
        ideal_distribution = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_distribution = self.planning.pre_analysis_results.get('ideal_distribution', {})

        total_row = {post_type: 0 for post_type in ALL_POST_TYPES}
        total_row["Total"] = 0

        for row, assignee in enumerate(sorted_assignees):
            self.weekly_stats_table.setItem(row, 0, QTableWidgetItem(str(assignee)))
            assignee_stats = weekly_stats.get(assignee, {})
            ideal_ranges = ideal_distribution.get(assignee, {}).get('weekday_posts', {})

            assignee_total = 0
            for col, post_type in enumerate(ALL_POST_TYPES, start=1):
                count = assignee_stats.get(post_type, 0)
                item = QTableWidgetItem(str(count))
                self.weekly_stats_table.setItem(row, col, item)
                assignee_total += count
                total_row[post_type] += count

                ideal_range = ideal_ranges.get(post_type, {})
                min_val = ideal_range.get('min', 0)
                max_val = ideal_range.get('max', float('inf'))

                if count < min_val:
                    item.setBackground(QBrush(QColor(200, 255, 200)))  # Vert clair
                elif count > max_val + 2:
                    item.setBackground(QBrush(QColor(255, 200, 200)))  # Rouge clair

            self.weekly_stats_table.setItem(row, len(ALL_POST_TYPES) + 1, QTableWidgetItem(str(assignee_total)))
            total_row["Total"] += assignee_total

            # Griser les lignes des médecins à 1 demi-part
            doctor = next((d for d in self.doctors if d.name == assignee), None)
            if doctor and doctor.half_parts == 1:
                for col in range(self.weekly_stats_table.columnCount()):
                    item = self.weekly_stats_table.item(row, col)
                    if item:
                        item.setBackground(QBrush(QColor(240, 240, 240)))  # Gris clair

        # Add the total row
        last_row = self.weekly_stats_table.rowCount() - 1
        self.weekly_stats_table.setItem(last_row, 0, QTableWidgetItem("Total"))
        for col, post_type in enumerate(ALL_POST_TYPES, start=1):
            self.weekly_stats_table.setItem(last_row, col, QTableWidgetItem(str(total_row[post_type])))
        self.weekly_stats_table.setItem(last_row, len(ALL_POST_TYPES) + 1, QTableWidgetItem(str(total_row["Total"])))

        self.weekly_stats_table.resizeColumnsToContents()
        self.weekly_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

    def update_weekend_stats_table(self, weekend_stats):
        """Met à jour le tableau des statistiques weekend"""
        self.weekend_stats_table.clear()

        # Récupération des statistiques weekend
        stats = self.calculate_weekend_stats()

        # Récupération des configurations weekend depuis le planning
        weekend_config = {}
        holiday_config = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            weekend_config = self.planning.pre_analysis_results.get('total_posts', {}).get('saturday', {})
            holiday_config = self.planning.pre_analysis_results.get('total_posts', {}).get('sunday_holiday', {})

        # Création d'un set pour collecter tous les postes configurés
        active_posts = set()

        # Vérification des postes configurés ou utilisés
        for group in self.post_groups.values():
            for post in group['posts']:
                saturday_count = weekend_config.get(post, 0)
                holiday_count = holiday_config.get(post, 0)
                
                # Si le poste est configuré ou utilisé dans les stats
                if (saturday_count > 0 or holiday_count > 0 or
                    any(stats[person.name].get(post, 0) > 0 for person in self.doctors + self.cats)):
                    active_posts.add(post)

        # Organisation des postes selon l'ordre des groupes
        all_posts = []
        for group in self.post_groups.values():
            # Ajouter uniquement les postes actifs de ce groupe, dans l'ordre du groupe
            group_posts = [post for post in group['posts'] if post in active_posts]
            all_posts.extend(group_posts)

        # Configuration du tableau
        self.weekend_stats_table.setColumnCount(len(all_posts) + 2)
        headers = ['Assigné à'] + all_posts + ['Total']
        self.weekend_stats_table.setHorizontalHeaderLabels(headers)

        # Coloration des en-têtes selon les groupes
        for col, post in enumerate(all_posts, start=1):
            for group in self.post_groups.values():
                if post in group['posts']:
                    header_item = self.weekend_stats_table.horizontalHeaderItem(col)
                    header_item.setBackground(group['color'])

                    # Ajouter une info-bulle avec la configuration
                    saturday_count = weekend_config.get(post, 0)
                    holiday_count = holiday_config.get(post, 0)
                    tooltip = f"Configuration :\nSamedi : {saturday_count}\nDimanche/Férié : {holiday_count}"
                    header_item.setToolTip(tooltip)
                    break

        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes du tableau
        self.weekend_stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec distinction CAT/mi-temps
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                badge_font = QFont()
                badge_font.setBold(True)
                name_item.setFont(badge_font)
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.weekend_stats_table.setItem(row, 0, name_item)

            # Valeurs des postes
            row_total = 0
            for col, post in enumerate(all_posts, start=1):
                count = stats.get(person.name, {}).get(post, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                        
                    # Coloration selon les intervalles pour les médecins
                    intervals = ideal_intervals.get(person.name, {}).get('weekend_posts', {}).get(post, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                if post in self.custom_posts:
                    item.setBackground(self.custom_posts[post].color)
                    
                self.weekend_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.weekend_stats_table.setItem(row, len(all_posts) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_weekend(len(all_personnel), stats, all_posts)
        self._add_total_row_weekend(len(all_personnel) + 1, stats, all_posts)

        # Configuration de l'affichage
        self.weekend_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.weekend_stats_table.verticalHeader().setVisible(False)
        self.weekend_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.weekend_stats_table)
    
    def _add_unassigned_row_weekend(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des postes non attribués pour les statistiques weekend"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.weekend_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par poste
        for col, post_type in enumerate(all_posts, start=1):
            count = unassigned_stats.get(post_type, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.weekend_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.weekend_stats_table.setItem(row_index, len(all_posts) + 1, total_item)

    def _add_total_row_weekend(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des totaux pour les statistiques weekend"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekend_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par poste
        grand_total = 0
        for col, post_type in enumerate(all_posts, start=1):
            total = sum(person_stats.get(post_type, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.weekend_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekend_stats_table.setItem(row_index, len(all_posts) + 1, final_total)

    def calculate_stats(self):
        # Récupérer tous les types de postes possibles
        all_post_types = set(ALL_POST_TYPES)  # Postes standards
        
        # Ajouter les postes personnalisés s'ils existent
        if hasattr(self, 'custom_posts'):
            all_post_types.update(self.custom_posts.keys())
        
        # Initialiser les stats avec tous les types de postes
        stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}
        
        if not self.planning or not self.planning.days:
            return stats

        for day_planning in self.planning.days:
            for slot in day_planning.slots:
                # S'assurer que le type de poste existe dans les stats
                if slot.abbreviation not in stats["Non attribué"]:
                    # Ajouter le nouveau type de poste à tous les dictionnaires
                    for person_stats in stats.values():
                        person_stats[slot.abbreviation] = 0
                        
                if slot.assignee in stats:
                    stats[slot.assignee][slot.abbreviation] += 1
                else:
                    stats["Non attribué"][slot.abbreviation] += 1

        return stats
    
    def calculate_detailed_stats(self):
        stats = {person.name: {
            "NLv": 0, "NLs": 0, "NLd": 0, "NLw": 0, "NAMw": 0,
            "VmS": 0, "VmD": 0, "VaSD": 0,
            "CmS": 0, "CmD": 0, "CaS": 0, "CaD": 0, "CaSD": 0, "CsS": 0, "CsD": 0, "CsSD": 0,
            "WE Lib": 0
        } for person in self.doctors + self.cats}
        stats["Non attribué"] = {key: 0 for key in stats[self.doctors[0].name].keys()}

        if not self.planning or not self.planning.days:
            return stats

        for day in self.planning.days:
            is_friday = day.date.weekday() == 4
            is_saturday = day.date.weekday() == 5
            is_sunday_holiday = day.date.weekday() == 6 or day.is_holiday_or_bridge
            is_weekend_or_holiday = is_saturday or is_sunday_holiday

            for slot in day.slots:
                assignee = slot.assignee if slot.assignee in stats else "Non attribué"
                if slot.abbreviation == "NL":
                    if is_friday:
                        stats[assignee]["NLv"] += 1
                        stats[assignee]["NLw"] += 1
                    elif is_saturday:
                        stats[assignee]["NLs"] += 1
                        stats[assignee]["NLw"] += 1
                    elif is_sunday_holiday:
                        stats[assignee]["NLd"] += 1
                        stats[assignee]["NLw"] += 1
                elif slot.abbreviation in ["NM", "NA"] and is_weekend_or_holiday:
                    stats[assignee]["NAMw"] += 1
                elif slot.abbreviation == "ML" and is_saturday:
                    stats[assignee]["VmS"] += 1
                elif (slot.abbreviation == "ML" or slot.abbreviation == "MC") and is_sunday_holiday:
                    stats[assignee]["VmD"] += 1
                elif slot.abbreviation in ["AL", "AC"] and is_weekend_or_holiday:
                    stats[assignee]["VaSD"] += 1
                elif slot.abbreviation in ["CM", "HM"] and is_saturday:
                    stats[assignee]["CmS"] += 1
                elif slot.abbreviation in ["CM", "HM", "SM", "RM"] and is_sunday_holiday:
                    stats[assignee]["CmD"] += 1
                elif slot.abbreviation in ["CA", "HA", "RA", "SA"] and is_saturday:
                    stats[assignee]["CaS"] += 1
                    stats[assignee]["CaSD"] += 1
                elif slot.abbreviation in ["CA", "HA", "RA", "SA"] and is_sunday_holiday:
                    stats[assignee]["CaD"] += 1
                    stats[assignee]["CaSD"] += 1
                elif slot.abbreviation in ["CS", "HS", "RS", "SS"] and is_saturday:
                    stats[assignee]["CsS"] += 1
                    stats[assignee]["CsSD"] += 1
                elif slot.abbreviation in ["CS", "HS", "RS", "SS"] and is_sunday_holiday:
                    stats[assignee]["CsD"] += 1
                    stats[assignee]["CsSD"] += 1

        for person in self.doctors + self.cats:
            stats[person.name]["WE Lib"] = self.calculate_we_lib(person.name)

        return stats

    def calculate_weekday_group_stats(self):
        stats = {person.name: {
            "XM": 0, "XA": 0, "XS": 0, "NAC": 0, "VsM": 0, "VsA": 0, "NL": 0
        } for person in self.doctors + self.cats}
        stats["Non attribué"] = {key: 0 for key in stats[self.doctors[0].name].keys()}

        if not self.planning or not self.planning.days:
            return stats

        for day in self.planning.days:
            if day.date.weekday() < 5 and not day.is_holiday_or_bridge:  # Jours de semaine uniquement, hors jours fériés et ponts
                for slot in day.slots:
                    assignee = slot.assignee if slot.assignee in stats else "Non attribué"
                    if slot.abbreviation in ["CM", "HM", "RM", "SM"]:
                        stats[assignee]["XM"] += 1
                    elif slot.abbreviation in ["CA", "HA", "RA", "SA"]:
                        stats[assignee]["XA"] += 1
                    elif slot.abbreviation in ["CS", "RS", "SS", "HS"]:
                        stats[assignee]["XS"] += 1
                    elif slot.abbreviation in ["NA", "NC"]:
                        stats[assignee]["NAC"] += 1
                    elif slot.abbreviation in ["ML", "MC"]:
                        stats[assignee]["VsM"] += 1
                    elif slot.abbreviation in ["AL", "AC"]:
                        stats[assignee]["VsA"] += 1
                    elif slot.abbreviation == "NL":
                        stats[assignee]["NL"] += 1

        return stats


    def calculate_weekday_stats(self):
        # Récupérer tous les types de postes possibles
        all_post_types = set(ALL_POST_TYPES)  # Postes standards
        
        # Ajouter les postes personnalisés s'ils existent
        if hasattr(self, 'custom_posts'):
            all_post_types.update(self.custom_posts.keys())
        
        # Initialiser les statistiques avec tous les types de postes
        weekday_stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        weekday_stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        weekday_stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}

        if not self.planning or not self.planning.days:
            return weekday_stats

        for day in self.planning.days:
            if day.date.weekday() < 5 and not day.is_holiday_or_bridge:
                for slot in day.slots:
                    # S'assurer que le type de poste existe dans les stats
                    if slot.abbreviation not in weekday_stats["Non attribué"]:
                        # Ajouter le nouveau type de poste à tous les dictionnaires
                        for person_stats in weekday_stats.values():
                            person_stats[slot.abbreviation] = 0

                    # Comptabiliser le poste
                    if slot.assignee and slot.assignee in weekday_stats:
                        weekday_stats[slot.assignee][slot.abbreviation] += 1
                    else:
                        weekday_stats["Non attribué"][slot.abbreviation] += 1

        return weekday_stats

    def calculate_weekend_stats(self):
        # Récupérer tous les types de postes possibles
        all_post_types = set(ALL_POST_TYPES)  # Postes standards
        
        # Ajouter les postes personnalisés s'ils existent
        if self.custom_posts:
            all_post_types.update(self.custom_posts.keys())
            logger.debug(f"Types de postes incluant les postes personnalisés: {all_post_types}")
            
        # Initialiser les statistiques avec tous les types de postes
        weekend_stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        weekend_stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        weekend_stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}

        if not self.planning or not self.planning.days:
            logger.debug("Pas de planning à analyser")
            return weekend_stats

        for day in self.planning.days:
            is_weekend = day.date.weekday() in [5, 6]
            is_friday = day.date.weekday() == 4
            is_holiday_or_bridge = day.is_holiday_or_bridge

            if is_weekend or is_holiday_or_bridge or (is_friday and not is_holiday_or_bridge):
                for slot in day.slots:
                    # Pour les vendredis non fériés, ne comptabiliser que les NL
                    if is_friday and not is_holiday_or_bridge and slot.abbreviation != "NL":
                        continue
                    
                    # Si on rencontre un nouveau type de poste, l'ajouter aux dictionnaires
                    if slot.abbreviation not in weekend_stats["Non attribué"]:
                        logger.debug(f"Nouveau type de poste détecté: {slot.abbreviation}")
                        for person_stats in weekend_stats.values():
                            person_stats[slot.abbreviation] = 0

                    # Comptabiliser le poste
                    if slot.assignee and slot.assignee in weekend_stats:
                        weekend_stats[slot.assignee][slot.abbreviation] += 1
                    else:
                        weekend_stats["Non attribué"][slot.abbreviation] += 1

        logger.debug("Calcul des statistiques du weekend terminé")
        return weekend_stats

    def calculate_we_lib(self, person_name):
        we_lib = 0
        current_we_start = None
        consecutive_free_days = 0
        
        for day in self.planning.days:
            is_weekend_or_holiday = day.date.weekday() >= 5 or day.is_holiday_or_bridge
            
            if is_weekend_or_holiday:
                if current_we_start is None:
                    current_we_start = day.date
                
                # Vérifier si la personne travaille ce jour-là
                person_works = any(slot.assignee == person_name and
                                ((slot.start_time.time() >= time(3, 0) and day.date == current_we_start) or
                                    (slot.end_time.time() <= time(23, 59) and (day.date - current_we_start).days >= 1))
                                for slot in day.slots)
                
                if person_works:
                    current_we_start = None
                    consecutive_free_days = 0
                else:
                    consecutive_free_days += 1
                    if consecutive_free_days == 2:
                        we_lib += 1
                        current_we_start = None
                        consecutive_free_days = 0
            else:
                current_we_start = None
                consecutive_free_days = 0
        
        return we_lib
    
    
    
    def uniformize_table_style(self, table):
        # Définir une taille de police uniforme
        table.setStyleSheet("font-size: 12px;")

        # Appliquer une taille de ligne uniforme
        table.verticalHeader().setDefaultSectionSize(24)  # Par exemple, 24 pixels de hauteur

        # Appliquer une largeur uniforme pour chaque colonne
        table.horizontalHeader().setDefaultSectionSize(100)  # Largeur par défaut des colonnes

        # Ajuster les colonnes pour remplir l'espace
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        
    def clear_stats(self):
        self.planning = None
        self.stats_table.setRowCount(0)
        self.stats_table.setColumnCount(0)
        self.weekend_stats_table.setRowCount(0)
        self.weekend_stats_table.setColumnCount(0)
        self.detailed_stats_table.setRowCount(0)
        self.detailed_stats_table.setColumnCount(0)
        self.weekly_stats_table.setRowCount(0)
        self.weekly_stats_table.setColumnCount(0)
        self.weekday_group_stats_table.setRowCount(0)
        self.weekday_group_stats_table.setColumnCount(0)


    def update_color_coding(self, item: QTableWidgetItem, post_type: str):
        """Met à jour la couleur de fond des cellules en fonction du type de poste"""
        if post_type in self.custom_posts:
            item.setBackground(self.custom_posts[post_type].color)
            
            
            
    
    
    
    
    def setup_scroll_sync(self):
        """Configure la synchronisation du scroll entre tous les tableaux de statistiques"""
        tables = [
            self.stats_table,
            self.weekend_stats_table,
            self.detailed_stats_table,
            self.weekly_stats_table,
            self.weekday_group_stats_table
        ]

        # Synchronisation du scroll vertical
        def sync_vertical_scroll(source_table):
            def _sync_scroll(value):
                # Synchroniser tous les autres tableaux avec la position de scroll de la source
                for table in tables:
                    if table != source_table and table.verticalScrollBar():
                        table.verticalScrollBar().setValue(value)
            return _sync_scroll

        # Synchronisation du scroll horizontal
        def sync_horizontal_scroll(source_table):
            def _sync_scroll(value):
                # Synchroniser tous les autres tableaux avec la position de scroll de la source
                for table in tables:
                    if table != source_table and table.horizontalScrollBar():
                        table.horizontalScrollBar().setValue(value)
            return _sync_scroll

        # Application de la synchronisation à tous les tableaux
        for table in tables:
            if table.verticalScrollBar():
                table.verticalScrollBar().valueChanged.connect(
                    sync_vertical_scroll(table)
                )
            if table.horizontalScrollBar():
                table.horizontalScrollBar().valueChanged.connect(
                    sync_horizontal_scroll(table)
                )
                
                
                
                


class DetailedGroupHeader(QTableWidgetItem):
    """Classe personnalisée pour les en-têtes de groupe avec fonctionnalité d'expansion"""
    def __init__(self, group_name, components=None):
        super().__init__(group_name)
        self.group_name = group_name
        self.components = components or []
        self.is_expanded = False
        
class AnimatedDetailedGroupHeader(DetailedGroupHeader):
    """En-tête de groupe amélioré avec indicateur d'expansion"""
    def __init__(self, group_name, components=None):
        super().__init__(group_name, components)
        self._arrow_expanded = "▼"
        self._arrow_collapsed = "►"
        self._update_text()

    def _update_text(self):
        """Met à jour le texte avec l'indicateur approprié"""
        arrow = self._arrow_expanded if self.is_expanded else self._arrow_collapsed
        self.setText(f"{arrow} {self.group_name}")

    def toggle_expansion(self):
        """Change l'état d'expansion et met à jour l'indicateur"""
        self.is_expanded = not self.is_expanded
        self._update_text()

class ColumnAnimation:
    """Gère l'animation des colonnes lors de l'expansion/réduction"""
    def __init__(self, table, start_col, end_col, duration=300):
        self.table = table
        self.start_col = start_col
        self.end_col = end_col
        self.duration = duration
        self.animations = []

    def expand(self):
        """Anime l'expansion des colonnes"""
        for col in range(self.start_col, self.end_col + 1):
            anim = QPropertyAnimation(self.table.horizontalHeader(), b"sectionSize")
            anim.setDuration(self.duration)
            anim.setStartValue(0)
            target_width = int(self.table.columnWidth(self.start_col - 1) * 0.6)
            anim.setEndValue(target_width)
            anim.setEasingCurve(QEasingCurve.Type.OutQuad)
            
            # Décalage progressif pour effet cascade
            QTimer.singleShot((col - self.start_col) * 50, anim.start)
            self.animations.append(anim)

    def collapse(self):
        """Anime la réduction des colonnes"""
        for col in range(self.end_col, self.start_col - 1, -1):
            anim = QPropertyAnimation(self.table.horizontalHeader(), b"sectionSize")
            anim.setDuration(self.duration)
            anim.setStartValue(self.table.columnWidth(col))
            anim.setEndValue(0)
            anim.setEasingCurve(QEasingCurve.Type.InQuad)
            
            # Décalage progressif pour effet cascade
            QTimer.singleShot((self.end_col - col) * 50, anim.start)
            self.animations.append(anim)

# gui/planning_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_management.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QTextEdit, QFileDialog, QMessageBox, QListWidget)
from PyQt6.QtCore import Qt, QDate
import os
import json
import csv
import openpyxl
from datetime import datetime, timedelta
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from calendar import monthrange, day_abbr
from openpyxl.utils import get_column_letter
from core.Constantes.models import Planning, DayPlanning, TimeSlot
from workalendar.europe import France

ORDERED_POST_TYPES = [
    "MLD1", "ACD1", "MCD1", "ALD1", "MLD2", "ACD2", "MCD2", "ALD2", "MLD3", "ACD3", "MCD3", "ALD3",
    "MLD4", "ACD4", "MCD4", "ALD4", "MLD5", "ACD5", "MCD5", "ALD5", "MMD1", "MMD2", "AMD1", "NLD1",
    "NLD2", "NMD1", "NMD2", "NMD3", "NAD1", "NAD2", "NAD3", "NZD1", "NCD1", "NCD2", "NCD3", "SMD1",
    "SAD1", "SSD1", "RMD1", "RAD1", "RSD1", "HMD1", "HAD1", "HSD1", "CMD1", "CAD1", "CSD1", "CMD2",
    "CAD2", "CSD2", "CMD3", "CAD3", "CMD4", "CAD4", "CTD1"
]
POST_TYPE_MAPPING = {
    "ML": "MLD", "AC": "ACD", "MC": "MCD", "AL": "ALD", "MM": "MMD", "AM": "AMD",
    "NL": "NLD", "NM": "NMD", "NA": "NAD", "NC": "NCD", "SM": "SMD", "SA": "SAD",
    "SS": "SSD", "RM": "RMD", "RA": "RAD", "RS": "RSD", "HM": "HMD", "HA": "HAD",
    "HS": "HSD", "CM": "CMD", "CA": "CAD", "CS": "CSD", "CT": "CTD"
}
class PlanningManagementWidget(QWidget):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.cal = France()  # Initialisation du calendrier ici
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Boutons
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Sauvegarder le planning")
        self.load_button = QPushButton("Charger un planning")
        self.export_csv_button = QPushButton("Exporter en CSV")
        self.export_excel_button = QPushButton("Exporter en Excel")
        
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.load_button)
        button_layout.addWidget(self.export_csv_button)
        button_layout.addWidget(self.export_excel_button)
        
        layout.addLayout(button_layout)

        # Liste des plannings
        self.planning_list = QListWidget()
        layout.addWidget(self.planning_list)

        # Connecter les boutons aux fonctions
        self.save_button.clicked.connect(self.save_planning)
        self.load_button.clicked.connect(self.load_planning)
        self.export_csv_button.clicked.connect(self.export_to_csv)
        self.export_excel_button.clicked.connect(self.export_to_excel)

        # Mettre à jour la liste des plannings
        self.update_planning_list()

    def save_planning(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à sauvegarder.")
            return

        planning = self.main_window.planning_tab.planning
        start_date = planning.start_date
        end_date = planning.end_date
        filename = f"P {start_date.strftime('%b')} - {end_date.strftime('%b')} - {end_date.year}.json"

        data = {
            "start_date": start_date.isoformat(),
            "end_date": end_date.isoformat(),
            "days": [
                {
                    "date": day.date.isoformat(),
                    "slots": [
                        {
                            "start_time": slot.start_time.isoformat(),
                            "end_time": slot.end_time.isoformat(),
                            "site": slot.site,
                            "slot_type": slot.slot_type,
                            "abbreviation": slot.abbreviation,
                            "assignee": slot.assignee
                        } for slot in day.slots
                    ]
                } for day in planning.days
            ]
        }

        with open(filename, 'w') as f:
            json.dump(data, f)

        self.update_planning_list()
        QMessageBox.information(self, "Succès", f"Planning sauvegardé sous {filename}")

    def load_planning(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Charger un planning", "", "Fichiers JSON (*.json)")
        if not filename:
            return

        with open(filename, 'r') as f:
            data = json.load(f)

        planning = Planning(
            start_date=datetime.fromisoformat(data['start_date']).date(),
            end_date=datetime.fromisoformat(data['end_date']).date()
        )

        for day_data in data['days']:
            day = DayPlanning(date=datetime.fromisoformat(day_data['date']).date())
            for slot_data in day_data['slots']:
                slot = TimeSlot(
                    start_time=datetime.fromisoformat(slot_data['start_time']),
                    end_time=datetime.fromisoformat(slot_data['end_time']),
                    site=slot_data['site'],
                    slot_type=slot_data['slot_type'],
                    abbreviation=slot_data['abbreviation'],
                    assignee=slot_data['assignee']
                )
                day.slots.append(slot)
            planning.days.append(day)

        if 'pre_analysis_results' in data:
            planning.pre_analysis_results = data['pre_analysis_results']
        else:
            planning.pre_analysis_results = {}

        self.main_window.planning_tab.planning = planning
        
        # Mettre à jour les dates dans PlanningViewWidget
        self.main_window.planning_tab.start_date.setDate(QDate(planning.start_date))
        self.main_window.planning_tab.end_date.setDate(QDate(planning.end_date))
        
        # Mettre à jour les dates dans DesiderataManagementWidget
        self.main_window.desiderata_tab.sync_dates_from_planning(planning.start_date, planning.end_date)
        
        self.main_window.planning_tab.update_table()
        self.main_window.update_data()
        QMessageBox.information(self, "Succès", f"Planning chargé depuis {filename}")

    def export_to_csv(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à exporter.")
            return

        folder = QFileDialog.getExistingDirectory(self, "Sélectionner le dossier d'exportation")
        if not folder:
            return

        planning = self.main_window.planning_tab.planning
        
        # Exporter le planning global
        self.export_global_planning_to_csv(planning, folder)

        # Exporter les plannings individuels
        for person in self.main_window.doctors + self.main_window.cats:
            self.export_individual_planning_to_csv(planning, person, folder)

        QMessageBox.information(self, "Succès", f"Plannings exportés en CSV dans {folder}")

    def export_to_excel(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à exporter.")
            return

        folder = QFileDialog.getExistingDirectory(self, "Sélectionner le dossier d'exportation")
        if not folder:
            return

        planning = self.main_window.planning_tab.planning
        
        # Exporter tous les plannings dans un seul fichier Excel
        self.export_all_plannings_to_excel(planning, folder)

        QMessageBox.information(self, "Succès", f"Plannings exportés en Excel dans {folder}")

    def update_planning_list(self):
        self.planning_list.clear()
        plannings = [f for f in os.listdir() if f.startswith("P ") and f.endswith(".json")]
        self.planning_list.addItems(plannings)

    def export_global_planning_to_csv(self, planning, folder):
        filename = os.path.join(folder, f"Planning_global_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.csv")
        
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            
            for day in planning.days:
                date_str = day.date.strftime('%d/%m/%Y')
                slots_by_type = {}
                
                # Regrouper les slots par type de poste
                for slot in day.slots:
                    base_type = POST_TYPE_MAPPING.get(slot.abbreviation, slot.abbreviation)
                    if base_type not in slots_by_type:
                        slots_by_type[base_type] = []
                    slots_by_type[base_type].append(slot)
                
                # Écrire les lignes pour chaque type de poste ordonné
                for post_type in ORDERED_POST_TYPES:
                    base_type = post_type[:-1] if post_type[-1].isdigit() else post_type
                    index = int(post_type[-1]) if post_type[-1].isdigit() else 1
                    
                    if base_type in slots_by_type and index <= len(slots_by_type[base_type]):
                        slot = slots_by_type[base_type][index - 1]
                        writer.writerow(["+", date_str, slot.assignee or "", post_type])
                    else:
                        writer.writerow(["+", date_str, "", post_type])

    def export_individual_planning_to_csv(self, planning, person, folder):
        filename = os.path.join(folder, f"Planning_{person.name}_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.csv")
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Date', 'Créneau', 'Type', 'Site'])
            for day in planning.days:
                for slot in day.slots:
                    if slot.assignee == person.name:
                        writer.writerow([
                            day.date.strftime('%d-%m-%y'),
                            f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}",
                            slot.abbreviation,
                            slot.site
                        ])

    def export_all_plannings_to_excel(self, planning, folder):
        filename = os.path.join(folder, f"Tous_les_plannings_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.xlsx")
        workbook = openpyxl.Workbook()
        
        # Supprimer la feuille par défaut
        workbook.remove(workbook.active)
        
        # Créer une feuille pour chaque médecin et CAT
        for person in self.main_window.doctors + self.main_window.cats:
            sheet = workbook.create_sheet(title=person.name)
            self.create_individual_planning_sheet(sheet, planning, person)

        workbook.save(filename)

    def create_individual_planning_sheet(self, sheet, planning, person):
        cal = self.cal  # Utiliser le calendrier de l'instance
    
        
        # Define colors and styles
        weekend_color = PatternFill(start_color="F0F0F0", end_color="F0F0F0", fill_type="solid")
        desiderata_color = PatternFill(start_color="FFE6E6", end_color="FFE6E6", fill_type="solid")
        weekend_desiderata_color = PatternFill(start_color="FFCCCB", end_color="FFCCCB", fill_type="solid")
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

        # Set column widths
        sheet.column_dimensions['A'].width = 5  # Jour (Numeric day column)
        sheet.column_dimensions['B'].width = 5  # Semaine column (used as a separator)

        # Create the header with months and days
        months = self.get_month_names(planning.start_date, planning.end_date)
        header = ["Jour", "Sem"]  # Add "Sem" as a standalone column for reference
        for month in months:
            header.extend([month, "", "", ""])  # Four columns for J, M, AM, S
        sheet.append(header)
        
        # Merge cells for the month headers and add subheaders for J, M, AM, S
        col = 3  # Start from column 3 to skip "Jour" and "Sem"
        for month in months:
            sheet.merge_cells(start_row=1, start_column=col, end_row=1, end_column=col+3)
            for i, period in enumerate(["J", "M", "AM", "S"]):
                sheet.cell(row=2, column=col+i, value=period)
            col += 4  # Move to the next group of columns for the next month
        
        # Fill in the days and data
        current_date = planning.start_date
        while current_date <= planning.end_date:
            row = current_date.day
            month_col = (current_date.year - planning.start_date.year) * 12 + current_date.month - planning.start_date.month
            col = 3 + month_col * 4

            # Fill day number
            sheet.cell(row=row+2, column=1, value=current_date.day)

            # Fill weekday
            weekday = current_date.strftime("%a")[:2]
            sheet.cell(row=row+2, column=col, value=weekday)

            # Fill slots
            day_planning = next((d for d in planning.days if d.date == current_date), None)
            m, am, s = self.get_cell_values(day_planning, person)
            sheet.cell(row=row+2, column=col+1, value=m)
            sheet.cell(row=row+2, column=col+2, value=am)
            sheet.cell(row=row+2, column=col+3, value=s)

            # Apply styles and colors
            for i in range(4):
                cell = sheet.cell(row=row+2, column=col+i)
                cell.border = thin_border
                cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)

                is_weekend = current_date.weekday() >= 5
                is_holiday_or_bridge = cal.is_holiday(current_date) or self.is_bridge_day(current_date)
                period = ["J", "M", "AM", "S"][i]
                has_desiderata = self.has_desiderata(person, current_date, period)

                if is_weekend or is_holiday_or_bridge:
                    if has_desiderata:
                        cell.fill = weekend_desiderata_color
                    else:
                        cell.fill = weekend_color
                elif has_desiderata:
                    cell.fill = desiderata_color

            current_date += timedelta(days=1)

        # Set column widths for all J, M, AM, S columns (except "Sem")
        for col in range(3, sheet.max_column + 1):
            sheet.column_dimensions[get_column_letter(col)].width = 6

        # Apply styles to the headers
        for cell in sheet[1] + sheet[2]:
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
            cell.border = thin_border

    def is_bridge_day(self, date):
        # 1) Lundi avant un mardi férié
        if date.weekday() == 0 and self.cal.is_holiday(date + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if date.weekday() in [4, 5] and self.cal.is_holiday(date - timedelta(days=1 if date.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if date.weekday() == 5 and self.cal.is_holiday(date - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= date.weekday() <= 4:  # Jours de semaine (lundi à vendredi)
            if (self.cal.is_holiday(date - timedelta(days=1)) and 
                self.cal.is_holiday(date + timedelta(days=1))):
                return True
        
        return False
            
    def get_cell_values(self, day_planning, person):
        if not day_planning:
            return "", "", ""
        slots = [slot for slot in day_planning.slots if slot.assignee == person.name]
        periods = {"M": [], "AM": [], "S": []}
        for slot in slots:
            period = self.get_post_period(slot.abbreviation)
            periods[period].append(slot.abbreviation)
        return " ".join(periods["M"]), " ".join(periods["AM"]), " ".join(periods["S"])

    def get_post_period(self, post):
        if post in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return "M"
        elif post in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return "AM"
        else:
            return "S"

    def has_desiderata(self, person, date, period):
        for des in person.desiderata:
            if des.start_date <= date <= des.end_date:
                if (period == "M" and des.period == 1) or \
                (period == "AM" and des.period == 2) or \
                (period == "S" and des.period == 3):
                    return True
        return False

    def get_month_names(self, start_date, end_date):
        months = []
        current_date = start_date.replace(day=1)
        while current_date <= end_date:
            months.append(current_date.strftime("%b"))
            current_date = (current_date.replace(day=1) + timedelta(days=32)).replace(day=1)
        return months

# gui/planning_comparison_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_comparison_view.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox, QPushButton, QHeaderView, QMessageBox,
                             QTableWidget, QTableWidgetItem, QDialog, QLabel, QScrollArea, QTextEdit)
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QColor, QBrush, QFont, QTextCharFormat
from datetime import date, timedelta
from core.utils import get_post_period
from core.Constantes.models import TimeSlot


# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class PlanningComparisonView(QWidget):
    def __init__(self, planning, doctors, cats, main_window):
        super().__init__()
        self.planning = planning
        self.main_window = main_window
        self.doctors = sorted(doctors, key=lambda d: d.name)
        self.cats = sorted(cats, key=lambda c: c.name)
        self.exchange_history = []
        self.post_balance = {}
        self.init_ui()
        self.synchronize_scrollbars()
        
        self.selector1.currentIndexChanged.connect(self.on_selector_changed)
        self.selector2.currentIndexChanged.connect(self.on_selector_changed)

        self.post_groups = {
            "VmS": ["ML"],
            "VmD": ["ML", "MC"],
            "VaSD": ["AL", "AC"],
            "CmS": ["CM", "HM","MM"],
            "CmD": ["CM", "HM", "SM", "RM"],
            "CaSD": ["CA", "HA", "RA", "SA"],
            "CsSD": ["CS", "HS", "RS", "SS"],
            "NLw": ["NL"],
            "NAMw": ["NM", "NA"]
        }
        
    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteurs
        controls_layout = QHBoxLayout()
        self.selector1 = QComboBox()
        self.selector2 = QComboBox()
        self.info_label1 = QLabel("")  # Label pour afficher les informations sous le premier menu
        self.info_label2 = QLabel("")  # Label pour afficher les informations sous le deuxième menu
        self.update_selectors()
        controls_layout.addWidget(self.selector1)
        controls_layout.addWidget(self.info_label1)
        controls_layout.addWidget(self.selector2)
        controls_layout.addWidget(self.info_label2)
        layout.addLayout(controls_layout)

        
        # Tableaux de planning
        tables_layout = QHBoxLayout()
        tables_layout.setSpacing(10)  # Réduire l'espace entre les tableaux

         # Scroll areas pour les tables
        scroll_area1 = QScrollArea()
        scroll_area2 = QScrollArea()
        scroll_area1.setWidgetResizable(True)
        scroll_area2.setWidgetResizable(True)

        self.table1 = FullPlanningTable(self)
        self.table2 = FullPlanningTable(self)
        scroll_area1.setWidget(self.table1)
        scroll_area2.setWidget(self.table2)

        tables_layout.addWidget(scroll_area1)
        tables_layout.addWidget(scroll_area2)
        
        layout.addLayout(tables_layout, 1)  # Donner plus d'importance aux tableaux

        # Initialiser l'affichage
        self.update_comparison()
        
        # Ajouter les nouveaux champs en bas avec une hauteur réduite
        bottom_layout = QHBoxLayout()
        bottom_layout.setContentsMargins(0, 0, 0, 0)  # Réduire les marges

         # Champs d'historique et de bilan
        bottom_layout = QHBoxLayout()
        bottom_layout.setContentsMargins(0, 5, 0, 0)  # Réduire les marges

        # Historique des échanges
        exchange_history_layout = QVBoxLayout()
        exchange_history_layout.setSpacing(2)
        exchange_history_label = QLabel("Historique des échanges")
        exchange_history_label.setStyleSheet("font-weight: bold; margin-bottom: 2px;")
        exchange_history_layout.addWidget(exchange_history_label)
        self.exchange_history_widget = QTextEdit()
        self.exchange_history_widget.setReadOnly(True)
        self.exchange_history_widget.setMinimumHeight(100) 
        self.exchange_history_widget.setMaximumHeight(150)
        exchange_history_layout.addWidget(self.exchange_history_widget)
        bottom_layout.addLayout(exchange_history_layout)

        # Bilan des postes
        post_balance_layout = QVBoxLayout()
        post_balance_layout.setSpacing(2)
        post_balance_label = QLabel("Bilan des postes")
        post_balance_label.setStyleSheet("font-weight: bold; margin-bottom: 2px;")
        post_balance_layout.addWidget(post_balance_label)
        self.post_balance_widget = QTextEdit()
        self.post_balance_widget.setReadOnly(True)
        self.post_balance_widget.setMinimumHeight(100)  # Augmenter un peu la hauteur pour accommoder plus de contenu
        self.post_balance_widget.setMaximumHeight(150)  # Limiter la hauteur maximale
        post_balance_layout.addWidget(self.post_balance_widget)
        bottom_layout.addLayout(post_balance_layout)

        layout.addLayout(bottom_layout)

        self.setLayout(layout)

    def get_doctor_parts(self, doctor_name):
        """
        Méthode pour récupérer dynamiquement le nombre de parts d'un médecin.
        Doit être adaptée en fonction de l'endroit où cette information est stockée.
        """
        doctor = next((d for d in self.doctors if d.name == doctor_name), None)
        if doctor:
            # Vérifier si le médecin a un attribut ou une méthode pour obtenir le nombre de parts
            return getattr(doctor, 'half_parts', 1)  # Utilise 'half_parts' ou une valeur par défaut de 1
        return None

    def update_selectors(self, preserve_selection=False, allow_new_selection=False):
        current1 = self.selector1.currentText() if preserve_selection else None
        current2 = self.selector2.currentText() if preserve_selection else None

        self.selector1.blockSignals(True)
        self.selector2.blockSignals(True)

        self.selector1.clear()
        self.selector2.clear()

        options = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        self.selector1.addItems(options)
        self.selector2.addItems(options)

        if preserve_selection:
            self.selector1.setCurrentText(current1)
            self.selector2.setCurrentText(current2)

        self.selector1.blockSignals(False)
        self.selector2.blockSignals(False)

        if allow_new_selection:
            # Reconnectez les signaux pour permettre de nouvelles sélections
            self.selector1.currentIndexChanged.connect(self.on_selector_changed)
            self.selector2.currentIndexChanged.connect(self.on_selector_changed)

        # Mettre à jour les labels d'information
        self.update_info_label1()
        self.update_info_label2()
                
        # Colorer les CAT
        for i in range(self.selector1.count()):
            if i > len(self.doctors):
                self.selector1.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)
                self.selector2.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)

        # Conserver le focus sur le sélecteur pour parcourir avec les flèches
        self.selector1.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.selector2.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    def on_selector_changed(self):
        sender = self.sender()
        if sender == self.selector1:
            self.current_selection1 = sender.currentText()
            self.table1.populate_table(self.current_selection1)
        elif sender == self.selector2:
            self.current_selection2 = sender.currentText()
            self.table2.populate_table(self.current_selection2)
        
        self.update_info_label1()
        self.update_info_label2()


    def update_info_label1(self):
        selected = self.selector1.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label1.setText("Médecin à plein temps")
            else:
                self.info_label1.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label1.setText("CAT")
        else:
            self.info_label1.setText("")

    def update_info_label2(self):
        selected = self.selector2.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label2.setText("Médecin à plein temps")
            else:
                self.info_label2.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label2.setText("CAT")
        else:
            self.info_label2.setText("")

    def update_comparison(self, preserve_selection=False):
        if preserve_selection and hasattr(self, 'current_selection1') and hasattr(self, 'current_selection2'):
            selected1 = self.current_selection1
            selected2 = self.current_selection2
        else:
            selected1 = self.selector1.currentText()
            selected2 = self.selector2.currentText()
        
        self.table1.populate_table(selected1)
        self.table2.populate_table(selected2)
        
        self.update_info_label1()
        self.update_info_label2()
        
        if preserve_selection:
            self.selector1.setCurrentText(selected1)
            self.selector2.setCurrentText(selected2)
    
    def reset_selectors(self):
        self.selector1.setCurrentIndex(0)
        self.selector2.setCurrentIndex(0)
        self.update_comparison()

    def save_current_selections(self):
        self.current_selection1 = self.selector1.currentText()
        self.current_selection2 = self.selector2.currentText()

    def on_assignment_changed(self, old_assignee, new_assignee, post_type):
        self.save_current_selections()
        self.main_window.planning_tab.update_table()
        self.main_window.update_stats_view()
        self.main_window.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
        
        # Mettre à jour les sélecteurs en permettant de nouvelles sélections
        self.update_selectors(preserve_selection=True, allow_new_selection=True)
        
        # Mettre à jour les tables
        self.table1.populate_table(self.current_selection1)
        self.table2.populate_table(self.current_selection2)
        
        # Mettre à jour les informations
        self.update_info_label1()
        self.update_info_label2()
        
         # Mettre à jour l'historique des échanges
        self.update_exchange_history(old_assignee, new_assignee, post_type)
      

        # Mettre à jour les excédents/déficits de postes
        self.update_post_balance(old_assignee, new_assignee, post_type)
        
    def synchronize_scrollbars(self):
        """
        Synchronise les barres de défilement des deux tables pour un défilement horizontal et vertical simultané.
        """
        # Synchronisation du défilement vertical
        self.table1.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table2)
        self.table2.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table1)

        # Synchronisation du défilement horizontal
        self.table1.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table2)
        self.table2.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table1)

        self.is_syncing_vertical = False
        self.is_syncing_horizontal = False

    def sync_scroll_vertical_table2(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table2.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_vertical_table1(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table1.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_horizontal_table2(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table2.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False

    def sync_scroll_horizontal_table1(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table1.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False

    def update_exchange_history(self, old_assignee, new_assignee, post_type):
        exchange = f"{old_assignee} donne {post_type} à {new_assignee}"
        self.exchange_history.append(exchange)

        cursor = self.exchange_history_widget.textCursor()
        format = QTextCharFormat()
        format.setForeground(QBrush(QColor(0, 0, 0)))  # Noir pour tous les échanges
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertText(exchange + "\n", format)

       
 

    def update_post_balance(self, old_assignee, new_assignee, post_type):
        if old_assignee not in self.post_balance:
            self.post_balance[old_assignee] = {"posts": {}, "groups": {}}
        if new_assignee not in self.post_balance:
            self.post_balance[new_assignee] = {"posts": {}, "groups": {}}

        # Mise à jour des postes individuels
        self.post_balance[old_assignee]["posts"][post_type] = self.post_balance[old_assignee]["posts"].get(post_type, 0) - 1
        self.post_balance[new_assignee]["posts"][post_type] = self.post_balance[new_assignee]["posts"].get(post_type, 0) + 1

        # Mise à jour des groupes de postes
        for group, posts in self.post_groups.items():
            if post_type in posts:
                self.post_balance[old_assignee]["groups"][group] = self.post_balance[old_assignee]["groups"].get(group, 0) - 1
                self.post_balance[new_assignee]["groups"][group] = self.post_balance[new_assignee]["groups"].get(group, 0) + 1

        self.post_balance_widget.clear()
        for assignee, balance in self.post_balance.items():
            non_zero_posts = {post: count for post, count in balance["posts"].items() if count != 0}
            non_zero_groups = {group: count for group, count in balance["groups"].items() if count != 0}
            
            if non_zero_posts or non_zero_groups:
                post_text = ", ".join([f"{count:+d}{post}" for post, count in non_zero_posts.items()])
                group_text = ", ".join([f"{count:+d}{group}" for group, count in non_zero_groups.items()])
                
                self.post_balance_widget.append(f"{assignee}:")
                self.post_balance_widget.append(f"  Postes: {post_text}")
                self.post_balance_widget.append(f"  Groupes: {group_text}")
                self.post_balance_widget.append("")  # Ligne vide pour séparer les entrées
                
    def reset_view(self):
        self.exchange_history = []
        self.post_balance = {}
        self.exchange_history_widget.clear()
        self.post_balance_widget.clear()
        self.table1.clear()
        self.table2.clear()
        self.table1.setRowCount(0)
        self.table1.setColumnCount(0)
        self.table2.setRowCount(0)
        self.table2.setColumnCount(0)
        self.selector1.setCurrentIndex(0)
        self.selector2.setCurrentIndex(0)

class FullPlanningTable(QTableWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.verticalHeader().setVisible(False)
        
        self.itemClicked.connect(self.on_item_clicked)
        self.cellDoubleClicked.connect(self.on_item_double_clicked)

    def populate_table(self, selected):
        if not self.parent.planning or not self.parent.planning.days:
            return

        self.clear()

        start_date = self.parent.planning.start_date
        end_date = self.parent.planning.end_date
        
        total_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

        self.setRowCount(31)
        self.setColumnCount(total_months * 4 + 1)

        headers = ["Jour"]
        current_date = start_date.replace(day=1)
        for _ in range(total_months):
            month_name = current_date.strftime("%b")
            headers.extend([f"{month_name}\nJ", f"{month_name}\nM", f"{month_name}\nAM", f"{month_name}\nS"])
            current_date = (current_date.replace(day=28) + timedelta(days=4)).replace(day=1)
        self.setHorizontalHeaderLabels(headers)

        current_date = start_date
        while current_date <= end_date:
            day_row = current_date.day - 1
            month_col = (current_date.year - start_date.year) * 12 + current_date.month - start_date.month
            col_offset = month_col * 4 + 1

            day_item = QTableWidgetItem(str(current_date.day))
            day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.setItem(day_row, 0, day_item)
            
            weekday_item = QTableWidgetItem(self.get_weekday_abbr(current_date.weekday()))
            weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            weekday_item.setForeground(QBrush(WEEKDAY_TEXT_COLOR))
            font = QFont()
            font.setPointSize(8)
            weekday_item.setFont(font)
            self.setItem(day_row, col_offset, weekday_item)

            day_planning = next((day for day in self.parent.planning.days if day.date == current_date), None)
            if day_planning:
                is_weekend_or_holiday = day_planning.is_weekend or day_planning.is_holiday_or_bridge
                background_color = WEEKEND_COLOR if is_weekend_or_holiday else WEEKDAY_COLOR

                posts = [slot for slot in day_planning.slots if (selected == "Non attribué" and slot.assignee is None) or slot.assignee == selected]
                
                morning_posts = [p for p in posts if get_post_period(p) == 0]
                afternoon_posts = [p for p in posts if get_post_period(p) == 1]
                evening_posts = [p for p in posts if get_post_period(p) == 2]

                for i, post_list in enumerate([morning_posts, afternoon_posts, evening_posts]):
                    posts_text = ", ".join([p.abbreviation for p in post_list])
                    if selected == "Non attribué":
                        unassigned_posts = [slot.abbreviation for slot in day_planning.slots 
                                            if slot.assignee is None and self.get_post_period(slot.abbreviation) == i]
                        posts_text = ", ".join(unassigned_posts)
                    
                    item = QTableWidgetItem(posts_text)
                    item.setData(Qt.ItemDataRole.UserRole, day_planning)
                    
                    # Appliquer la couleur de fond de base
                    item.setBackground(QBrush(background_color))
                    
                    # Vérifier les désidératas
                    selected_person = next((p for p in self.parent.doctors + self.parent.cats if p.name == selected), None)
                    if selected_person:
                        for desiderata in selected_person.desiderata:
                            if desiderata.start_date <= current_date <= desiderata.end_date:
                                if desiderata.period == i + 1:
                                    desiderata_color = WEEKEND_DESIDERATA_COLOR if is_weekend_or_holiday else DESIDERATA_COLOR
                                    item.setBackground(QBrush(desiderata_color))
                    
                    self.setItem(day_row, col_offset + i + 1, item)

            current_date += timedelta(days=1)

        # Ajuster la taille des cellules
        for row in range(self.rowCount()):
            self.setRowHeight(row, 20)

        for col in range(self.columnCount()):
            if col == 0:
                self.setColumnWidth(col, 30)
            elif (col - 1) % 4 == 0:
                self.setColumnWidth(col, 30)
            else:
                self.setColumnWidth(col, 40)

        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                
    def toggle_cell(self, item):
        current_color = item.background().color()
        is_weekend_or_holiday = current_color == WEEKEND_COLOR
        
        if current_color == WEEKEND_COLOR:
            new_color = WEEKEND_DESIDERATA_COLOR
        elif current_color == WEEKEND_DESIDERATA_COLOR:
            new_color = WEEKEND_COLOR
        elif current_color == WEEKDAY_COLOR:
            new_color = DESIDERATA_COLOR
        else:
            new_color = WEEKDAY_COLOR
        
        item.setBackground(QBrush(new_color))

    def get_weekday_abbr(self, weekday):
        return ["L", "M", "M", "J", "V", "S", "D"][weekday]


    def get_post_period(self, post):
        if post in ["ML","MC","MM", "CM", "HM", "SM", "RM"]:
            return 0  # Matin
        elif post in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1  # Après-midi
        else:
            return 2  # Soir


    def on_item_clicked(self, item):
        if item.column() > 1:  # Ignorer les colonnes Jour et Sem
            row = item.row()
            column = item.column()

            if self == self.parent.table1:
                other_table = self.parent.table2
            else:
                other_table = self.parent.table1
            
            other_table.setCurrentCell(row, column)

    def on_item_double_clicked(self, row, column):
        if column > 1 and (column - 1) % 4 != 0:
            item = self.item(row, column)
            if item and item.data(Qt.ItemDataRole.UserRole):
                day = item.data(Qt.ItemDataRole.UserRole)
                
                if self == self.parent.table1:
                    current_assignee = self.parent.selector1.currentText()
                    compared_assignee = self.parent.selector2.currentText()
                else:
                    current_assignee = self.parent.selector2.currentText()
                    compared_assignee = self.parent.selector1.currentText()

                # Vérifier si un échange est possible
                if current_assignee == compared_assignee:
                    QMessageBox.warning(self, "Échange impossible", "Impossible d'échanger avec le même assigné.")
                    return

                period = ((column - 1) % 4) - 1
                period_names = ["Matin", "Après-midi", "Soir"]
                period_name = period_names[period]

                if current_assignee == "Non attribué":
                    available_posts = [slot.abbreviation for slot in day.slots 
                                    if slot.assignee is None and self.get_post_period(slot.abbreviation) == period]
                else:
                    available_posts = [slot.abbreviation for slot in day.slots 
                                    if slot.assignee == current_assignee and self.get_post_period(slot.abbreviation) == period]

                if not available_posts:
                    QMessageBox.warning(self, "Échange impossible", "Aucun poste disponible pour l'échange.")
                    return

                dialog = PostAssignmentDialog(day, current_assignee, self.parent.doctors, self.parent.cats, compared_assignee, available_posts, period_name)
                if dialog.exec() == QDialog.DialogCode.Accepted:
                    new_assignee = dialog.get_selected_assignee()
                    selected_post = dialog.get_selected_post()
                    self.update_assignment(day, current_assignee, new_assignee, selected_post)

    def update_assignment(self, day, current_assignee, new_assignee, selected_post):
        if current_assignee == new_assignee:
            return  # Pas de changement nécessaire

        changes_made = False
        for slot in day.slots:
            if slot.abbreviation == selected_post:
                if current_assignee == "Non attribué" and slot.assignee is None:
                    slot.assignee = new_assignee
                    changes_made = True
                elif current_assignee != "Non attribué" and slot.assignee == current_assignee:
                    slot.assignee = None if new_assignee == "Non attribué" else new_assignee
                    changes_made = True
        if changes_made:
            self.parent.on_assignment_changed(current_assignee, new_assignee, selected_post)

class PostAssignmentDialog(QDialog):
    def __init__(self, day, current_assignee, doctors, cats, compared_assignee, available_posts, period_name):
        super().__init__()
        self.day = day
        self.current_assignee = current_assignee
        self.doctors = doctors
        self.cats = cats
        self.compared_assignee = compared_assignee
        self.available_posts = available_posts
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Affichage du nom de l'assigné par défaut (comparé)
        layout.addWidget(QLabel(f"Nouvel assigné pour le {self.day.date}:"))
        
        # Sélecteur pour l'assigné (docteurs et CAT)
        self.assignee_selector = QComboBox()
        options = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        options = [option for option in options if option != self.current_assignee]  # Exclure l'assigné actuel
        self.assignee_selector.addItems(options)
        
        # Définir l'assigné par défaut comme celui comparé, sauf s'il est identique à l'actuel
        if self.compared_assignee != self.current_assignee:
            self.assignee_selector.setCurrentText(self.compared_assignee)

        # Sélecteur pour les postes disponibles (seulement les postes présents dans la case)
        layout.addWidget(QLabel("Choisir les postes à échanger :"))
        self.post_selector = QComboBox()
        self.post_selector.addItems(self.available_posts)
        layout.addWidget(self.post_selector)

        # Boutons d'action
        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addLayout(buttons)

        
        
        layout.addWidget(self.assignee_selector)

    def get_selected_assignee(self):
        return self.assignee_selector.currentText()

    def get_selected_post(self):
        return self.post_selector.currentText()

    

# gui/__init__.py

# © 2024 HILAL Arkane. Tous droits réservés.


# gui/splash_screen.py

# gui/splash_screen.py

from PyQt6.QtWidgets import QSplashScreen
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from core.utils import resource_path

class SplashScreen(QSplashScreen):
    def __init__(self):
        super().__init__()
        pixmap = QPixmap(resource_path("icons/logo_SOSplanning.png"))
        
        # Réduire la taille de l'image à un tiers de sa taille originale
        scaled_size = pixmap.size() / 3
        scaled_pixmap = pixmap.scaled(scaled_size, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        
        self.setPixmap(scaled_pixmap)
        self.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.FramelessWindowHint)

    def update_message(self, message):
        self.showMessage(message, Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, Qt.GlobalColor.black)

# gui/personnel_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/personnel_management.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                             QFormLayout, QLineEdit, QSpinBox, QMessageBox, QSizePolicy,
                             QLabel, QFrame, QTableWidget, QTableWidgetItem, QDialog, QGridLayout)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont, QColor, QIcon
from core.Constantes.models import Doctor, CAT, ALL_POST_TYPES, Desiderata
from core.Constantes.data_persistence import DataPersistence
from .post_configuration import PostConfigurationWidget
from .styles import EDIT_DELETE_BUTTON_STYLE


class PersonnelManagementWidget(QWidget):
    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.data_persistence = DataPersistence()
        self.init_ui()
        
    

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        tab_widget = QTabWidget()
        
        # Onglet des médecins
        doctors_tab = QWidget()
        doctors_layout = QVBoxLayout(doctors_tab)

        grid_container = QWidget()
        grid_container.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        self.doctors_grid = QGridLayout(grid_container)
        self.doctors_grid.setSpacing(0)
        self.doctors_grid.setContentsMargins(1, 1, 1, 1)

        doctors_layout.addWidget(grid_container)

        add_doctor_button = QPushButton("Ajouter un médecin")
        add_doctor_button.clicked.connect(lambda: self.add_personnel("Médecin"))
        add_doctor_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        doctors_layout.addWidget(add_doctor_button)

        tab_widget.addTab(doctors_tab, "Médecins")

        # Onglet des CAT
        cats_tab = QWidget()
        cats_layout = QVBoxLayout(cats_tab)
        
        self.cats_grid = QWidget()
        self.cats_grid.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        cats_layout.addWidget(self.cats_grid)
        
        add_cat_button = QPushButton("Ajouter un CAT")
        add_cat_button.clicked.connect(lambda: self.add_personnel("CAT"))
        add_cat_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        cats_layout.addWidget(add_cat_button)
        
        tab_widget.addTab(cats_tab, "CAT")

        # Nouvel onglet pour la configuration des postes
        self.post_config_tab = PostConfigurationWidget(self.post_configuration, self.main_window)
        tab_widget.addTab(self.post_config_tab, "Configuration des postes")

        layout.addWidget(tab_widget)
        self.update_tables()

    def update_tables(self):
        self.update_doctors_table()
        self.update_cats_table()

    def update_doctors_table(self):
        for i in reversed(range(self.doctors_grid.count())): 
            self.doctors_grid.itemAt(i).widget().setParent(None)

        sorted_doctors = sorted(self.doctors, key=lambda x: x.name.lower())

        for index, doctor in enumerate(sorted_doctors):
            row = index // 2
            col = index % 2 * 4

            doctor_frame = QFrame()
            doctor_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                }
            """)
            doctor_layout = QHBoxLayout(doctor_frame)
            doctor_layout.setContentsMargins(5, 5, 5, 5)
            doctor_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            doctor_layout.addWidget(number_label)

            name_label = QLabel(doctor.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            doctor_layout.addWidget(name_label)

            half_parts_label = QLabel(f"Demi-parts: {doctor.half_parts}")
            doctor_layout.addWidget(half_parts_label)

            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier")
            edit_button.clicked.connect(lambda _, p=doctor: self.edit_personnel(p))
            edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer")
            delete_button.clicked.connect(lambda _, p=doctor: self.delete_personnel(p))

            delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 3px 8px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 1px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                doctor_layout.addWidget(button)

            if doctor.half_parts == 1:
                doctor_frame.setStyleSheet("""
                    QFrame {
                        border: 1px solid #ddd;
                        background-color: #FFFFD0;
                    }
                """)

            self.doctors_grid.addWidget(doctor_frame, row, col, 1, 4)

        for i in range(8):
            self.doctors_grid.setColumnStretch(i, 1)
            
    def update_cats_table(self):
        if self.cats_grid.layout():
            QWidget().setLayout(self.cats_grid.layout())

        cats_layout = QVBoxLayout(self.cats_grid)
        cats_layout.setSpacing(0)
        cats_layout.setContentsMargins(0, 0, 0, 0)

        sorted_cats = sorted(self.cats, key=lambda x: x.name.lower())

        for index, cat in enumerate(sorted_cats):
            cat_frame = QFrame()
            cat_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                    padding: 2px;
                }
            """)
            cat_layout = QHBoxLayout(cat_frame)
            cat_layout.setContentsMargins(5, 5, 5, 5)
            cat_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            number_label.setFixedWidth(20)
            cat_layout.addWidget(number_label)

            name_label = QLabel(cat.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            cat_layout.addWidget(name_label)

            cat_layout.addStretch(1)

            edit_button = QPushButton("Modifier")
            edit_button.clicked.connect(lambda _, c=cat: self.edit_personnel(c))
            delete_button = QPushButton("Supprimer")
            delete_button.clicked.connect(lambda _, c=cat: self.delete_personnel(c))
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 2px 5px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 0px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                button.setFixedSize(70, 25)
                cat_layout.addWidget(button)

            cats_layout.addWidget(cat_frame)

        cats_layout.addStretch(1)

    def add_personnel(self, personnel_type):
        if personnel_type == "Médecin":
            dialog = PersonnelDialog(self, personnel_type=personnel_type)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                self.doctors.append(Doctor(name, half_parts))
        else:  # CAT
            dialog = CATDialog(self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()
                new_cat = CAT(name)
                self.cats.append(new_cat)
        self.update_tables()
        self.save_data()

    def delete_personnel(self, person):
        print(f"Tentative de suppression de : {person.name}")
        confirm = QMessageBox.question(self, "Confirmer la suppression", 
                                    f"Êtes-vous sûr de vouloir supprimer {person.name} ?",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            print("Confirmation de suppression.")
            if isinstance(person, Doctor):
                self.doctors.remove(person)
            else:
                self.cats.remove(person)
            self.update_tables()
            self.save_data()

    def edit_personnel(self, person):
        print(f"Tentative de modification de : {person.name}")
        if isinstance(person, Doctor):
            dialog = PersonnelDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                person.name = name
                person.half_parts = half_parts
                print(f"Médecin modifié : {person.name}, demi-parts : {person.half_parts}")
        else:  # CAT
            dialog = CATDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()
                person.name = name
                print(f"CAT modifié : {person.name}")
        self.update_tables()
        self.save_data()


    def save_data(self):
        print("Sauvegarde des données...")
        if hasattr(self, 'data_persistence'):
            self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        else:
            print("Attention : Aucun mécanisme de persistance des données n'est configuré.")

class PersonnelDialog(QDialog):
    def __init__(self, parent=None, person=None, personnel_type=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier personnel")
        self.person = person
        self.personnel_type = personnel_type if person is None else ("Médecin" if isinstance(person, Doctor) else "CAT")
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        if self.personnel_type == "Médecin":
            self.half_parts_input = QSpinBox()
            self.half_parts_input.setRange(1, 2)
            layout.addRow("Demi-parts:", self.half_parts_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.person:
            self.name_input.setText(self.person.name)
            if isinstance(self.person, Doctor):
                self.half_parts_input.setValue(self.person.half_parts)

    def get_personnel_info(self):
        half_parts = self.half_parts_input.value() if self.personnel_type == "Médecin" else 0
        return self.name_input.text(), self.personnel_type, half_parts
    

    
class CATDialog(QDialog):
    def __init__(self, parent=None, cat=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier CAT")
        self.cat = cat
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.cat:
            self.name_input.setText(self.cat.name)

    def get_cat_info(self):
        return self.name_input.text()




# gui/planning_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_view.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QLabel,
                             QTableWidget, QTableWidgetItem, QDateEdit, QMessageBox, QProgressBar)
from PyQt6.QtCore import Qt, QDate, QThread, pyqtSignal
from PyQt6.QtGui import QColor, QBrush, QFont
from core.Generator.planning_generator import PlanningGenerator
from core.Constantes.models import ALL_POST_TYPES, WEEKDAY_COMBINATIONS, WEEKEND_COMBINATIONS
from datetime import date, timedelta
from .doctor_planning_view import DoctorPlanningView
from PyQt6.QtCore import pyqtSignal
from PyQt6.QtCore import pyqtSignal


# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class PlanningGenerationThread(QThread):
    progress_update = pyqtSignal(int)
    planning_generated = pyqtSignal(object)

    def __init__(self, planning_generator, start_date, end_date, existing_planning=None):
        super().__init__()
        self.planning_generator = planning_generator
        self.start_date = start_date
        self.end_date = end_date
        self.existing_planning = existing_planning

    def run(self):
        if self.existing_planning:
            planning = self.planning_generator.generate_planning(self.start_date, self.end_date)
        else:
            planning = self.planning_generator.generate_planning(self.start_date, self.end_date)
        self.planning_generated.emit(planning)

class PlanningViewWidget(QWidget):
    dates_changed = pyqtSignal(date, date)

    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        self.planning = None
        self.weekend_validated = False
        self.init_ui()
        self.weekend_color = QColor(255, 200, 200)


    def init_ui(self):
        layout = QVBoxLayout(self)

        # Contrôles de date et bouton de génération
        date_layout = QHBoxLayout()
        
        self.start_date = QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setCalendarPopup(True)

        # Définir les dates par défaut
        today = date.today()
        end_date = today + timedelta(days=4*30)  # Environ 4 mois plus tard
        self.start_date.setDate(QDate(today.year, today.month, today.day))
        self.end_date.setDate(QDate(end_date.year, end_date.month, end_date.day))

        date_layout.addWidget(QLabel("Du:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("Au:"))
        date_layout.addWidget(self.end_date)
        
        # Bouton de génération
        generate_button = QPushButton("Générer le planning")
        generate_button.clicked.connect(self.generate_planning)
        generate_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #e8e8e8;
            }
        """)
        self.generate_button = QPushButton("Générer le planning")
        self.generate_button.clicked.connect(self.generate_planning)
        date_layout.addWidget(self.generate_button)
        self.validate_weekends_button = QPushButton("Valider les weekends")
        self.validate_weekends_button.clicked.connect(self.validate_weekends)
        self.validate_weekends_button.setEnabled(False)  # Désactivé par défaut
        date_layout.addWidget(self.validate_weekends_button)

        date_layout.setStretchFactor(self.start_date, 2)
        date_layout.setStretchFactor(self.end_date, 2)
        date_layout.setStretchFactor(generate_button, 1)
        
        layout.addLayout(date_layout)

        # Ajout du nouveau bouton de réinitialisation
        self.reset_planning_button = QPushButton("Réinitialiser le planning")
        self.reset_planning_button.clicked.connect(self.reset_planning)
        self.reset_planning_button.setEnabled(True)  # Activez le bouton
        date_layout.addWidget(self.reset_planning_button)

        # Barre de progression
        self.progress_bar = QProgressBar(self)
        layout.addWidget(self.progress_bar)

        # Créer un widget avec des onglets
        tab_widget = QTabWidget()
        
        # Vue globale du planning
        self.global_view = QTableWidget(self)
        tab_widget.addTab(self.global_view, "Vue globale")

        # Nouvelle vue du planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        tab_widget.addTab(self.doctor_planning_view, "Planning par médecin")

        layout.addWidget(tab_widget)
        
        self.start_date.dateChanged.connect(self.on_date_changed)
        self.end_date.dateChanged.connect(self.on_date_changed)

    def update_dates(self, start_date, end_date):
        self.start_date.setDate(QDate(start_date))
        self.end_date.setDate(QDate(end_date))
        self.on_date_changed()  # Ceci émettra le signal dates_changed
        
    def on_date_changed(self):
        start_date = self.start_date.date().toPyDate()
        end_date = self.end_date.date().toPyDate()
        self.dates_changed.emit(start_date, end_date)

    def generate_planning(self, existing_planning=None):
        start_date = self.start_date.date().toPyDate()
        end_date = self.end_date.date().toPyDate()

        if start_date > end_date:
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return

        self.progress_bar.setValue(0)
        self.generation_thread = PlanningGenerationThread(self.planning_generator, start_date, end_date, existing_planning)
        self.generation_thread.progress_update.connect(self.progress_bar.setValue)
        self.generation_thread.planning_generated.connect(self.planning_generated)
        self.generation_thread.start()


    def planning_generated(self, planning):
        if planning is None:
            QMessageBox.warning(self, "Erreur", "Impossible de générer le planning. Veuillez vérifier les desideratas des médecins.")
            self.progress_bar.setValue(0)
        else:
            self.planning = planning
            self.update_table()
            self.doctor_planning_view.update_view(planning, self.doctors, self.cats)
            self.progress_bar.setValue(100)
            self.validate_weekends_button.setEnabled(True)  # Activer le bouton après la génération
            self.main_window.update_data()
            
            # Afficher les desideratas non respectés
            # unrespected_desiderata = self.planning_generator.get_unrespected_desiderata()
            
    def validate_weekends(self):
        if self.planning:
            self.weekend_validated = True
            self.generate_button.setText("Générer planning semaine")
            self.generate_button.clicked.disconnect()
            self.generate_button.clicked.connect(self.generate_weekday_planning)
            self.validate_weekends_button.setEnabled(False)
            QMessageBox.information(self, "Validation", "Les weekends ont été validés. Vous pouvez maintenant générer le planning de la semaine.")
        else:
            QMessageBox.warning(self, "Erreur", "Aucun planning n'a été généré. Veuillez d'abord générer un planning.")

    def generate_weekday_planning(self):
        if self.weekend_validated:
            # Appeler la méthode pour générer le planning de la semaine
            self.planning = self.planning_generator.generate_weekday_planning(self.planning)
            self.update_table()
            self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
            self.main_window.update_data()
            QMessageBox.information(self, "Génération terminée", "Le planning de la semaine a été généré avec succès.")
        else:
            QMessageBox.warning(self, "Erreur", "Veuillez d'abord valider les weekends avant de générer le planning de la semaine.")
            
    def display_constraint_analysis(self):
            if hasattr(self.planning_generator, 'pre_analyzer'):
                analysis = self.planning_generator.pre_analyzer.analyze()
                if analysis is not None and 'constraint_analysis' in analysis:
                    constraint_analysis = analysis['constraint_analysis']
                    
                    message = f"Analyse des contraintes :\n"
                    message += f"Conflits potentiels : {constraint_analysis.get('potential_conflicts', 'N/A')}\n"
                    # Ajoutez d'autres informations sur les contraintes ici
                    
                    QMessageBox.information(self, "Analyse des contraintes", message)
                else:
                    QMessageBox.warning(self, "Erreur", "L'analyse des contraintes n'est pas disponible.")
            else:
                QMessageBox.warning(self, "Erreur", "L'analyseur de pré-planning n'est pas disponible.")
                
    def update_table(self):
        if not self.planning:
            return

        self.global_view.clear()
        self.global_view.setRowCount(0)
        self.global_view.setColumnCount(5)
        self.global_view.setHorizontalHeaderLabels(["Date", "Créneau", "Type", "Site", "Assigné à"])

        for day_planning in self.planning.days:
            for slot in day_planning.slots:
                row = self.global_view.rowCount()
                self.global_view.insertRow(row)
                date_item = QTableWidgetItem(day_planning.date.strftime("%d-%m-%y"))
                self.global_view.setItem(row, 0, date_item)
                self.global_view.setItem(row, 1, QTableWidgetItem(f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}"))
                self.global_view.setItem(row, 2, QTableWidgetItem(slot.abbreviation))
                self.global_view.setItem(row, 3, QTableWidgetItem(slot.site))
                self.global_view.setItem(row, 4, QTableWidgetItem(slot.assignee or "Non attribué"))

                # Colorer la ligne si c'est un week-end, un jour férié ou un pont
                if day_planning.is_weekend or day_planning.is_holiday_or_bridge:
                    for col in range(self.global_view.columnCount()):
                        self.global_view.item(row, col).setBackground(QBrush(WEEKEND_COLOR))
                else:
                    for col in range(self.global_view.columnCount()):
                        self.global_view.item(row, col).setBackground(QBrush(WEEKDAY_COLOR))

        self.global_view.resizeColumnsToContents()
        
        # Fixer la hauteur des lignes
        for row in range(self.global_view.rowCount()):
            self.global_view.setRowHeight(row, 25)

        # Empêcher l'édition des cellules
        self.global_view.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        
    def update_post_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        self.planning_generator = PlanningGenerator(self.doctors, self.cats, self.post_configuration)
        if self.planning:
            self.generate_planning(self.planning)  # Passez le planning existant
        else:
            self.generate_planning()  # Créez un nouveau planning si aucun n'existe
            
    def update_data(self, doctors, cats, post_configuration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        if self.planning:
            self.update_table()
            self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)

    def update_planning(self, updated_planning):
        self.planning = updated_planning
        self.update_table()
        self.doctor_planning_view.update_view(updated_planning, self.doctors, self.cats)
        self.main_window.update_data()


    def reset_planning(self):
        confirm = QMessageBox.question(self, "Confirmation", 
                                    "Êtes-vous sûr de vouloir réinitialiser le planning ? Toutes les données de planning seront perdues.",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                    QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            # Réinitialiser le planning
            self.planning = None
            self.weekend_validated = False

            # Réinitialiser l'état des boutons
            self.generate_button.setText("Générer le planning")
            self.generate_button.setEnabled(True)
            self.validate_weekends_button.setEnabled(False)

            # Déconnecter et reconnecter le signal pour s'assurer qu'il n'y a qu'une seule connexion
            self.generate_button.clicked.disconnect()
            self.generate_button.clicked.connect(self.generate_planning)

            # Réinitialiser les compteurs et attributs des médecins et CAT
            for doctor in self.doctors:
                doctor.night_shifts = {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0}
                doctor.nm_shifts = {'NMs': 0, 'NMd': 0, 'total': 0}
                doctor.combo_counts = {combo: 0 for combo in WEEKEND_COMBINATIONS}
                doctor.group_counts = {group: 0 for group in ["CmS", "CmD", "CaS", "CaD", "CsSD", "VmS", "VmD", "VaSD"]}
                doctor.weekday_night_shifts = {'NL': 0, 'total': 0}
                doctor.weekday_nm_shifts = {'NM': 0, 'total': 0}
                doctor.weekday_combo_counts = {combo: 0 for combo in WEEKDAY_COMBINATIONS}
                doctor.weekday_post_counts = {post_type: 0 for post_type in ALL_POST_TYPES}

            for cat in self.cats:
                cat.posts = {}
                cat.weekday_posts = {}

            # Effacer les vues
            self.global_view.setRowCount(0)
            self.global_view.setColumnCount(0)
            self.doctor_planning_view.clear_view()

            # Réinitialiser le générateur de planning
            self.planning_generator = PlanningGenerator(self.doctors, self.cats, self.post_configuration)

            # Réinitialiser la barre de progression
            self.progress_bar.setValue(0)

            # Mettre à jour les données dans la fenêtre principale
            self.main_window.reset_all_views()

            QMessageBox.information(self, "Réinitialisation", "Le planning a été réinitialisé avec succès. Vous pouvez maintenant générer un nouveau planning.")

# gui/detached_stats_window.py

# © 2024 HILAL Arkane. Tous droits réservés.
from PyQt6.QtWidgets import QMainWindow
from .stats_view import StatsView

class DetachedStatsWindow(QMainWindow):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.setWindowTitle("Statistiques détachées")
        self.stats_view = StatsView(planning=main_window.planning_tab.planning, 
                                    doctors=main_window.doctors, 
                                    cats=main_window.cats)
        self.setCentralWidget(self.stats_view)
        self.setGeometry(200, 200, 800, 600)

    def closeEvent(self, event):
        self.main_window.reattach_stats()
        event.accept()

    def update_stats(self):
        if hasattr(self.main_window.planning_tab, 'planning'):
            self.stats_view.update_stats(self.main_window.planning_tab.planning,
                                         self.main_window.doctors,
                                         self.main_window.cats)

# gui/post_configuration.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/post_configuration.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                            QTimeEdit, QLineEdit, QCheckBox, QGroupBox,
                            QTableWidget, QTableWidgetItem, QLabel, QSpinBox, QDateEdit, 
                            QHeaderView, QComboBox, QDialog, QFormLayout, QDialogButtonBox, 
                            QMessageBox, QRadioButton, QButtonGroup)
from PyQt6.QtCore import QDate, Qt, QTime
from PyQt6.QtGui import QColor, QBrush, QIcon, QFont
from datetime import time  # Ajout de l'import correct pour time
from core.Constantes.models import DailyPostConfiguration, PostConfig, SpecificPostConfig, ALL_POST_TYPES, PostManager, TimeSlot
from core.Constantes.custom_post import CustomPost
from typing import List, Dict, Optional, TYPE_CHECKING, Union
from .styles import EDIT_DELETE_BUTTON_STYLE
import logging

logger = logging.getLogger(__name__)


class CustomSpinBox(QSpinBox):
    def wheelEvent(self, event):
        event.ignore()

class SpecificConfigDialog(QDialog):
    def __init__(self, parent, start_date, end_date, default_weekday_config, default_saturday_config, default_sunday_config, existing_config=None):
        super().__init__(parent)
        self.start_date = start_date
        self.end_date = end_date
        self.default_weekday_config = default_weekday_config
        self.default_saturday_config = default_saturday_config
        self.default_sunday_config = default_sunday_config
        self.existing_config = existing_config
        self.setWindowTitle("Configuration spécifique")
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.start_date_edit = QDateEdit(self.start_date if not self.existing_config else self.existing_config.start_date)
        self.end_date_edit = QDateEdit(self.end_date if not self.existing_config else self.existing_config.end_date)

        form.addRow("Date de début:", self.start_date_edit)
        form.addRow("Date de fin:", self.end_date_edit)

        self.day_type_group = QButtonGroup(self)
        weekday_radio = QRadioButton("Jours de semaine")
        saturday_radio = QRadioButton("Samedis")
        sunday_radio = QRadioButton("Dimanches/Fériés")
        self.day_type_group.addButton(weekday_radio, 1)
        self.day_type_group.addButton(saturday_radio, 2)
        self.day_type_group.addButton(sunday_radio, 3)

        day_type_layout = QHBoxLayout()
        day_type_layout.addWidget(weekday_radio)
        day_type_layout.addWidget(saturday_radio)
        day_type_layout.addWidget(sunday_radio)
        form.addRow("Type de jours à configurer:", day_type_layout)

        # Ajouter un label explicatif
        explanation = QLabel("Note: Cette configuration ne s'appliquera qu'aux types de jours sélectionnés dans la plage de dates choisie.")
        explanation.setWordWrap(True)
        form.addRow(explanation)

        layout.addLayout(form)

        self.post_table = QTableWidget()
        self.post_table.setColumnCount(2)
        self.post_table.setHorizontalHeaderLabels(["Type de poste", "Nombre"])
        self.post_table.verticalHeader().setVisible(False)

        layout.addWidget(self.post_table)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self.day_type_group.buttonClicked.connect(self.update_table)
        weekday_radio.setChecked(True)
        self.update_table()

    def update_table(self):
        self.post_table.setRowCount(0)
        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            default_config = self.default_weekday_config
        elif day_type_id == 2:
            default_config = self.default_saturday_config
        else:
            default_config = self.default_sunday_config

        for post_type in ALL_POST_TYPES:
            row = self.post_table.rowCount()
            self.post_table.insertRow(row)
            self.post_table.setItem(row, 0, QTableWidgetItem(post_type))
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            if self.existing_config and post_type in self.existing_config.post_counts:
                spinbox.setValue(self.existing_config.post_counts[post_type])
            else:
                spinbox.setValue(default_config.get(post_type, PostConfig()).total)
            self.post_table.setCellWidget(row, 1, spinbox)
        self.post_table.resizeColumnsToContents()

    def get_config(self):
        post_counts = {}
        for row in range(self.post_table.rowCount()):
            post_type = self.post_table.item(row, 0).text()
            count = self.post_table.cellWidget(row, 1).value()
            if count > 0:
                post_counts[post_type] = count

        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            apply_to = "Semaine"
        elif day_type_id == 2:
            apply_to = "Samedi"
        else:
            apply_to = "Dimanche/Ferié"

        return SpecificPostConfig(
            start_date=self.start_date_edit.date().toPyDate(),
            end_date=self.end_date_edit.date().toPyDate(),
            apply_to=apply_to,
            post_counts=post_counts
        )
    
    def validate_config(self) -> bool:
        if self.start_date_edit.date() > self.end_date_edit.date():
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return False

        selected_config = None
        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            selected_config = self.default_weekday_config
        elif day_type_id == 2:
            selected_config = self.default_saturday_config
        else:
            selected_config = self.default_sunday_config

        # Vérifier les valeurs par rapport à la configuration par défaut
        for row in range(self.post_table.rowCount()):
            post_type = self.post_table.item(row, 0).text()
            count = self.post_table.cellWidget(row, 1).value()
            default_count = selected_config.get(post_type, PostConfig()).total

            if count < 0:
                QMessageBox.warning(self, "Erreur", f"Le nombre de postes ne peut pas être négatif pour {post_type}")
                return False

        return True

    def accept(self):
        if self.validate_config():
            super().accept()

        
class SpecificConfigWidget(QWidget):
    def __init__(self, post_configuration, planning_start_date, planning_end_date, main_window):  # Ajout de main_window
        super().__init__()
        self.post_configuration = post_configuration
        self.planning_start_date = planning_start_date
        self.planning_end_date = planning_end_date
        self.main_window = main_window  # Stockage de la référence
        self.init_ui()


    def init_ui(self):
        layout = QVBoxLayout(self)
        
        self.table = QTableWidget()
        self.table.setColumnCount(6)
        self.table.setHorizontalHeaderLabels(["Date début", "Date fin", "Type de jour", "Types de postes", "Nombre", "Actions"])
        layout.addWidget(self.table)

        button_layout = QHBoxLayout()
        add_button = QPushButton("Ajouter une configuration")
        add_button.clicked.connect(self.add_specific_config)
        save_button = QPushButton("Enregistrer config spécifique")
        save_button.clicked.connect(self.save_specific_config)
        button_layout.addWidget(add_button)
        button_layout.addWidget(save_button)
        layout.addLayout(button_layout)

        self.update_table()

    def add_specific_config(self):
        dialog = SpecificConfigDialog(
            self, 
            self.planning_start_date, 
            self.planning_end_date, 
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            config = dialog.get_config()
            self.post_configuration.add_specific_config(config)
            self.update_table()
            print(f"Configuration ajoutée et table mise à jour")  # Pour le débogage

    def edit_specific_config(self, row):
        config = self.post_configuration.specific_configs[row]
        dialog = SpecificConfigDialog(
            self, 
            self.planning_start_date, 
            self.planning_end_date, 
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday,
            existing_config=config
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_config = dialog.get_config()
            self.post_configuration.specific_configs[row] = new_config
            self.update_table()

    def delete_specific_config(self, row):
        config_to_delete = self.post_configuration.specific_configs[row]
        self.post_configuration.remove_specific_config(config_to_delete)
        self.update_table()

    def update_table(self):
        self.table.setRowCount(len(self.post_configuration.specific_configs))
        for row, config in enumerate(self.post_configuration.specific_configs):
            self.table.setItem(row, 0, QTableWidgetItem(config.start_date.strftime("%d-%m-%y")))
            self.table.setItem(row, 1, QTableWidgetItem(config.end_date.strftime("%d-%m-%y")))
            self.table.setItem(row, 2, QTableWidgetItem(config.apply_to))

            # Fusionner les types de poste et leur nombre
            post_counts = ", ".join([f"{count}{post_type}" for post_type, count in config.post_counts.items()])
            post_counts_item = QTableWidgetItem(post_counts)
            post_counts_item.setTextAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
            self.table.setItem(row, 3, post_counts_item)
            
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            
            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier la configuration")
            edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer la configuration")
            delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            actions_layout.addWidget(edit_button)
            actions_layout.addWidget(delete_button)
            actions_layout.setContentsMargins(2, 2, 2, 2)
            actions_layout.setSpacing(4)
            
            edit_button.clicked.connect(lambda _, r=row: self.edit_specific_config(r))
            delete_button.clicked.connect(lambda _, r=row: self.delete_specific_config(r))
            
            self.table.setCellWidget(row, 4, actions_widget)
        self.table.resizeColumnsToContents()
        self.table.resizeRowsToContents()

    def save_specific_config(self):
        try:
            specific_configs = []
            for row in range(self.table.rowCount()):
                # Création de la configuration comme avant
                specific_config = SpecificPostConfig(...)
                specific_configs.append(specific_config)
            
            self.post_configuration.specific_configs = specific_configs
            # Forcer la mise à jour complète
            if hasattr(self.parent(), 'main_window'):
                self.parent().main_window.update_post_configuration(self.post_configuration)
                self.parent().main_window.save_data()  # S'assurer que tout est sauvegardé
                QMessageBox.information(self, "Succès", "Configuration spécifique sauvegardée avec succès")
            else:
                QMessageBox.warning(self, "Erreur", "Impossible de sauvegarder la configuration")
                
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors de la sauvegarde : {str(e)}")
        
class PostConfigurationWidget(QWidget):
    
    # Ajoutez sync_scroll comme méthode statique pour la lisibilité
    @staticmethod
    def sync_scroll(tables):
        if not tables:
            return

        main_scrollbar = tables[0].verticalScrollBar()

        def update_scroll():
            for table in tables[1:]:
                table.verticalScrollBar().setValue(main_scrollbar.value())

        main_scrollbar.valueChanged.connect(update_scroll)

        for table in tables[1:]:
            table.verticalScrollBar().valueChanged.connect(lambda val: main_scrollbar.setValue(val))

    def __init__(self, post_configuration, main_window):
        super().__init__()
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.config_tables = {}
        self.custom_posts = {}
        self.load_custom_posts()
        self.clean_invalid_custom_posts()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        tab_widget = QTabWidget()

        
        # Onglet pour les médecins
        doctors_tab = QWidget()
        doctors_layout = QVBoxLayout(doctors_tab)
        doctors_config = self.create_config_tab(
            [("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday)],
            "Médecins"
        )
        doctors_layout.addWidget(doctors_config)
        
        # Boutons en ligne pour les médecins
        doctors_button_layout = QHBoxLayout()
        add_custom_post_button = QPushButton("Ajouter un poste")
        add_custom_post_button.clicked.connect(self.add_custom_post)
        save_doctors_button = QPushButton("Enregistrer la configuration des médecins")
        save_doctors_button.clicked.connect(lambda: self.save_configuration("Médecin"))
        
        doctors_button_layout.addWidget(add_custom_post_button)
        doctors_button_layout.addWidget(save_doctors_button)
        doctors_layout.addLayout(doctors_button_layout)
        
        tab_widget.addTab(doctors_tab, "Postes Médecins")

        # Onglet pour les CAT
        cats_tab = QWidget()
        cats_layout = QVBoxLayout(cats_tab)
        cats_config = self.create_config_tab(
            [("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)],
            "CAT"
        )
        cats_layout.addWidget(cats_config)
        
        # Bouton de sauvegarde pour les CAT
        cats_button_layout = QHBoxLayout()
        save_cats_button = QPushButton("Enregistrer la configuration des CAT")
        save_cats_button.clicked.connect(lambda: self.save_configuration("CAT"))
        cats_button_layout.addWidget(save_cats_button)
        cats_layout.addLayout(cats_button_layout)
        
        tab_widget.addTab(cats_tab, "Postes CAT")
        
        # Après avoir ajouté les tableaux au dictionnaire config_tables
        self.sync_scroll([
            self.config_tables["Semaine"],
            self.config_tables["Samedi"],
            self.config_tables["Dimanche/Férié"],
            self.config_tables["CAT_Semaine"],
            self.config_tables["CAT_Samedi"],
            self.config_tables["CAT_Dimanche/férié"]
        ])
        
        # Modification de l'initialisation de SpecificConfigWidget
        self.specific_config_tab = SpecificConfigWidget(
            self.post_configuration,
            self.start_date if hasattr(self, 'start_date') else None,
            self.end_date if hasattr(self, 'end_date') else None,
            self.main_window  # Passage de la référence main_window
        )
        tab_widget.addTab(self.specific_config_tab, "Jours spécifiques")
        
        layout.addWidget(tab_widget)

        # Dans init_ui, après la création du bouton
        add_custom_post_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)

    def update_dates(self, start_date, end_date):
        self.specific_config_tab.planning_start_date = start_date
        self.specific_config_tab.planning_end_date = end_date
        self.specific_config_tab.update_table()


    def create_config_tab(self, configs, title):
        """Crée un nouvel onglet de configuration"""
        tab = QWidget()
        tab_layout = QHBoxLayout(tab)
        
        for day_type, config in configs:
            column_layout = QVBoxLayout()
            column_layout.addWidget(QLabel(day_type))
            table = self.create_config_table(config, day_type)
            column_layout.addWidget(table)
            tab_layout.addLayout(column_layout)
        
        return tab
    
    def create_config_table(self, config, day_type):
        """Crée une nouvelle table de configuration"""
        table = QTableWidget(self)
        table.setObjectName(day_type)
        table.setColumnCount(3)  # Retour à 3 colonnes
        table.setHorizontalHeaderLabels(["Type de poste", "Nombre total", "Actions"])

        all_posts = self.get_posts_for_day_type(day_type)
        table.setRowCount(len(all_posts))
        
        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            if post_type in self.custom_posts:
                name_item.setBackground(QBrush(self.custom_posts[post_type].color))
                
            # Pour NL dans la config CAT en semaine, modifier le texte
            if post_type == "NL" and "CAT" in day_type and "Semaine" in day_type:
                name_item.setText("NL/NLv")
                
            table.setItem(row, 0, name_item)
            
            # Création du widget pour la colonne "Nombre total"
            if post_type == "NL" and "CAT" in day_type and "Semaine" in day_type:
                # Créer un widget conteneur pour les deux spinbox
                container = QWidget()
                layout = QHBoxLayout(container)
                layout.setContentsMargins(2, 2, 2, 2)
                layout.setSpacing(2)
                
                # Spinbox pour NL
                nl_spinbox = CustomSpinBox()
                nl_spinbox.setRange(0, 20)
                nl_spinbox.setValue(config.get(post_type, PostConfig()).total)
                nl_spinbox.setFixedWidth(50)  # Réduire la largeur
                
                # Spinbox pour NLv
                nlv_spinbox = CustomSpinBox()
                nlv_spinbox.setRange(0, 20)
                nlv_spinbox.setValue(config.get("NLv", PostConfig()).total)
                nlv_spinbox.setFixedWidth(50)  # Réduire la largeur
                
                layout.addWidget(nl_spinbox)
                layout.addWidget(nlv_spinbox)
                
                table.setCellWidget(row, 1, container)
            else:
                # SpinBox normal pour les autres postes
                spinbox = CustomSpinBox()
                spinbox.setRange(0, 20)
                spinbox.setValue(config.get(post_type, PostConfig()).total)
                table.setCellWidget(row, 1, spinbox)

            # Pour les postes personnalisés uniquement
            if post_type in self.custom_posts:
                actions_widget = QWidget()
                actions_layout = QHBoxLayout(actions_widget)
                actions_layout.setContentsMargins(2, 2, 2, 2)
                
                edit_button = QPushButton()
                edit_button.setIcon(QIcon("icons/edition.png"))
                edit_button.setToolTip("Modifier le poste personnalisé")
                edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                delete_button = QPushButton()
                delete_button.setIcon(QIcon("icons/supprimer.png"))
                delete_button.setToolTip("Supprimer le poste personnalisé")
                delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                
                edit_button.clicked.connect(lambda _, p=post_type: self.edit_custom_post(p))
                delete_button.clicked.connect(lambda _, p=post_type: self.remove_custom_post(p))
                
                actions_layout.addWidget(edit_button)
                actions_layout.addWidget(delete_button)
                table.setCellWidget(row, 2, actions_widget)
            else:
                empty_widget = QWidget()
                table.setCellWidget(row, 2, empty_widget)

        # Ajuster l'affichage de la table
        table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        table.setColumnWidth(2, 140)
        
        self.config_tables[day_type] = table
        return table
    
    def get_posts_for_day_type(self, day_type: str) -> list:
        """Obtient tous les postes (standards + personnalisés) pour un type de jour"""
        logger.debug(f"Récupération des postes pour {day_type}")
        
        day_type_mapping = {
            "Semaine": "weekday",
            "Samedi": "saturday",
            "Dimanche/Férié": "sunday_holiday",
            "CAT_Semaine": "weekday",
            "CAT_Samedi": "saturday",
            "CAT_Dimanche/férié": "sunday_holiday"
        }

        all_posts = list(ALL_POST_TYPES)
        real_day_type = day_type_mapping.get(day_type)
        is_cat = day_type.startswith("CAT_")

        # Debug logs
        logger.debug(f"Posts standard : {all_posts}")
        logger.debug(f"Posts personnalisés disponibles : {list(self.custom_posts.keys())}")

        if real_day_type:
            for name, post in self.custom_posts.items():
                logger.debug(f"Vérification du poste {name}:")
                logger.debug(f"- Types de jour: {post.day_types}")
                logger.debug(f"- Type d'assignation: {post.assignment_type}")
                
                if real_day_type in post.day_types:
                    is_eligible = False
                    if is_cat and post.assignment_type in ['cats', 'both']:
                        logger.debug(f"- Éligible pour CAT")
                        is_eligible = True
                    elif not is_cat and post.assignment_type in ['doctors', 'both']:
                        logger.debug(f"- Éligible pour médecins")
                        is_eligible = True
                    
                    if is_eligible and name not in all_posts:
                        all_posts.append(name)
                        logger.debug(f"- Poste {name} ajouté à la liste")

        logger.debug(f"Liste finale pour {day_type}: {all_posts}")
        return all_posts
    def add_custom_post(self):
        """Ajoute un nouveau poste personnalisé"""
        dialog = NewPostDialog(self, existing_posts=self.custom_posts,
                            statistic_groups=self.define_statistic_groups())
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_post = dialog.get_post()
            if new_post:
                logger.info(f"Nouveau poste créé : {new_post.name}")
                logger.debug(f"- Types de jour: {new_post.day_types}")
                logger.debug(f"- Type d'assignation: {new_post.assignment_type}")
                
                # Ajouter aux custom posts
                self.custom_posts[new_post.name] = new_post
                logger.debug(f"Poste ajouté au dictionnaire custom_posts")
                
                # Ajouter aux configurations appropriées
                for day_type in new_post.day_types:
                    if new_post.assignment_type in ["Médecin", "Les deux"]:
                        config = getattr(self.post_configuration, day_type)
                        config[new_post.name] = PostConfig(total=1)
                        logger.debug(f"Ajouté à la configuration {day_type} des médecins")
                    
                    if new_post.assignment_type in ["CAT", "Les deux"]:
                        cat_config = getattr(self.post_configuration, f"cat_{day_type}")
                        cat_config[new_post.name] = PostConfig(total=1)
                        logger.debug(f"Ajouté à la configuration {day_type} des CAT")
                
                # Sauvegarder et mettre à jour
                self.save_custom_posts()
                logger.debug("Custom posts sauvegardés")
                
                # Mise à jour des tables
                for day_type, table in self.config_tables.items():
                    logger.debug(f"Mise à jour de la table {day_type}")
                    self.refresh_table(table, day_type)
                
                logger.info(f"Poste {new_post.name} ajouté avec succès")
                QMessageBox.information(self, "Succès", f"Le poste {new_post.name} a été ajouté avec succès")
                
    def get_action_button_style(self):
        return """
            QPushButton {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 3px 8px;
                font-size: 11px;
                border-radius: 2px;
                margin: 1px;
                max-width: 60px;
            }
            QPushButton:hover {
                background-color: #e8e8e8;
            }
        """
        
    def _update_config_tables(self):
        """Met à jour les tables de configuration avec tous les postes"""
        configs = [
            ("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday),
            ("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
        ]

        for day_type, config in configs:
            table = self.config_tables.get(day_type)
            if table:
                # Sauvegarder la position du scroll actuelle
                current_scroll = table.verticalScrollBar().value()
                
                # Récupérer tous les postes pour ce type de jour
                all_posts = self.get_posts_for_day_type(day_type)
                
                # Mettre à jour la table
                table.setRowCount(0)  # Effacer d'abord la table
                table.setRowCount(len(all_posts))
                table.setColumnCount(3)
                table.setHorizontalHeaderLabels(["Type de poste", "Nombre total", "Actions"])
                
                for row, post_type in enumerate(all_posts):
                    # Création et ajout du nom du poste
                    name_item = QTableWidgetItem(post_type)
                    if post_type in self.custom_posts:
                        name_item.setBackground(QBrush(self.custom_posts[post_type].color))
                    table.setItem(row, 0, name_item)
                    
                    # SpinBox pour le nombre
                    spinbox = CustomSpinBox()
                    spinbox.setRange(0, 20)
                    spinbox.setValue(config.get(post_type, PostConfig()).total)
                    table.setCellWidget(row, 1, spinbox)
                    
                    # Ajouter les boutons d'action pour les postes personnalisés
                    if post_type in self.custom_posts:
                        actions_widget = QWidget()
                        actions_layout = QHBoxLayout(actions_widget)
                        actions_layout.setContentsMargins(2, 2, 2, 2)
                        actions_layout.setSpacing(4)
                        
                        edit_button = QPushButton()
                        edit_button.setIcon(QIcon("icons/edition.png"))
                        edit_button.setToolTip("Modifier le poste personnalisé")
                        edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                        delete_button = QPushButton()
                        delete_button.setIcon(QIcon("icons/supprimer.png"))
                        delete_button.setToolTip("Supprimer le poste personnalisé")
                        delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                        
                        edit_button.clicked.connect(lambda _, p=post_type: self.edit_custom_post(p))
                        delete_button.clicked.connect(lambda _, p=post_type: self.remove_custom_post(p))
                        
                        actions_layout.addWidget(edit_button)
                        actions_layout.addWidget(delete_button)
                        
                        actions_widget.setLayout(actions_layout)
                        table.setCellWidget(row, 2, actions_widget)
                    else:
                        # Pour les postes standards, on met une cellule vide
                        empty_widget = QWidget()
                        table.setCellWidget(row, 2, empty_widget)
                
                # Restaurer la position du scroll
                table.verticalScrollBar().setValue(current_scroll)
                
                # Ajuster la taille des colonnes
                table.resizeColumnsToContents()
                
                # Optimiser la largeur des colonnes
                header = table.horizontalHeader()
                header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
                header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
                header.setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
                
                # Définir une largeur minimale pour la colonne des actions
                table.setColumnWidth(2, 140)
            else:
                print(f"Table non trouvée pour {day_type}")
    
    
    def add_post_to_configurations(self, post):
        """Ajoute un nouveau poste à toutes les configurations appropriées"""
        # Pour les médecins
        if post.assignment_type in ['doctors', 'both']:
            for day_type in post.day_types:
                config = getattr(self.post_configuration, day_type)
                config[post.name] = PostConfig(total=1)
        
        # Pour les CAT
        if post.assignment_type in ['cats', 'both']:
            for day_type in post.day_types:
                config = getattr(self.post_configuration, f'cat_{day_type}')
                config[post.name] = PostConfig(total=1)
                
    def remove_custom_post(self, post_name: str):
        """Supprime un poste personnalisé"""
        if post_name in self.custom_posts:
            confirm = QMessageBox.question(
                self,
                "Confirmation",
                f"Êtes-vous sûr de vouloir supprimer le poste {post_name} ?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm == QMessageBox.StandardButton.Yes:
                # Supprimer le poste de la configuration
                post = self.custom_posts[post_name]
                for day_type in post.day_types:
                    if post.assignment_type in ["Médecin", "Les deux"]:
                        if day_type == "weekday":
                            self.post_configuration.weekday.pop(post_name, None)
                        elif day_type == "saturday":
                            self.post_configuration.saturday.pop(post_name, None)
                        elif day_type == "sunday_holiday":
                            self.post_configuration.sunday_holiday.pop(post_name, None)
                    
                    if post.assignment_type in ["CAT", "Les deux"]:
                        if day_type == "weekday":
                            self.post_configuration.cat_weekday.pop(post_name, None)
                        elif day_type == "saturday":
                            self.post_configuration.cat_saturday.pop(post_name, None)
                        elif day_type == "sunday_holiday":
                            self.post_configuration.cat_sunday_holiday.pop(post_name, None)
                
                del self.custom_posts[post_name]
                self.save_custom_posts()
                self.update_all_tables()
                QMessageBox.information(self, "Succès", f"Le poste {post_name} a été supprimé")

    def save_custom_posts(self):
        """Sauvegarde les postes personnalisés"""
        print("Sauvegarde des postes personnalisés :")  # Debug
        for name, post in self.custom_posts.items():
            print(f"- {name}: {post.day_types}, {post.assignment_type}")  # Debug
        custom_posts_data = {name: post.to_dict() for name, post in self.custom_posts.items()}
        self.main_window.data_persistence.save_custom_posts(custom_posts_data)

    def load_custom_posts(self):
        """Charge les postes personnalisés depuis la persistance"""
        try:
            custom_posts_data = self.main_window.data_persistence.load_custom_posts()
            if custom_posts_data:
                self.custom_posts = {}
                for name, data in custom_posts_data.items():
                    try:
                        if isinstance(data, dict):
                            self.custom_posts[name] = CustomPost.from_dict(data)
                        else:
                            self.custom_posts[name] = data
                        logger.info(f"Poste personnalisé chargé: {name}")
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement du poste {name}: {e}")
            self.update_all_tables()
        except Exception as e:
            logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")

    def refresh_custom_posts(self):
        """Rafraîchit la liste des postes personnalisés"""
        new_custom_posts = self.main_window.data_persistence.load_custom_posts()
        if new_custom_posts:
            has_changes = False
            # Vérifier les modifications
            for name, data in new_custom_posts.items():
                if name not in self.custom_posts:
                    try:
                        if isinstance(data, dict):
                            self.custom_posts[name] = CustomPost.from_dict(data)
                        else:
                            self.custom_posts[name] = data
                        has_changes = True
                        logger.info(f"Nouveau poste personnalisé détecté: {name}")
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement du poste {name}: {e}")
            
            # Vérifier les suppressions
            for name in list(self.custom_posts.keys()):
                if name not in new_custom_posts:
                    del self.custom_posts[name]
                    has_changes = True
                    logger.info(f"Poste personnalisé supprimé: {name}")
            
            if has_changes:
                self.update_all_tables()
        
    def update_table(self, table: QTableWidget, day_type: str):
        """Met à jour une table spécifique avec les postes standards et personnalisés"""
        current_scroll_position = table.verticalScrollBar().value()
        
        # Récupérer la configuration appropriée
        if "CAT" in day_type:
            config = getattr(self.post_configuration, f"cat_{day_type.lower().replace('cat_', '')}", {})
            assignation_filter = ["CAT", "Les deux"]
        else:
            config = getattr(self.post_configuration, day_type.lower(), {})
            assignation_filter = ["Médecin", "Les deux"]

        # Récupérer tous les postes (standards + personnalisés)
        all_posts = list(ALL_POST_TYPES)
        custom_posts_for_type = [
            post for post in self.custom_posts.values()
            if (day_type.lower().replace("cat_", "") in post.day_types and 
                post.assignment_type in assignation_filter)
        ]
        all_posts.extend([post.name for post in custom_posts_for_type])
        
        # Mettre à jour la table
        table.setRowCount(len(all_posts))
        
        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            table.setItem(row, 0, name_item)
            
            # Colorer les postes personnalisés
            if post_type in [p.name for p in custom_posts_for_type]:
                custom_post = next(p for p in custom_posts_for_type if p.name == post_type)
                name_item.setBackground(QBrush(custom_post.color))
            
            # SpinBox pour le nombre
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            spinbox.setValue(config.get(post_type, PostConfig()).total)
            table.setCellWidget(row, 1, spinbox)

        # Restaurer la position du scroll
        table.verticalScrollBar().setValue(current_scroll_position)
        table.resizeColumnsToContents()
        
    def update_all_tables(self):
        """Met à jour toutes les tables de configuration"""
        # Mettre à jour les tables des médecins
        for day_type in ["Semaine", "Samedi", "Dimanche/Férié"]:
            table = self.config_tables.get(day_type)
            if table:
                self.refresh_table(table, day_type)

        # Mettre à jour les tables des CAT
        for day_type in ["CAT_Semaine", "CAT_Samedi", "CAT_Dimanche/férié"]:
            table = self.config_tables.get(day_type)
            if table:
                self.refresh_table(table, day_type)


    def refresh_table(self, table: QTableWidget, day_type: str):
        """Rafraîchit une table spécifique"""
        current_scroll = table.verticalScrollBar().value()
        
        # Obtenir tous les postes pour ce type de jour
        all_posts = self.get_posts_for_day_type(day_type)
        
        # Mise à jour de la table
        table.setRowCount(len(all_posts))
        
        # Obtenir la configuration appropriée
        config_mapping = {
            "Semaine": self.post_configuration.weekday,
            "Samedi": self.post_configuration.saturday,
            "Dimanche/Férié": self.post_configuration.sunday_holiday,
            "CAT_Semaine": self.post_configuration.cat_weekday,
            "CAT_Samedi": self.post_configuration.cat_saturday,
            "CAT_Dimanche/férié": self.post_configuration.cat_sunday_holiday
        }
        config = config_mapping.get(day_type, {})

        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            if post_type in self.custom_posts:
                custom_post = self.custom_posts[post_type]
                name_item.setBackground(QBrush(custom_post.color))
                # Ajouter les boutons d'action
                actions_widget = QWidget()
                actions_layout = QHBoxLayout(actions_widget)
                actions_layout.setContentsMargins(2, 2, 2, 2)
                
                edit_button = QPushButton()
                edit_button.setIcon(QIcon("icons/edition.png"))
                edit_button.setToolTip("Modifier le poste personnalisé")
                edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                delete_button = QPushButton()
                delete_button.setIcon(QIcon("icons/supprimer.png"))
                delete_button.setToolTip("Supprimer le poste personnalisé")
                delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                
                edit_button.clicked.connect(lambda _, n=post_type: self.edit_custom_post(n))
                delete_button.clicked.connect(lambda _, n=post_type: self.remove_custom_post(n))
                
                actions_layout.addWidget(edit_button)
                actions_layout.addWidget(delete_button)
                
                table.setCellWidget(row, 2, actions_widget)
            
            table.setItem(row, 0, name_item)
            
            # Spinbox pour le nombre
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            spinbox.setValue(config.get(post_type, PostConfig()).total)
            table.setCellWidget(row, 1, spinbox)

        # Restaurer le scroll
        table.verticalScrollBar().setValue(current_scroll)
        table.resizeColumnsToContents()
    
    def save_configuration(self, config_type):
        if config_type == "Médecin":
            configs = [
                ("Semaine", self.post_configuration.weekday),
                ("Samedi", self.post_configuration.saturday),
                ("Dimanche/Férié", self.post_configuration.sunday_holiday)
            ]
        elif config_type == "CAT":
            configs = [
                ("CAT_Semaine", self.post_configuration.cat_weekday),
                ("CAT_Samedi", self.post_configuration.cat_saturday),
                ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
            ]
        else:
            return

        for day_type, config in configs:
            table = self.config_tables.get(day_type)
            if table:
                for row in range(table.rowCount()):
                    post_type = table.item(row, 0).text()
                    cell_widget = table.cellWidget(row, 1)
                    
                    # Cas spécial pour NL/NLv
                    if isinstance(cell_widget, QWidget) and cell_widget.layout() and cell_widget.layout().count() == 2:
                        nl_spinbox = cell_widget.layout().itemAt(0).widget()
                        nlv_spinbox = cell_widget.layout().itemAt(1).widget()
                        config["NL"] = PostConfig(total=nl_spinbox.value())
                        config["NLv"] = PostConfig(total=nlv_spinbox.value())
                    else:
                        if post_type == "NL/NLv":
                            post_type = "NL"
                        total_count = cell_widget.value()
                        config[post_type] = PostConfig(total=total_count)

        # Mise à jour et sauvegarde
        self.main_window.update_post_configuration(self.post_configuration)
        QMessageBox.information(self, "Sauvegarde", f"Configuration des {config_type} sauvegardée")
        
        # On peut ajouter un message suggérant de générer le planning manuellement
        QMessageBox.information(self, "Rappel", "N'oubliez pas de générer de nouveau le planning pour appliquer ces changements.")


    def update_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        for day_type, config in [
            ("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday),
            ("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
        ]:
            table = self.config_tables.get(day_type)
            if table:
                for row in range(table.rowCount()):
                    post_type = table.item(row, 0).text()
                    cell_widget = table.cellWidget(row, 1)
                    
                    # Vérifier si c'est le widget spécial NL/NLv
                    if isinstance(cell_widget, QWidget) and cell_widget.layout() and cell_widget.layout().count() == 2:
                        nl_spinbox = cell_widget.layout().itemAt(0).widget()
                        nlv_spinbox = cell_widget.layout().itemAt(1).widget()
                        nl_spinbox.setValue(config.get("NL", PostConfig()).total)
                        nlv_spinbox.setValue(config.get("NLv", PostConfig()).total)
                    else:
                        if post_type == "NL/NLv":
                            post_type = "NL"
                        if isinstance(cell_widget, QSpinBox):
                            cell_widget.setValue(config.get(post_type, PostConfig()).total)
    
    def update_custom_posts_list(self):
        """Met à jour la liste des postes personnalisés"""
        self.custom_posts_list.setRowCount(len(self.custom_posts))
        
        for row, (name, post) in enumerate(self.custom_posts.items()):
            # Nom
            self.custom_posts_list.setItem(row, 0, QTableWidgetItem(name))
            
            # Horaires
            horaires = f"{post.start_time.strftime('%H:%M')} - {post.end_time.strftime('%H:%M')}"
            self.custom_posts_list.setItem(row, 1, QTableWidgetItem(horaires))
            
            # Types de jour
            types_jour = ", ".join(post.day_types)
            self.custom_posts_list.setItem(row, 2, QTableWidgetItem(types_jour))
            
            # Assignation
            self.custom_posts_list.setItem(row, 3, QTableWidgetItem(post.assignment_type))
            
            # Actions
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier le poste personnalisé")

            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer le poste personnalisé")
            
            edit_button.clicked.connect(lambda _, n=name: self.edit_custom_post(n))
            delete_button.clicked.connect(lambda _, n=name: self.remove_custom_post(n))
            
            actions_layout.addWidget(edit_button)
            actions_layout.addWidget(delete_button)
            self.custom_posts_list.setCellWidget(row, 4, actions_widget)
        
        self.custom_posts_list.resizeColumnsToContents()

    def define_statistic_groups(self):
        """
        Définit tous les groupes de postes possibles pour le menu déroulant.
        Cette méthode est utilisée par PostConfigurationWidget et NewPostDialog.
        """
        # Groupes Weekend
        weekend_groups = [
            ("Consultations Samedi", [
                "CmS",  # Consultation matin samedi
            ]),
            ("Consultations Dimanche/Férié", [
                "CmD",  # Consultation matin dimanche/férié
            ]),
            ("Consultations Weekend/Férié", [
                "CaSD",  # Consultation après-midi samedi + dimanche/férié
                "CsSD",  # Consultation soir samedi + dimanche/férié
            ]),
            ("Visites Samedi", [
                "VmS",  # Visites matin samedi
            ]),
            ("Visites Dimanche/Férié", [
                "VmD",  # Visites matin dimanche/férié
            ]),
            ("Visites Weekend/Férié", [
                "VaSD",  # Visites après-midi samedi + dimanche/férié
            ]),
            ("Gardes Weekend/Férié", [
                "NAMw",  # NA + NM weekends/férié
                "NLw",   # NL Weekend/férié + vendredi
            ])
        ]

        # Groupes Semaine
        weekday_groups = [
            ("Consultations Semaine", [
                "XmM",  # Consultation matin à partir de 7h
                "XM",   # Consultation matin à partir de 9h
                "XA",   # Consultation après-midi
                "XS",   # Consultation soir
            ]),
            ("Visites Semaine", [
                "Vm",   # Visites matin
                "VA"    # Visites après-midi
            ]),
            ("Gardes Semaine", [
                "NMC"   # NM + NC + NA de la semaine
            ])
        ]

        return {
            "Aucun": None,
            "Weekend": weekend_groups,
            "Semaine": weekday_groups
        }

    def edit_custom_post(self, post_name: str):
        """Modifie un poste personnalisé existant"""
        if post_name in self.custom_posts:
            dialog = NewPostDialog(
                self,
                existing_posts=self.custom_posts,
                statistic_groups=self.define_statistic_groups(),  # Utilisez define_statistic_groups ici
                post_to_edit=self.custom_posts[post_name]
            )
            
            if dialog.exec() == QDialog.DialogCode.Accepted:
                edited_post = dialog.get_post()
                if edited_post:
                    # Supprimer l'ancienne configuration
                    old_post = self.custom_posts[post_name]
                    self.remove_post_from_config(old_post)
                    
                    # Ajouter la nouvelle configuration
                    self.custom_posts[edited_post.name] = edited_post
                    self.add_post_to_config(edited_post)
                    
                    self.save_custom_posts()
                    self.update_all_tables()
                    QMessageBox.information(self, "Succès", f"Le poste {edited_post.name} a été modifié avec succès")

    def remove_post_from_config(self, post):
        """Supprime un poste de la configuration"""
        for day_type in post.day_types:
            if post.assignment_type in ["Médecin", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.weekday.pop(post.name, None)
                elif day_type == "saturday":
                    self.post_configuration.saturday.pop(post.name, None)
                elif day_type == "sunday_holiday":
                    self.post_configuration.sunday_holiday.pop(post.name, None)

            if post.assignment_type in ["CAT", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.cat_weekday.pop(post.name, None)
                elif day_type == "saturday":
                    self.post_configuration.cat_saturday.pop(post.name, None)
                elif day_type == "sunday_holiday":
                    self.post_configuration.cat_sunday_holiday.pop(post.name, None)

    def add_post_to_config(self, post):
        """Ajoute un poste à la configuration"""
        for day_type in post.day_types:
            if post.assignment_type in ["Médecin", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.weekday[post.name] = PostConfig(total=1)
                elif day_type == "saturday":
                    self.post_configuration.saturday[post.name] = PostConfig(total=1)
                elif day_type == "sunday_holiday":
                    self.post_configuration.sunday_holiday[post.name] = PostConfig(total=1)

            if post.assignment_type in ["CAT", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.cat_weekday[post.name] = PostConfig(total=1)
                elif day_type == "saturday":
                    self.post_configuration.cat_saturday[post.name] = PostConfig(total=1)
                elif day_type == "sunday_holiday":
                    self.post_configuration.cat_sunday_holiday[post.name] = PostConfig(total=1)
              
              
    def clean_invalid_custom_posts(self):
        """Nettoie les postes personnalisés invalides"""
        invalid_posts = []
        
        # Identifier les postes invalides
        for name, post in self.custom_posts.items():
            if post.assignment_type not in ['doctors', 'cats', 'both']:
                logger.debug(f"Poste invalide trouvé: {name} avec assignment_type: {post.assignment_type}")
                invalid_posts.append(name)
                
            # Vérifier aussi la validité des types de jour
            for day_type in post.day_types:
                if day_type not in ['weekday', 'saturday', 'sunday_holiday']:
                    logger.debug(f"Poste avec type de jour invalide: {name} avec day_type: {day_type}")
                    if name not in invalid_posts:
                        invalid_posts.append(name)

        # Supprimer les postes invalides
        for name in invalid_posts:
            logger.info(f"Suppression du poste invalide: {name}")
            del self.custom_posts[name]
            
            # Supprimer des configurations
            for config in [self.post_configuration.weekday, 
                        self.post_configuration.saturday, 
                        self.post_configuration.sunday_holiday,
                        self.post_configuration.cat_weekday,
                        self.post_configuration.cat_saturday,
                        self.post_configuration.cat_sunday_holiday]:
                if name in config:
                    del config[name]

        # Sauvegarder les modifications
        if invalid_posts:
            self.save_custom_posts()
            self.update_all_tables()
            logger.info(f"Nettoyage terminé. Postes supprimés: {invalid_posts}")
            
          
class NewPostDialog(QDialog):
    def __init__(self, parent=None, existing_posts=None, statistic_groups=None, post_to_edit=None):
        super().__init__(parent)
        self.existing_posts = existing_posts or {}
        self.custom_post = post_to_edit
        self.statistic_groups = statistic_groups
        self.post_manager = PostManager()  # Ajout du PostManager ici
        self.init_ui()
        if post_to_edit:
            self.load_post_data(post_to_edit)

    def init_ui(self):
        self.setWindowTitle("Nouveau Poste")
        layout = QVBoxLayout(self)

        # Nom du poste
        name_layout = QHBoxLayout()
        self.name_input = QLineEdit()
        self.name_input.setMaxLength(4)
        self.name_input.setPlaceholderText("2-4 caractères")
        name_layout.addWidget(QLabel("Nom du poste:"))
        name_layout.addWidget(self.name_input)
        layout.addLayout(name_layout)

        # Horaires
        time_layout = QHBoxLayout()
        self.start_time = QTimeEdit()
        self.end_time = QTimeEdit()
        self.start_time.setDisplayFormat("HH:mm")
        self.end_time.setDisplayFormat("HH:mm")
        time_layout.addWidget(QLabel("De:"))
        time_layout.addWidget(self.start_time)
        time_layout.addWidget(QLabel("À:"))
        time_layout.addWidget(self.end_time)
        layout.addLayout(time_layout)

        # Types de jour
        days_group = QGroupBox("Types de jour")
        days_layout = QHBoxLayout()
        self.weekday_check = QCheckBox("Semaine")
        self.saturday_check = QCheckBox("Samedi")
        self.sunday_check = QCheckBox("Dimanche/Férié")
        days_layout.addWidget(self.weekday_check)
        days_layout.addWidget(self.saturday_check)
        days_layout.addWidget(self.sunday_check)
        days_group.setLayout(days_layout)
        layout.addWidget(days_group)

        # Type d'assignation
        assignment_layout = QHBoxLayout()
        self.assignment_combo = QComboBox()
        self.assignment_combo.addItems(["Médecin", "CAT", "Les deux"])  # Utiliser les mêmes valeurs que dans le code
        assignment_layout.addWidget(QLabel("Assignation:"))
        assignment_layout.addWidget(self.assignment_combo)
        layout.addLayout(assignment_layout)

        # Groupe statistique
        stats_layout = QHBoxLayout()
        self.stats_combo = QComboBox()
        
        # Ajouter "Aucun"
        self.stats_combo.addItem("Aucun")
        
        # Ajouter les groupes de weekend
        self.stats_combo.insertSeparator(self.stats_combo.count())
        self.stats_combo.addItem("--- WEEKEND ---")
        for category, subgroups in self.statistic_groups["Weekend"]:
            self.stats_combo.insertSeparator(self.stats_combo.count())
            self.stats_combo.addItem(category)  # En-tête de catégorie
            for group in subgroups:
                self.stats_combo.addItem("    " + group)  # Sous-groupes indentés
        
        # Ajouter les groupes de semaine
        self.stats_combo.insertSeparator(self.stats_combo.count())
        self.stats_combo.addItem("--- SEMAINE ---")
        for category, subgroups in self.statistic_groups["Semaine"]:
            self.stats_combo.insertSeparator(self.stats_combo.count())
            self.stats_combo.addItem(category)  # En-tête de catégorie
            for group in subgroups:
                self.stats_combo.addItem("    " + group)  # Sous-groupes indentés

        # Désactiver les séparateurs et en-têtes
        model = self.stats_combo.model()
        for i in range(self.stats_combo.count()):
            text = self.stats_combo.itemText(i)
            if "---" in text or not text.startswith("    "):
                item = model.item(i)
                if item:
                    item.setEnabled(False)

        stats_layout.addWidget(QLabel("Groupe statistique:"))
        stats_layout.addWidget(self.stats_combo)
        layout.addLayout(stats_layout)


        # Combinaisons possibles
        self.init_combinations_ui(layout)

        # Boutons
        button_layout = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        cancel_button = QPushButton("Annuler")
        save_button.clicked.connect(self.validate_and_save)
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(save_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)
        
        # Connecter les changements d'horaires à la mise à jour des combinaisons
        self.start_time.timeChanged.connect(self.update_available_combinations)
        self.end_time.timeChanged.connect(self.update_available_combinations)


    def init_combinations_ui(self, parent_layout):
        combinations_group = QGroupBox("Combinaisons possibles")
        self.combinations_layout = QVBoxLayout()

        explanation = QLabel("Les postes disponibles pour la combinaison seront affichés en fonction des horaires compatibles")
        explanation.setWordWrap(True)
        self.combinations_layout.addWidget(explanation)

        self.combination_widgets = {}  # Stocke les widgets pour pouvoir les montrer/cacher
        
        # Créer les checkboxes pour tous les postes mais les cacher initialement
        all_posts = list(ALL_POST_TYPES) + [post.name for post in self.existing_posts.values()]
        
        for post_name in all_posts:
            checkbox = QCheckBox(post_name)
            checkbox.hide()  # Caché par défaut
            self.combination_widgets[post_name] = checkbox
            self.combinations_layout.addWidget(checkbox)

        combinations_group.setLayout(self.combinations_layout)
        parent_layout.addWidget(combinations_group)

    def get_post_period(self, start_time: time, end_time: time) -> int:
        """
        Détermine la période d'un créneau horaire
        0: Matin (7h-13h)
        1: Après-midi (13h-18h)
        2: Soir (18h-7h)
        """
        print(f"Analyse du créneau : {start_time} - {end_time}")
        
        if end_time < start_time:
            hours_range = list(range(start_time.hour, 24)) + list(range(0, end_time.hour + 1))
        else:
            hours_range = list(range(start_time.hour, end_time.hour + 1))
        
        print(f"Heures à analyser : {hours_range}")
        
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        print(f"Heures du matin : {morning_hours}")
        print(f"Heures de l'après-midi : {afternoon_hours}")
        print(f"Heures du soir : {evening_hours}")
        
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        
        if max_hours == morning_hours:
            print("Assigné à la période du matin")
            return 0
        elif max_hours == afternoon_hours:
            print("Assigné à la période de l'après-midi")
            return 1
        else:
            print("Assigné à la période du soir")
            return 2

    def update_available_combinations(self):
        """Met à jour dynamiquement les postes disponibles pour la combinaison"""
        start_time = self.start_time.time().toPyTime()
        end_time = self.end_time.time().toPyTime()

        if start_time >= end_time and not end_time.hour < 7:  # Permettre les créneaux qui traversent minuit
            return

        # Déterminer la période du nouveau poste
        new_post_period = self.get_post_period(start_time, end_time)

        for post_name, widget in self.combination_widgets.items():
            is_compatible = False
            
            if post_name in ALL_POST_TYPES:
                # Obtenir les horaires des postes standards
                post_details = self.post_manager.get_post_details(post_name, "weekday")
                if post_details:
                    post_start = post_details['start_time']
                    post_end = post_details['end_time']
                    
                    # Vérifier la compatibilité horaire
                    if not (start_time < post_end and end_time > post_start):
                        # Vérifier la période du poste standard
                        standard_post_period = self.get_post_period(post_start, post_end)
                        # Les périodes doivent être différentes pour être compatibles
                        is_compatible = new_post_period != standard_post_period
                        
            elif post_name in self.existing_posts:
                # Vérifier la compatibilité avec les postes personnalisés existants
                custom_post = self.existing_posts[post_name]
                if not (start_time < custom_post.end_time and end_time > custom_post.start_time):
                    existing_post_period = self.get_post_period(custom_post.start_time, custom_post.end_time)
                    is_compatible = new_post_period != existing_post_period

            # Montrer ou cacher le checkbox selon la compatibilité
            widget.setVisible(is_compatible)
            if not is_compatible and widget.isChecked():
                widget.setChecked(False)

    def load_post_data(self, post):
        """Charge les données d'un poste existant pour l'édition"""
        self.name_input.setText(post.name)
        self.start_time.setTime(QTime(post.start_time.hour, post.start_time.minute))
        self.end_time.setTime(QTime(post.end_time.hour, post.end_time.minute))
        
        # Types de jour
        self.weekday_check.setChecked("weekday" in post.day_types)
        self.saturday_check.setChecked("saturday" in post.day_types)
        self.sunday_check.setChecked("sunday_holiday" in post.day_types)
        
        # Assignation
        index = self.assignment_combo.findText(post.assignment_type.title())
        if index >= 0:
            self.assignment_combo.setCurrentIndex(index)
            
        # Sélectionner le bon groupe statistique
        if post.statistic_group:
            for i in range(self.stats_combo.count()):
                if self.stats_combo.itemText(i).strip() == post.statistic_group:
                    self.stats_combo.setCurrentIndex(i)
                    break
                
        # Combinaisons
        for post_name, combo_name in post.possible_combinations.items():
            if post_name in self.combination_widgets:
                self.combination_widgets[post_name].setChecked(True)

    def validate_and_save(self):
        try:
            # Validation du nom
            name = self.name_input.text().upper()
            if not name:
                raise ValueError("Le nom du poste est requis")
            if len(name) < 2 or len(name) > 4:
                raise ValueError("Le nom du poste doit contenir entre 2 et 4 caractères")

            # Validation des horaires
            start_time = self.start_time.time().toPyTime()
            end_time = self.end_time.time().toPyTime()
            if start_time >= end_time:
                raise ValueError("L'heure de début doit être antérieure à l'heure de fin")
            
            # Validation des types de jour
            day_types = set()
            if self.weekday_check.isChecked():
                day_types.add("weekday")
            if self.saturday_check.isChecked():
                day_types.add("saturday")
            if self.sunday_check.isChecked():
                day_types.add("sunday_holiday")
            
            if not day_types:
                raise ValueError("Au moins un type de jour doit être sélectionné")

            # Récupération des combinaisons
            combinations = {}
            for post_name, checkbox in self.combination_widgets.items():
                if checkbox.isChecked():
                    # Le nom de la combinaison est automatiquement générée
                    # en concaténant les noms des postes dans l'ordre
                    combo_name = name + post_name
                    combinations[post_name] = combo_name

            # Création du CustomPost
                self.custom_post = CustomPost(
                name=name,
                start_time=start_time,
                end_time=end_time,
                day_types=day_types,
                assignment_type=self.assignment_combo.currentText(),  # Plus besoin de .lower()
                possible_combinations=combinations,
                statistic_group=None if self.stats_combo.currentText() == "Aucun" else self.stats_combo.currentText()
            )

            self.accept()

        except ValueError as e:
            QMessageBox.warning(self, "Erreur de validation", str(e))

    def get_post(self) -> Optional[CustomPost]:
        """
        Convertit le type d'assignation en valeur correcte pour le CustomPost
        """
        assignment_mapping = {
            "Médecin": "doctors",
            "CAT": "cats",
            "Les deux": "both"
        }

        # Nettoyer le groupe statistique sélectionné (enlever les espaces et vérifier si c'est un vrai groupe)
        selected_group = self.stats_combo.currentText().strip()
        if selected_group == "Aucun" or not selected_group.startswith("    "):
            statistic_group = None
        else:
            statistic_group = selected_group.strip()  # Enlever les espaces de début
            
        if hasattr(self, 'custom_post'):
            # Convertir le type d'assignation
            assignment = assignment_mapping.get(self.custom_post.assignment_type)
            if assignment:
                self.custom_post.assignment_type = assignment
            return self.custom_post
        return None
    

# gui/doctor_planning_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# .gui/doctor_planning_view
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QComboBox, QScrollArea
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QColor, QBrush, QFont
from datetime import date, timedelta
from typing import Union
from core.utils import get_post_period
from core.Constantes.models import TimeSlot



# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class DoctorPlanningView(QWidget):
    def __init__(self, planning, doctors, cats):
        super().__init__()
        self.planning = planning
        self.doctors = sorted(doctors, key=lambda d: d.name.lower())  # Tri alphabétique des médecins
        self.cats = sorted(cats, key=lambda c: c.name.lower())  # Tri alphabétique des CATs
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteur de médecin/CAT
        self.selector = QComboBox()
        self.update_selector()
        self.selector.currentIndexChanged.connect(self.update_table)
        self.selector.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.selector.installEventFilter(self)  # Installer un filtre d'événements pour gérer les touches fléchées
        layout.addWidget(self.selector)

        # Créer une zone de défilement pour la table
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)

        # Table du planning
        self.table = QTableWidget()
        scroll_area.setWidget(self.table)

        self.setLayout(layout)

    def update_selector(self):
        self.selector.clear()
        self.selector.addItems([doctor.name for doctor in self.doctors])
        self.selector.addItems([cat.name for cat in self.cats])
        
    def update_view(self, planning, doctors, cats):
        self.planning = planning
        self.doctors = sorted(doctors, key=lambda d: d.name.lower())
        self.cats = sorted(cats, key=lambda c: c.name.lower())
        self.update_selector()
        self.update_table()

    def eventFilter(self, obj, event):
        if obj == self.selector and event.type() == event.Type.KeyPress:
            key = event.key()
            if key == Qt.Key.Key_Up or key == Qt.Key.Key_Down:
                current_index = self.selector.currentIndex()
                if key == Qt.Key.Key_Up and current_index > 0:
                    self.selector.setCurrentIndex(current_index - 1)
                elif key == Qt.Key.Key_Down and current_index < self.selector.count() - 1:
                    self.selector.setCurrentIndex(current_index + 1)
                return True
        return super().eventFilter(obj, event)

    def update_table(self):
        try:
            if not hasattr(self, 'table') or not self.table:
                return
                
            if not self.planning or not self.planning.days:
                self.clear_table()
                return

            # Désactiver les mises à jour de l'interface pendant les modifications
            self.table.setUpdatesEnabled(False)
            
            try:
                selected_name = self.selector.currentText()
                start_date = self.planning.start_date
                end_date = self.planning.end_date
                
                # Calculer le nombre de mois
                total_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

                # Configurer la table
                if self.table:
                    self.table.clear()
                    self.table.setRowCount(31)
                    self.table.setColumnCount(total_months * 4 + 1)

                    # En-têtes de colonnes
                    headers = ["Jour"]
                    current_date = date(start_date.year, start_date.month, 1)
                    for _ in range(total_months):
                        month_name = current_date.strftime("%b")
                        headers.extend([f"{month_name}\nJ", f"{month_name}\nM", f"{month_name}\nAM", f"{month_name}\nS"])
                        current_date = (current_date.replace(day=28) + timedelta(days=4)).replace(day=1)
                    
                    if self.table:
                        self.table.setHorizontalHeaderLabels(headers)

                    current_date = start_date
                    while current_date <= end_date:
                        if not self.table:
                            break
                            
                        day_row = current_date.day - 1
                        month_col = (current_date.year - start_date.year) * 12 + current_date.month - start_date.month
                        col_offset = month_col * 4 + 1

                        # Créer et configurer les items
                        items_to_set = []
                        
                        day_item = QTableWidgetItem(str(current_date.day))
                        day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                        items_to_set.append((day_row, 0, day_item))
                        
                        weekday_item = QTableWidgetItem(self.get_weekday_abbr(current_date.weekday()))
                        weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                        weekday_item.setForeground(QBrush(WEEKDAY_TEXT_COLOR))
                        font = QFont()
                        font.setPointSize(8)
                        weekday_item.setFont(font)
                        items_to_set.append((day_row, col_offset, weekday_item))

                        day_planning = next((day for day in self.planning.days if day.date == current_date), None)
                        if day_planning:
                            is_weekend_or_holiday = day_planning.is_weekend or day_planning.is_holiday_or_bridge
                            background_color = WEEKEND_COLOR if is_weekend_or_holiday else WEEKDAY_COLOR
                            
                            slots = [slot for slot in day_planning.slots if slot.assignee == selected_name]
                            periods = [
                                [s for s in slots if get_post_period(s) == i]
                                for i in range(3)
                            ]

                            for i, post_list in enumerate(periods):
                                item = QTableWidgetItem(", ".join([p.abbreviation for p in post_list]))
                                item.setBackground(QBrush(background_color))
                                
                                selected_person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
                                if selected_person:
                                    for desiderata in selected_person.desiderata:
                                        if desiderata.start_date <= current_date <= desiderata.end_date:
                                            if desiderata.period == i + 1:
                                                item.setBackground(QBrush(WEEKEND_DESIDERATA_COLOR if is_weekend_or_holiday else DESIDERATA_COLOR))
                                
                                items_to_set.append((day_row, col_offset + i + 1, item))

                        # Définir tous les items en une seule fois
                        if self.table:
                            for row, col, item in items_to_set:
                                self.table.setItem(row, col, item)

                        current_date += timedelta(days=1)

                    # Ajuster la taille des cellules
                    if self.table:
                        for row in range(self.table.rowCount()):
                            self.table.setRowHeight(row, 20)

                        for col in range(self.table.columnCount()):
                            if col == 0:
                                self.table.setColumnWidth(col, 40)
                            elif (col - 1) % 4 == 0:
                                self.table.setColumnWidth(col, 30)
                            else:
                                self.table.setColumnWidth(col, 50)

                        # Empêcher l'édition des cellules
                        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)

            finally:
                # Réactiver les mises à jour de l'interface
                if self.table:
                    self.table.setUpdatesEnabled(True)

        except RuntimeError:
            # Gérer l'erreur si le widget a été supprimé
            pass
        except Exception as e:
            print(f"Erreur lors de la mise à jour du tableau : {e}")


    def get_weekday_abbr(self, weekday):
        return ["L", "M", "M", "J", "V", "S", "D"][weekday]

    def get_post_period(self, slot_or_abbrev: Union[TimeSlot, str]) -> int:
        """
        Détermine la période d'un poste (0: Matin, 1: Après-midi, 2: Soir)
        """
        # Si on reçoit un objet TimeSlot complet
        if isinstance(slot_or_abbrev, TimeSlot):
            start_hour = slot_or_abbrev.start_time.hour
            if 7 <= start_hour < 13:
                return 0  # Matin
            elif 13 <= start_hour < 18:
                return 1  # Après-midi
            else:
                return 2  # Soir
        
        # Si on reçoit juste l'abréviation (pour les postes standards)
        if isinstance(slot_or_abbrev, str):
            if slot_or_abbrev in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
                return 0
            elif slot_or_abbrev in ["CA", "HA", "SA", "RA", "AL", "AC"]:
                return 1
            else:
                return 2

        return 2  # Par défaut
        
    def clear_table(self):
        self.table.clear()
        self.table.setRowCount(1)
        self.table.setColumnCount(1)
        self.table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))
        
    def clear_view(self):
        self.planning = None
        self.table.clear()
        self.table.setRowCount(0)
        self.table.setColumnCount(0)
        self.selector.setCurrentIndex(0)

# gui/styles.py

# gui/styles.py

EDIT_DELETE_BUTTON_STYLE = """
    QPushButton {
        background-color: #f8f8f8;
        border: 1px solid #ddd;
        padding: 4px 8px;
        border-radius: 4px;
        min-width: 24px;
        max-width: 24px;
        min-height: 24px;
        max-height: 24px;
    }
    QPushButton:hover {
        background-color: #e8e8e8;
        border: 1px solid #ccc;
    }
    QPushButton:pressed {
        background-color: #d8d8d8;
    }
"""



# gui/desiderata_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/desiderata_management.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QScrollArea, QGridLayout, QAbstractScrollArea,
                             QTableWidget, QTableWidgetItem, QComboBox, QMessageBox, QLabel, QDateEdit, QMessageBox,
                             QSplitter, QHeaderView,QDialog)
from PyQt6.QtCore import Qt, QDate, QEvent
from PyQt6.QtGui import QColor, QBrush, QFont
from core.Constantes.models import Desiderata, Doctor, CAT
from datetime import date, timedelta
from workalendar.europe import France

class DesiderataCalendarWidget(QTableWidget):
    def __init__(self, start_date, end_date):
        super().__init__()
        self.start_date = start_date
        self.end_date = end_date
        self.cal = France()
        self.selections = {}
        self.is_selecting = False  # Ajoutez cet attribut
        self.init_ui()

    def init_ui(self):
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.verticalHeader().setVisible(False)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        self.create_calendar()
        self.cellPressed.connect(self.on_cell_pressed)
        self.cellEntered.connect(self.on_cell_entered)
        self.setMouseTracking(True)
        self.viewport().installEventFilter(self)
        
    

    def create_calendar(self):
        self.clear()
        days_abbr = ["L", "M", "M", "J", "V", "S", "D"]
        months = (self.end_date.year - self.start_date.year) * 12 + self.end_date.month - self.start_date.month + 1

        total_columns = 5 * months  # 5 colonnes pour chaque mois (Jour, Mois, M, AM, S)
        self.setColumnCount(total_columns)
        self.setRowCount(31)

        current_date = self.start_date
        for i in range(months):
            base_col = i * 5
            month_name = current_date.strftime("%b")
            self.setHorizontalHeaderItem(base_col, QTableWidgetItem("Jour"))
            self.setHorizontalHeaderItem(base_col + 1, QTableWidgetItem(month_name))
            self.setHorizontalHeaderItem(base_col + 2, QTableWidgetItem("M"))
            self.setHorizontalHeaderItem(base_col + 3, QTableWidgetItem("AM"))
            self.setHorizontalHeaderItem(base_col + 4, QTableWidgetItem("S"))
            current_date += timedelta(days=32)
            current_date = current_date.replace(day=1)

        current_date = self.start_date
        while current_date <= self.end_date:
            row = current_date.day - 1
            month_col = (current_date.year - self.start_date.year) * 12 + current_date.month - self.start_date.month
            base_col = month_col * 5

            is_weekend = current_date.weekday() >= 5
            is_holiday = self.cal.is_holiday(current_date)
            background_color = QColor(220, 220, 220) if is_weekend or is_holiday else QColor(255, 255, 255)

            # Colonne de jour pour chaque mois
            day_item = QTableWidgetItem(str(current_date.day))
            day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            day_item.setBackground(QBrush(background_color))
            self.setItem(row, base_col, day_item)

            # Colonne du jour de la semaine
            weekday_item = QTableWidgetItem(days_abbr[current_date.weekday()])
            weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            weekday_item.setForeground(QBrush(QColor(150, 150, 150)))
            weekday_item.setBackground(QBrush(background_color))
            self.setItem(row, base_col + 1, weekday_item)

            # Colonnes M, AM, S
            for i in range(3):
                item = QTableWidgetItem()
                item.setBackground(QBrush(background_color))
                self.setItem(row, base_col + 2 + i, item)

            current_date += timedelta(days=1)

        # Réduire la hauteur des lignes et la largeur des colonnes
        for row in range(self.rowCount()):
            self.setRowHeight(row, int(self.rowHeight(row) * 4/6))
        for col in range(self.columnCount()):
            self.setColumnWidth(col, int(self.columnWidth(col) * 3/5))
            
    def update_dates(self, start_date, end_date):
        self.store_selections()  # Stocker les sélections avant de mettre à jour
        self.start_date = start_date
        self.end_date = end_date
        self.create_calendar()
        self.restore_selections()

    def store_selections(self):
        self.selections.clear()
        for row in range(self.rowCount()):
            for col in range(1, self.columnCount()):
                item = self.item(row, col)
                if item and item.background().color() in [QColor(255, 150, 150), QColor(255, 200, 200)]:
                    date = self.get_date_from_cell(row, col)
                    if date:
                        self.selections[date] = col - (((col - 1) // 4) * 4)

    def restore_selections(self):
        for date, period in self.selections.items():
            if self.start_date <= date <= self.end_date:
                row = date.day - 1
                month_col = (date.year - self.start_date.year) * 12 + date.month - self.start_date.month
                col = 1 + month_col * 4 + period
                item = self.item(row, col)
                if item:
                    self.toggle_cell(item, force_select=True)

    def get_date_from_cell(self, row, col):
        month_col = col // 5
        year = self.start_date.year + (self.start_date.month + month_col - 1) // 12
        month = (self.start_date.month + month_col - 1) % 12 + 1
        day = row + 1
        try:
            return date(year, month, day)
        except ValueError:
            return None

    def toggle_cell(self, item, force_select=False):
        current_color = item.background().color()
        is_weekend_or_holiday = current_color == QColor(220, 220, 220) or current_color == QColor(255, 150, 150)
        
        if force_select:
            new_color = QColor(255, 150, 150) if is_weekend_or_holiday else QColor(255, 200, 200)
        elif is_weekend_or_holiday:
            new_color = QColor(255, 150, 150) if current_color == QColor(220, 220, 220) else QColor(220, 220, 220)
        else:
            new_color = QColor(255, 200, 200) if current_color == QColor(255, 255, 255) else QColor(255, 255, 255)
        
        item.setBackground(QBrush(new_color))

    def on_cell_pressed(self, row, column):
        if column % 5 in [2, 3, 4]:
            item = self.item(row, column)
            if item:
                self.is_selecting = True
                self.selection_state = item.background().color() != self.get_desiderata_color(item)
                self.toggle_cell(item)

    def on_cell_entered(self, row, column):
        if self.is_selecting and column % 5 in [2, 3, 4]:
            item = self.item(row, column)
            if item:
                self.toggle_cell(item)

    def eventFilter(self, obj, event):
        if obj == self.viewport():
            if event.type() == QEvent.Type.MouseButtonRelease:
                self.is_selecting = False
        return super().eventFilter(obj, event)


    def get_desiderata_color(self, item):
        is_weekend_or_holiday = item.background().color() == QColor(220, 220, 220)
        return QColor(255, 150, 150) if is_weekend_or_holiday else QColor(255, 200, 200)



    

    def get_selected_desiderata(self):
        desiderata = []
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 5):
                date = self.get_date_from_cell(row, col - 2)
                if date is None or date > self.end_date:
                    continue
                for i in range(3):
                    item = self.item(row, col + i)
                    if item and item.background().color() in [QColor(255, 150, 150), QColor(255, 200, 200)]:
                        desiderata.append((date, i + 1))
        return desiderata

    def set_desiderata(self, desiderata):
        self.reset_to_initial_state()
        for date, period in desiderata:
            if self.start_date <= date <= self.end_date:
                row = date.day - 1
                month_col = (date.year - self.start_date.year) * 12 + date.month - self.start_date.month
                base_col = month_col * 5
                col = base_col + 2 + (period - 1)
                item = self.item(row, col)
                if item:
                    self.toggle_cell(item, force_select=True)
    
    def reset_to_initial_state(self):
        for row in range(self.rowCount()):
            for col in range(1, self.columnCount()):
                item = self.item(row, col)
                if item:
                    date = self.get_date_from_cell(row, col)
                    if date:
                        is_weekend = date.weekday() >= 5
                        is_holiday = self.cal.is_holiday(date)
                        if is_weekend or is_holiday:
                            item.setBackground(QBrush(QColor(220, 220, 220)))
                        else:
                            item.setBackground(QBrush(QColor(255, 255, 255)))


    def clear_all_selections(self):
        self.reset_to_initial_state()

    


    def is_bridge_day(self, date):
        # 1) Lundi avant un mardi férié
        if date.weekday() == 0 and self.cal.is_holiday(date + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if date.weekday() in [4, 5] and self.cal.is_holiday(date - timedelta(days=1 if date.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if date.weekday() == 5 and self.cal.is_holiday(date - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= date.weekday() <= 4:  # Jours de semaine (lundi à vendredi)
            if (self.cal.is_holiday(date - timedelta(days=1)) and 
                self.cal.is_holiday(date + timedelta(days=1))):
                return True
        
        return False

 

    
class DesiderataManagementWidget(QWidget):
    def __init__(self, doctors, cats, planning_start_date, planning_end_date, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.planning_start_date = planning_start_date
        self.planning_end_date = planning_end_date
        self.main_window = main_window
        self.init_ui()

    def init_ui(self):
        self.layout = QVBoxLayout(self)

        # Modifier les champs de date pour utiliser un calendrier
        date_layout = QHBoxLayout()
        self.start_date = QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setCalendarPopup(True)
        self.start_date.setDate(QDate(self.planning_start_date))
        self.end_date.setDate(QDate(self.planning_end_date))

        self.apply_dates_button = QPushButton("Appliquer les dates")
        self.apply_dates_button.clicked.connect(self.apply_dates)

        date_layout.addWidget(QLabel("Date de début:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("Date de fin:"))
        date_layout.addWidget(self.end_date)
        date_layout.addWidget(self.apply_dates_button)

        self.layout.addLayout(date_layout)

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        self.person_selector = QComboBox()
        self.update_person_selector()
        self.person_selector.currentIndexChanged.connect(self.update_calendar)
        self.person_selector.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.person_selector.installEventFilter(self)
        left_layout.addWidget(self.person_selector)

        self.calendar_widget = DesiderataCalendarWidget(self.planning_start_date, self.planning_end_date)
        self.calendar_widget.setMinimumSize(800, 600)
        left_layout.addWidget(self.calendar_widget)

        button_layout = QHBoxLayout()
        save_button = QPushButton("Enregistrer les desiderata")
        save_button.clicked.connect(self.save_desiderata)
        button_layout.addWidget(save_button)

        reset_button = QPushButton("Réinitialiser les desiderata")
        reset_button.clicked.connect(self.reset_desiderata)
        button_layout.addWidget(reset_button)

        reset_all_button = QPushButton("Réinitialiser tous les desiderata")
        reset_all_button.clicked.connect(self.reset_all_desiderata)
        button_layout.addWidget(reset_all_button)

        left_layout.addLayout(button_layout)

        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)

        self.stats_label = QLabel("Statistiques d'indisponibilité:")
        right_layout.addWidget(self.stats_label)
        
        self.stats_table = QTableWidget()
        self.stats_table.setColumnCount(2)
        self.stats_table.setHorizontalHeaderLabels(["Médecin/CAT", "% d'indisponibilité"])
        right_layout.addWidget(self.stats_table)
        
        # Ajouter le bouton des périodes critiques
        self.show_critical_periods_button = QPushButton("Afficher les périodes critiques")
        self.show_critical_periods_button.clicked.connect(self.show_critical_periods)
        right_layout.addWidget(self.show_critical_periods_button)


        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)
        splitter.setSizes([int(self.width() * 0.7), int(self.width() * 0.3)])

        self.layout.addWidget(splitter)  # Utiliser self.layout au lieu de main_layout

        self.update_stats()
        self.update_calendar()
        
    def apply_dates(self):
        new_start_date = self.start_date.date().toPyDate()
        new_end_date = self.end_date.date().toPyDate()
        
        if new_start_date > new_end_date:
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return

        self.planning_start_date = new_start_date
        self.planning_end_date = new_end_date
        
        self.calendar_widget.update_dates(new_start_date, new_end_date)
        
        # Mettre à jour les dates dans le planning principal
        self.main_window.planning_tab.start_date.setDate(QDate(new_start_date))
        self.main_window.planning_tab.end_date.setDate(QDate(new_end_date))
        
        self.update_stats()
        self.update_calendar()
        
        QMessageBox.information(self, "Succès", "Les dates ont été appliquées avec succès.")

    def sync_dates_from_planning(self, start_date, end_date):
        self.start_date.setDate(QDate(start_date))
        self.end_date.setDate(QDate(end_date))
        self.planning_start_date = start_date
        self.planning_end_date = end_date
        self.calendar_widget.update_dates(start_date, end_date)
        self.update_stats()
        self.update_calendar()

     # Ajouter la méthode pour afficher la fenêtre des périodes critiques
    def show_critical_periods(self):
            self.critical_periods_window = CriticalPeriodsWindow(
                self.doctors,
                self.cats,
                self.planning_start_date,
                self.planning_end_date,
                self
            )
            self.critical_periods_window.show()
            
    def update_person_selector(self):
        self.person_selector.clear()
        sorted_doctors = sorted(self.doctors, key=lambda x: x.name.lower())
        sorted_cats = sorted(self.cats, key=lambda x: x.name.lower())
        
        for doctor in sorted_doctors:
            self.person_selector.addItem(doctor.name)
        
        if sorted_cats:
            self.person_selector.insertSeparator(len(sorted_doctors))
        
        for cat in sorted_cats:
            self.person_selector.addItem(cat.name)
            
    def update_calendar(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            self.calendar_widget.set_desiderata([(d.start_date, d.period) for d in person.desiderata])
        else:
            self.calendar_widget.clear_all_selections()
    
    def eventFilter(self, obj, event):
        if obj == self.person_selector and event.type() == QEvent.Type.KeyPress:
            key = event.key()
            if key == Qt.Key.Key_Up:
                index = self.person_selector.currentIndex()
                if index > 0:
                    self.person_selector.setCurrentIndex(index - 1)
                return True
            elif key == Qt.Key.Key_Down:
                index = self.person_selector.currentIndex()
                if index < self.person_selector.count() - 1:
                    self.person_selector.setCurrentIndex(index + 1)
                return True
        return super().eventFilter(obj, event)

    def save_desiderata(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            new_desiderata = self.calendar_widget.get_selected_desiderata()
            person.desiderata = [
                Desiderata(date, date, "Indisponibilité", period) 
                for date, period in new_desiderata
            ]
            self.update_stats()
            self.main_window.save_data()
            QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été enregistrés avec succès.")
    def reset_desiderata(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            confirm = QMessageBox.question(self, "Confirmation", 
                                           f"Êtes-vous sûr de vouloir réinitialiser les desiderata de {person.name} ?",
                                           QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if confirm == QMessageBox.StandardButton.Yes:
                person.desiderata = []
                self.calendar_widget.clear_all_selections()
                self.update_stats()
                QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été réinitialisés.")

    def reset_all_desiderata(self):
        confirm = QMessageBox.question(self, "Confirmation", 
                                       "Êtes-vous sûr de vouloir réinitialiser tous les desiderata pour tous les médecins et CAT ?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            for person in self.doctors + self.cats:
                person.desiderata = []
            self.calendar_widget.clear_all_selections()
            self.update_stats()
            self.update_calendar()
            QMessageBox.information(self, "Succès", "Tous les desiderata ont été réinitialisés.")

    def update_stats(self):
        self.stats_table.setRowCount(0)
        total_days = (self.planning_end_date - self.planning_start_date).days + 1
        stats = []

        for person in self.doctors + self.cats:
            unavailable_periods = sum(1 for d in person.desiderata if d.type == "Indisponibilité")
            total_periods = total_days * 3  # 3 périodes par jour
            unavailability_percentage = (unavailable_periods / total_periods) * 100
            
            # Initialiser le pourcentage de postes non attribués à 0
            unassigned_percentage = 0
            
            # Vérifier si le planning a été généré
            if (hasattr(self.main_window, 'planning_tab') and 
                hasattr(self.main_window.planning_tab, 'planning_generator') and 
                hasattr(self.main_window.planning_tab.planning_generator, 'planning') and
                self.main_window.planning_tab.planning_generator.planning is not None):
                
                planning = self.main_window.planning_tab.planning_generator.planning
                unassigned_shifts = self.main_window.planning_tab.planning_generator.analyze_unassigned_shifts(planning)
                
                if hasattr(self.main_window.planning_tab.planning_generator, 'target_distribution'):
                    target_distribution = self.main_window.planning_tab.planning_generator.target_distribution
                    expected_shifts = sum(target_distribution[person.name][day_type][post_type] 
                                          for day_type in target_distribution[person.name] 
                                          for post_type in target_distribution[person.name][day_type])
                    if expected_shifts > 0:
                        unassigned_percentage = (sum(unassigned_shifts[person.name].values()) / expected_shifts) * 100

            stats.append((person.name, unavailability_percentage, unassigned_percentage))

        stats.sort(key=lambda x: x[1], reverse=True)

        for row, (name, unavailability_percentage, unassigned_percentage) in enumerate(stats):
            self.stats_table.insertRow(row)
            self.stats_table.setItem(row, 0, QTableWidgetItem(name))
            self.stats_table.setItem(row, 1, QTableWidgetItem(f"{unavailability_percentage:.2f}%"))
            self.stats_table.setItem(row, 2, QTableWidgetItem(f"{unassigned_percentage:.2f}%"))

        self.stats_table.setHorizontalHeaderLabels(["Nom", "% d'indisponibilité", "% de postes non attribués"])
        self.stats_table.resizeColumnsToContents()


class CriticalPeriodsWindow(QDialog):
    def __init__(self, doctors, cats, start_date, end_date, parent=None):
        super().__init__(parent)
        self.doctors = doctors
        self.cats = cats
        self.start_date = start_date
        self.end_date = end_date
        self.cal = France()
        self.init_ui()
        self.update_critical_periods()

    def init_ui(self):
        self.setWindowTitle("Périodes critiques")
        self.setMinimumSize(1200, 600)
        main_layout = QVBoxLayout(self)

        # Layout horizontal pour le calendrier et la liste
        content_layout = QHBoxLayout()
        
        # Création du calendrier des périodes critiques
        self.calendar = CriticalPeriodsCalendar(self.start_date, self.end_date)
        self.calendar.cellClicked.connect(self.update_availability_list)
        content_layout.addWidget(self.calendar, stretch=2)

        # Création de la liste des disponibilités
        self.availability_list = QTableWidget()
        self.availability_list.setColumnCount(2)
        self.availability_list.setHorizontalHeaderLabels(["Médecin", "Statut"])
        self.availability_list.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        content_layout.addWidget(self.availability_list, stretch=1)

        main_layout.addLayout(content_layout)

        # Ajouter la légende
        legend_widget = self.calendar.add_legend(main_layout)
        main_layout.addWidget(legend_widget)

        # Ajuster les proportions
        self.calendar.setMinimumWidth(800)
        self.availability_list.setMinimumWidth(300)

        # Empêcher le redimensionnement des lignes
        self.calendar.verticalHeader().setDefaultSectionSize(25)
        self.availability_list.verticalHeader().setDefaultSectionSize(25)

    def update_critical_periods(self):
        # Calculer le nombre total de personnel (médecins + CAT)
        total_personnel = len(self.doctors) + len(self.cats)
        
        # Calculer le nombre de personnes indisponibles pour chaque période
        unavailability_map = {}
        for current_date in (self.start_date + timedelta(n) for n in range((self.end_date - self.start_date).days + 1)):
            for period in range(1, 4):  # 1: Matin, 2: Après-midi, 3: Soir
                unavailable_count = sum(
                    1 for person in (self.doctors + self.cats)
                    if any(
                        des.start_date <= current_date <= des.end_date and des.period == period
                        for des in person.desiderata
                    )
                )
                unavailability_map[(current_date, period)] = unavailable_count

        # Mettre à jour le calendrier avec les couleurs appropriées
        self.calendar.update_colors(unavailability_map, total_personnel)

    def update_availability_list(self, row, col):
        self.availability_list.setRowCount(0)
        date = self.calendar.get_date_from_cell(row, col - (col % 5))
        
        # Déterminer la période en fonction de la colonne
        if col % 5 == 2:
            period = 1  # Matin
            period_name = "Matin"
        elif col % 5 == 3:
            period = 2  # Après-midi
            period_name = "Après-midi"
        elif col % 5 == 4:
            period = 3  # Soir
            period_name = "Soir"
        else:
            return

        if not date:
            return

        # Ajouter une ligne d'en-tête avec la date et la période
        self.availability_list.insertRow(0)
        
        # Calculer le pourcentage d'indisponibilité
        total_personnel = len(self.doctors) + len(self.cats)
        unavailable_count = sum(
            1 for person in (self.doctors + self.cats)
            if any(des.start_date <= date <= des.end_date and des.period == period for des in person.desiderata)
        )
        percentage = (unavailable_count / total_personnel) * 100 if total_personnel > 0 else 0
        
        header_item = QTableWidgetItem(
            f"{date.strftime('%d/%m/%Y')} - {period_name}\n"
            f"{unavailable_count}/{total_personnel} ({percentage:.0f}% indisponibles)"
        )
        header_item.setBackground(QBrush(QColor(240, 240, 240)))
        header_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        self.availability_list.setSpan(0, 0, 1, 2)
        self.availability_list.setItem(0, 0, header_item)

        # Trier et afficher tous le personnel (médecins et CAT)
        all_personnel = self.doctors + self.cats
        sorted_personnel = sorted(all_personnel, key=lambda p: (
            not any(des.start_date <= date <= des.end_date and des.period == period for des in p.desiderata),
            isinstance(p, CAT),  # Trier les CAT après les médecins
            p.name
        ))

        for person in sorted_personnel:
            row = self.availability_list.rowCount()
            self.availability_list.insertRow(row)
            
            # Nom avec indication du type et des demi-parts pour les médecins
            name_text = person.name
            if isinstance(person, Doctor):
                if person.half_parts == 1:
                    name_text += " (½)"
            else:
                name_text += " (CAT)"
            name_item = QTableWidgetItem(name_text)
            self.availability_list.setItem(row, 0, name_item)
            
            # Statut de disponibilité
            is_available = not any(
                des.start_date <= date <= des.end_date and des.period == period
                for des in person.desiderata
            )
            status_item = QTableWidgetItem("Disponible" if is_available else "Indisponible")
            color = QColor(150, 255, 150) if is_available else QColor(255, 150, 150)
            status_item.setBackground(QBrush(color))
            status_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.availability_list.setItem(row, 1, status_item)

        self.availability_list.resizeColumnsToContents()
            
class CriticalPeriodsCalendar(DesiderataCalendarWidget):
    def __init__(self, start_date, end_date):
        super().__init__(start_date, end_date)
        self.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        # Définition des paliers et leurs couleurs
        self.color_ranges = {
            (0, 0): (QColor(255, 255, 255), "0% - Aucune indisponibilité"),
            (1, 25): (QColor(200, 255, 200), "1-25% - Indisponibilité faible"),
            (26, 50): (QColor(255, 255, 150), "26-50% - Indisponibilité modérée"),
            (51, 75): (QColor(255, 200, 150), "51-75% - Indisponibilité élevée"),
            (75, 99): (QColor(255, 0, 0), "76-99% - Indisponibilité critique"),
            (100, 100): (QColor(0, 0, 0), "100% - Indisponibilité totale")
        }

    def get_color_for_count(self, percentage):
        """
        Détermine la couleur en fonction du pourcentage d'indisponibilité
        """
        # Arrondir le pourcentage pour la comparaison
        percentage = round(percentage)
        
        for (min_val, max_val), (base_color, _) in self.color_ranges.items():
            if min_val <= percentage <= max_val:
                # Créer un dégradé subtil dans le palier
                if min_val != max_val:
                    ratio = (percentage - min_val) / (max_val - min_val)
                    base_h, base_s, base_v, _ = base_color.getHsvF()
                    # Ajuster légèrement la saturation pour le dégradé
                    new_s = min(1.0, base_s + (ratio * 0.2))
                    return QColor.fromHsvF(base_h, new_s, base_v)
                return base_color
                
        return self.color_ranges[(100, 100)][0]  # Noir pour 100%

    def update_colors(self, unavailability_map, total_personnel):
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 5):  # Colonnes M, AM, S
                date = self.get_date_from_cell(row, col - 2)
                if not date:
                    continue

                for i in range(3):  # Pour chaque période (M, AM, S)
                    period = i + 1
                    unavailable_count = unavailability_map.get((date, period), 0)
                    percentage = (unavailable_count / total_personnel) * 100 if total_personnel > 0 else 0
                    
                    item = self.item(row, col + i)
                    if item:
                        color = self.get_color_for_count(percentage)
                        item.setBackground(QBrush(color))
                        # Ajouter le pourcentage dans la cellule
                        item.setText(f"{percentage:.0f}%")
                        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

    def add_legend(self, parent_layout):
        legend_widget = QWidget()
        legend_layout = QHBoxLayout(legend_widget)
        legend_layout.setSpacing(10)
        legend_layout.setContentsMargins(10, 5, 10, 5)

        for (min_val, max_val), (color, description) in self.color_ranges.items():
            # Créer un carré de couleur
            color_label = QLabel()
            color_label.setFixedSize(20, 20)
            color_label.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            
            # Texte de description
            text_label = QLabel(description)
            text_label.setMinimumWidth(150)  # Assurer une largeur minimale pour la lisibilité
            
            # Conteneur pour chaque paire couleur-texte
            container = QWidget()
            container_layout = QHBoxLayout(container)
            container_layout.setSpacing(5)
            container_layout.addWidget(color_label)
            container_layout.addWidget(text_label)
            
            legend_layout.addWidget(container)

        return legend_widget

    def mousePressEvent(self, event):
        # Empêcher la modification des couleurs lors du clic
        item = self.itemAt(event.pos())
        if item:
            self.cellClicked.emit(item.row(), item.column())

# .vscode/settings.json

{
    "CodeGPT.apiKey": "CodeGPT Plus Beta",
    "CodeGPT.Autocomplete.enabled": false,
    "CodeGPT.Autocomplete.maxTokens": 240
}

