# data_cleanup.py

import os
import pickle
import shutil
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class DataCleanup:
    """Utilitaire pour nettoyer et vérifier les données persistantes."""
    
    def __init__(self):
        # Chemins des fichiers de données
        self.app_data_dir = os.path.expanduser("~/Library/Application Support/SosMedecins")
        self.data_files = [
            'app_data.pkl',
            'custom_posts.pkl',
            'planning_data.pkl',
            'post_config.pkl'
        ]

    def list_all_data(self):
        """Liste le contenu de tous les fichiers de données."""
        logger.info("\nCONTENU DES FICHIERS DE DONNÉES:")
        logger.info("=" * 60)
        
        for filename in self.data_files:
            filepath = os.path.join(self.app_data_dir, filename)
            if os.path.exists(filepath):
                try:
                    with open(filepath, 'rb') as f:
                        data = pickle.load(f)
                    logger.info(f"\nContenu de {filename}:")
                    logger.info("-" * 40)
                    self._print_data_structure(data)
                except Exception as e:
                    logger.error(f"Erreur lecture {filename}: {e}")
            else:
                logger.info(f"\n{filename} n'existe pas")

    def clean_custom_posts(self):
        """Nettoie spécifiquement les postes personnalisés."""
        custom_posts_file = os.path.join(self.app_data_dir, 'custom_posts.pkl')
        if os.path.exists(custom_posts_file):
            try:
                os.remove(custom_posts_file)
                logger.info("custom_posts.pkl supprimé avec succès")
            except Exception as e:
                logger.error(f"Erreur suppression custom_posts.pkl: {e}")
        else:
            logger.info("custom_posts.pkl n'existe pas")

    def backup_data(self):
        """Crée une sauvegarde des données actuelles."""
        backup_dir = os.path.join(self.app_data_dir, 'backup')
        os.makedirs(backup_dir, exist_ok=True)
        
        for filename in self.data_files:
            src = os.path.join(self.app_data_dir, filename)
            if os.path.exists(src):
                dst = os.path.join(backup_dir, filename)
                try:
                    shutil.copy2(src, dst)
                    logger.info(f"Sauvegarde créée: {filename}")
                except Exception as e:
                    logger.error(f"Erreur sauvegarde {filename}: {e}")

    def reset_all_data(self):
        """Réinitialise toutes les données persistantes."""
        # Créer d'abord une sauvegarde
        self.backup_data()
        
        # Supprimer les fichiers
        for filename in self.data_files:
            filepath = os.path.join(self.app_data_dir, filename)
            if os.path.exists(filepath):
                try:
                    os.remove(filepath)
                    logger.info(f"{filename} supprimé")
                except Exception as e:
                    logger.error(f"Erreur suppression {filename}: {e}")

    def _print_data_structure(self, data, level=0):
        """Affiche la structure des données de manière récursive."""
        indent = "  " * level
        
        if isinstance(data, dict):
            for key, value in data.items():
                logger.info(f"{indent}{key}:")
                self._print_data_structure(value, level + 1)
        elif isinstance(data, (list, tuple, set)):
            for item in data:
                self._print_data_structure(item, level + 1)
        else:
            logger.info(f"{indent}{data}")

def main():
    """Point d'entrée pour utiliser l'utilitaire."""
    logging.basicConfig(level=logging.INFO,
                       format='%(message)s')
    
    cleanup = DataCleanup()
    
    print("\nQue souhaitez-vous faire ?")
    print("1: Lister toutes les données")
    print("2: Nettoyer les postes personnalisés")
    print("3: Créer une sauvegarde")
    print("4: Réinitialiser toutes les données")
    print("0: Quitter")
    
    choice = input("\nVotre choix (0-4): ")
    
    if choice == "1":
        cleanup.list_all_data()
    elif choice == "2":
        cleanup.clean_custom_posts()
    elif choice == "3":
        cleanup.backup_data()
    elif choice == "4":
        confirm = input("Cette action est irréversible. Confirmer ? (o/n): ")
        if confirm.lower() == 'o':
            cleanup.reset_all_data()
    
if __name__ == "__main__":
    main()

# ExportsTxt.py

import os

def combine_files(project_dir, output_file):
    excluded_items = {'app_data.pkl', 'icons','dist', 'logger_config.py','logs','custom_posts.pkl','main.cpython-312-darwin.so','main.c','Tests', 'main.spec','setup.py', 'build', 'test', 'build/main', '.DS_Store', 'exportsTxt.py', 'test.py','utils', 'app.log', '__pycache__','venv', 'planningt.txt', 'SAVE base.txt', 'SAV 2.txt','SAV3.txt'}
    
    with open(output_file, "w", encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(project_dir):
            # Remove excluded directories
            dirs[:] = [d for d in dirs if d not in excluded_items]
            
            for file in files:
                if file in excluded_items:
                    continue
                
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding='utf-8') as infile:
                        relative_path = os.path.relpath(file_path, project_dir)
                        outfile.write(f"# {relative_path}\n\n")
                        outfile.write(infile.read())
                        outfile.write("\n\n")
                except UnicodeDecodeError:
                    print(f"Skipping file due to encoding issues: {file_path}")

project_directory = "/Users/arkane/Documents/Planning"
output_file_path = "/Users/arkane/Documents/Planning/planningt.txt"
combine_files(project_directory, output_file_path)


# main.py

# © 2024 HILAL Arkane. Tous droits réservés.
# main.py

import sys
import os
import logging

from logger_config import setup_logger
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QPalette, QColor, QIcon
from PyQt6.QtCore import QTimer, QThread, pyqtSignal
from gui.main_window import MainWindow
from gui.splash_screen import SplashScreen
from core.Constantes.models import Doctor, CAT, create_default_post_configuration
from core.Constantes.data_persistence import DataPersistence

def resource_path(relative_path):
    """Get the absolute path to the resource, works for development and for PyInstaller."""
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

def set_application_style(app):
    app.setStyle("Fusion")
    
    # Palette de couleurs
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(245, 245, 250))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(240, 240, 245))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 225))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Text, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.Button, QColor(225, 225, 230))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(50, 50, 50))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Link, QColor(85, 125, 160))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(85, 125, 160))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))

    app.setPalette(palette)

    # Feuille de style CSS
    app.setStyleSheet("""
    QMainWindow, QWidget {
        background-color: #F5F5FA;
        color: #323232;
        font-family: 'Helvetica Neue', 'Arial', sans-serif;
        font-size: 13px;
    }
    QPushButton {
        background-color: #3C6EA0;
        color: white;
        border: none;
        padding: 8px 18px;
        border-radius: 4px;
        font-weight: bold;
    }
    QPushButton:hover {
        background-color: #508CBB;
    }
    QPushButton:pressed {
        background-color: #2A5280;
    }
    QTableWidget, QTreeWidget, QListWidget {
        background-color: white;
        alternate-background-color: #F8F8FA;
    }
    QHeaderView::section {
        background-color: #E6E6EB;
        color: #323232;
        padding: 5px;
        border: none;
        border-right: 1px solid #D0D0D8;
        border-bottom: 1px solid #D0D0D8;
        font-weight: bold;
    }
    QTabWidget::pane {
        border: 1px solid #D0D0D8;
        background-color: #F5F5FA;
    }
    QTabBar::tab {
        background-color: #E6E6EB;
        color: #323232;
        padding: 8px 16px;
        border: 1px solid #D0D0D8;
        border-bottom: none;
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
    }
    QTabBar::tab:selected {
        background-color: #F5F5FA;
        border-bottom: 2px solid #557DA0;
    }
    QTabBar::tab:hover:!selected {
        background-color: #F2F2F5;
    }
    QComboBox, QDateEdit {
        background-color: #FFFFFF;
        color: #323232;
        border: 1px solid #D0D0D8;
        padding: 6px;
        border-radius: 6px;
    }
    QScrollBar:vertical {
        background-color: #F2F2F5;
        width: 12px;
    }
    QScrollBar::handle:vertical {
        background-color: #C0C0C8;
        border-radius: 6px;
    }
    QScrollBar::handle:vertical:hover {
        background-color: #A0A0A8;
    }
    QGroupBox {
        border: 1px solid #D0D0D8;
        border-radius: 6px;
        padding-top: 10px;
    }
    QGroupBox::title {
        color: #557DA0;
        font-weight: bold;
    }
    """)

class LoaderThread(QThread):
    update_signal = pyqtSignal(str)
    finished_signal = pyqtSignal(tuple)

    def run(self):
        self.update_signal.emit("Chargement des données...")
        data_persistence = DataPersistence()
        doctors, cats, post_configuration = data_persistence.load_data()

        if not doctors and not cats:
            self.update_signal.emit("Création des données par défaut...")
            doctors = [
                Doctor("Dr. Smith", 2),
                Doctor("Dr. Johnson", 1),
                Doctor("Dr. Williams", 2),
            ]
            cats = [
                CAT("CAT 1"),
                CAT("CAT 2"),
            ]

        if post_configuration is None:
            self.update_signal.emit("Création de la configuration par défaut...")
            post_configuration = create_default_post_configuration()

        self.update_signal.emit("Initialisation de l'interface...")
        self.finished_signal.emit((doctors, cats, post_configuration))


def main():
    logger = setup_logger()
    app = QApplication(sys.argv)
    set_application_style(app)

    splash = SplashScreen()
    splash.show()

    loader_thread = LoaderThread()
    loader_thread.update_signal.connect(splash.update_message)
    loader_thread.finished_signal.connect(lambda data: on_load_finished(data, splash))
    loader_thread.start()

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    sys.exit(app.exec())

def on_load_finished(data, splash):
    doctors, cats, post_configuration = data
    window = MainWindow(doctors, cats, post_configuration)
    
    def show_main_window():
        splash.finish(window)  # Ceci fermera le splash screen
        window.show()

    QTimer.singleShot(1000, show_main_window)  # Attendre au moins 3 secondes

if __name__ == "__main__":
    main()

# core/__init__.py

# © 2024 HILAL Arkane. Tous droits réservés.

from .Constantes.models import *
from .Generator.planning_generator import PlanningGenerator
from .Analyzer.pre_analyzer import PlanningPreAnalyzer
from .Constantes.constraints import PlanningConstraints

__all__ = ['PlanningGenerator']

# core/utils.py

# core/utils.py
from typing import Union
from datetime import datetime
import sys
import os

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

def get_post_period(post_or_slot) -> int:
    """
    Détermine la période d'un poste (0: Matin, 1: Après-midi, 2: Soir)
    basé sur la plage horaire majoritaire.
    """
    # Pour les postes standards (strings)
    if isinstance(post_or_slot, str):
        if post_or_slot in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return 0
        elif post_or_slot in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1
        else:
            return 2
    
    # Pour les postes avec horaires
    else:
        start_hour = post_or_slot.start_time.hour
        end_hour = post_or_slot.end_time.hour
        
        # Si le poste traverse minuit
        if end_hour < start_hour:
            hours_range = list(range(start_hour, 24)) + list(range(0, end_hour + 1))
        else:
            hours_range = list(range(start_hour, end_hour + 1))
        
        # Compte des heures dans chaque période
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        # Retourne la période avec le plus d'heures
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        if max_hours == morning_hours:
            return 0
        elif max_hours == afternoon_hours:
            return 1
        else:
            return 2

# core/Generator/planning_generator.py

# core/planning_generator.py

"""
planning_generator.py
Module de génération du planning basé sur les résultats de la pré-analyse
"""

import logging
import random
from datetime import datetime, date, timedelta, time
from typing import List, Dict, Optional, Tuple, Union
import math
from core.Constantes.models import (
    Doctor, CAT, Planning, DayPlanning, TimeSlot, PostManager, PostConfig,SpecificPostConfig,
    ALL_POST_TYPES, WEEKDAY_COMBINATIONS, WEEKEND_COMBINATIONS
)
from core.Constantes.constraints import PlanningConstraints
from core.Analyzer.pre_analyzer import PlanningPreAnalyzer
from core.Constantes.data_persistence import DataPersistence
from core.Constantes.day_type import DayType
from core.Constantes.custom_post import CustomPost
from collections import defaultdict
from core.Generator.weekday_gen import WeekdayGenerator

from workalendar.europe import France


logger = logging.getLogger(__name__)

class PlanningGenerator:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.constraints = PlanningConstraints()
        self.cal = France()
        self.post_manager = PostManager()
        
        # Chargement des postes personnalisés
        data_persistence = DataPersistence()
        self.custom_posts = data_persistence.load_custom_posts()
        
        # Vérification que tous les postes sont bien des objets CustomPost
        invalid_posts = []
        for name, post in list(self.custom_posts.items()):
            if not isinstance(post, CustomPost):
                try:
                    self.custom_posts[name] = CustomPost.from_dict(post if isinstance(post, dict) else post.__dict__)
                except Exception as e:
                    logger.error(f"Impossible de convertir le poste {name}: {e}")
                    invalid_posts.append(name)
        
        # Supprimer les postes invalides
        for name in invalid_posts:
            del self.custom_posts[name]
        
        logger.info(f"Postes personnalisés chargés: {list(self.custom_posts.keys())}")
        
        # Initialisation du suivi de distribution 
        self.current_distribution = {
            "weekend": {
                person.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0,  # NL weekend
                    "NAs": 0, "NAd": 0,  # NA weekend
                    "NMs": 0, "NMd": 0,  # NM weekend
                    "weekend_groups": {}  # Groupes weekend
                } for person in doctors + cats  # Ajouter aussi les CAT
            },
            "weekday": {
                person.name: {
                    "NL": 0,      # NL semaine
                    "weekday_groups": {}  # Groupes semaine
                } for person in doctors + cats  # Ajouter aussi les CAT
            }
        }
    def _initialize_planning_days(self, planning: Planning):
        logger.info("\nINITIALISATION DU PLANNING")
        logger.info("=" * 80)
        

        planning.days = []
        current_date = planning.start_date

        while current_date <= planning.end_date:
            # Utiliser DayTypeDetector pour déterminer le type de jour
            day_type = DayType.get_day_type(current_date, self.cal)
            
            # Nouveau : Traitement spécial pour les samedis de pont
            is_bridge_saturday = (current_date.weekday() == 5 and 
                                DayType.is_bridge_day(current_date, self.cal))
            
            # Déterminer la configuration à utiliser
            config_to_use = None
            
            # Modification : Utiliser la configuration sunday_holiday pour les samedis de pont
            if day_type == "sunday_holiday" or is_bridge_saturday:
                config_to_use = self.post_configuration.sunday_holiday
                logger.debug(f"{current_date} est un jour férié/pont - force config sunday_holiday")
            elif day_type == "saturday" and not is_bridge_saturday:
                config_to_use = self.post_configuration.saturday
            else:
                config_to_use = self.post_configuration.weekday

            # Vérifier s'il existe une configuration spécifique pour cette date
            specific_config = self._get_specific_config(current_date, day_type)
            if specific_config:
                config_to_use = specific_config

            # Créer l'instance du jour avec le statut correct
            day = DayPlanning(
                date=current_date,
                slots=[],
                is_weekend=(day_type in ["saturday", "sunday_holiday"]),
                is_holiday_or_bridge=(day_type == "sunday_holiday" or is_bridge_saturday)  # Modification ici
            )

            # Créer les slots en tenant compte du type spécial de jour
            if is_bridge_saturday:
                # Pour un samedi de pont, on traite comme un jour férié
                self._create_standard_slots(day, config_to_use, "sunday_holiday")
            else:
                self._create_standard_slots(day, config_to_use, day_type)
                
            self._create_custom_slots(day, config_to_use, day_type)

            planning.days.append(day)
            current_date += timedelta(days=1)

        self._log_slots_summary(planning)

    def _get_specific_config(self, current_date: date, day_type: str) -> Optional[Dict]:
        """Vérifie s'il existe une configuration spécifique pour cette date"""
        if hasattr(self.post_configuration, 'specific_configs'):
            normalized_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }[day_type]
            
            for config in self.post_configuration.specific_configs:
                if (config.start_date <= current_date <= config.end_date and
                    config.apply_to == normalized_type):
                    return config.post_counts
        return None


    def _get_config_from_analysis(self, current_date: date, day_type: str) -> Dict:
        """
        Récupère la configuration à utiliser pour un jour donné.
        """
        # D'abord vérifier si c'est un jour de pont
        if DayType.is_bridge_day(current_date, self.cal):
            logger.debug(f"{current_date} : jour de pont - utilisation config sunday_holiday")
            return self.post_configuration.sunday_holiday
            
        # Ensuite vérifier les configurations spécifiques
        if hasattr(self.post_configuration, 'specific_configs'):
            normalized_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }[day_type]
            
            for config in self.post_configuration.specific_configs:
                if (config.start_date <= current_date <= config.end_date and
                    config.apply_to == normalized_type):
                    logger.debug(f"{current_date} : configuration spécifique trouvée")
                    return config.post_counts
                    
        # Sinon utiliser la configuration standard
        if day_type == "sunday_holiday":
            logger.debug(f"{current_date} : dimanche/férié standard")
            return self.post_configuration.sunday_holiday
        elif day_type == "saturday":
            return self.post_configuration.saturday
        else:
            return self.post_configuration.weekday
        
    def _normalize_day_type(self, day_type: str) -> str:
        """
        Normalise le type de jour pour la comparaison avec les configurations spécifiques.
        """
        mapping = {
            "weekday": "Semaine",
            "saturday": "Samedi",
            "sunday_holiday": "Dimanche/Férié"
        }
        return mapping.get(day_type, day_type)

    def _create_standard_slots(self, day: DayPlanning, config: Dict, day_type: str):
        """
        Crée les slots standards pour un jour selon la configuration.
        """
        

        # Pour les jours de pont, on force l'utilisation de la config sunday_holiday
        if DayType.is_bridge_day(day.date, self.cal):
            logger.debug(f"{day.date} est un jour de pont - force config sunday_holiday")
            config = self.post_configuration.sunday_holiday

        for post_type, count in config.items():
            # Ignorer les postes personnalisés
            if post_type in self.custom_posts:
                continue

            total = count.total if isinstance(count, PostConfig) else count
            
            if total > 0:
                post_details = self.post_manager.get_post_details(post_type, day_type)
                
                if not post_details:
                    logger.warning(f"Pas de détails trouvés pour le poste {post_type}")
                    continue

                # Traitement spécial pour NL
                if post_type == "NL":
                    if day_type == "sunday_holiday" or (
                        day.date.weekday() == 4 and 
                        not DayType.get_day_type(day.date + timedelta(days=1), self.cal) == "sunday_holiday"
                    ) or (
                        day.date.weekday() == 5 and 
                        not DayType.get_day_type(day.date, self.cal) == "sunday_holiday"
                    ):
                        logger.debug(f"  - Création de {total} slot(s) {post_type}")
            
                
                # Création effective des slots
                for _ in range(total):
                    slot = TimeSlot(
                        start_time=datetime.combine(day.date, post_details['start_time']),
                        end_time=datetime.combine(
                            day.date + timedelta(days=1) if post_details['end_time'] < post_details['start_time'] else day.date,
                            post_details['end_time']
                        ),
                        site=post_details['site'],
                        slot_type="Consultation" if "Visite" not in post_details['site'] else "Visite",
                        abbreviation=post_type,
                        assignee=None
                    )
                    day.slots.append(slot)
                    
    def _create_custom_slots(self, day: DayPlanning, config: Dict, day_type: str):
        """Crée les slots pour les postes personnalisés"""
        if not self.custom_posts:
            return

        for post_name, custom_post in self.custom_posts.items():
            # Vérifier si le poste doit être créé pour ce type de jour
            if day_type in custom_post.day_types:
                # Récupérer la configuration pour ce jour
                configured_count = 0
                if isinstance(config, SpecificPostConfig):
                    configured_count = config.post_counts.get(post_name, 0)
                else:
                    configured_count = config.get(post_name, PostConfig()).total

                # Pour les samedis, créer le nombre de slots configuré dans post_configuration
                if day_type == "saturday":
                    configured_count = self.post_configuration.saturday.get(post_name, PostConfig()).total
                elif day_type == "sunday_holiday":
                    configured_count = self.post_configuration.sunday_holiday.get(post_name, PostConfig()).total

                logger.debug(f"Création de {configured_count} slots {post_name} pour {day.date} ({day_type})")

                # Créer les slots
                for _ in range(configured_count):
                    slot = TimeSlot(
                        start_time=datetime.combine(day.date, custom_post.start_time),
                        end_time=datetime.combine(
                            day.date + timedelta(days=1 if custom_post.end_time < custom_post.start_time else 0),
                            custom_post.end_time
                        ),
                        site="Personnalisé",
                        slot_type=custom_post.statistic_group.strip() if custom_post.statistic_group else "Personnalisé",
                        abbreviation=post_name,
                        assignee=None
                    )
                    day.slots.append(slot)

    def _create_slot(self, day_date: date, post_details: Dict, post_type: str) -> TimeSlot:
        """
        Crée un slot de planning à partir des détails du poste.
        
        Args:
            day_date (date): Date du jour
            post_details (Dict): Détails du poste (horaires, site, etc)
            post_type (str): Type de poste (NL, ML, etc)
            
        Returns:
            TimeSlot: Le slot créé
        """
        # Déterminer si le slot traverse minuit
        start_time = datetime.combine(day_date, post_details['start_time'])
        end_time = datetime.combine(
            day_date + timedelta(days=1) if post_details['end_time'] < post_details['start_time'] else day_date,
            post_details['end_time']
        )
        
        # Déterminer le type de slot (Consultation ou Visite)
        slot_type = "Consultation" if "Visite" not in post_details['site'] else "Visite"
        
        return TimeSlot(
            start_time=start_time,
            end_time=end_time,
            site=post_details['site'],
            slot_type=slot_type,
            abbreviation=post_type,
            assignee=None
        )

    def _log_slots_summary(self, planning: Planning):
        """
        Affiche un résumé détaillé des slots qui ont été créés.
        """
        logger.info("\nRÉSUMÉ DES SLOTS INITIALISÉS")
        logger.info("=" * 80)

        # Structure pour compter les slots par type de jour
        counts = {
            "weekday": defaultdict(int),    # Jours de semaine
            "saturday": defaultdict(int),    # Samedis normaux
            "sunday_holiday": defaultdict(int)  # Dimanches/Fériés/Ponts
        }

        # Les NL nécessitent un traitement spécial
        nl_slots = {
            "weekday": 0,   # Lundi-Jeudi
            "nlv": 0,       # Vendredi
            "nls": 0,       # Samedi normal
            "nld": 0        # Dimanche/Férié/Pont
        }

        # Compter les slots existants
        for day in planning.days:
            for slot in day.slots:
                if slot.abbreviation == "NL":
                    if day.is_holiday_or_bridge:
                        nl_slots["nld"] += 1
                    elif day.is_weekend and not day.is_holiday_or_bridge:
                        nl_slots["nls"] += 1
                    elif day.date.weekday() == 4:  # Vendredi
                        nl_slots["nlv"] += 1
                    else:
                        nl_slots["weekday"] += 1
                else:
                    if day.is_holiday_or_bridge:
                        counts["sunday_holiday"][slot.abbreviation] += 1
                    elif day.is_weekend and not day.is_holiday_or_bridge:
                        counts["saturday"][slot.abbreviation] += 1
                    else:
                        counts["weekday"][slot.abbreviation] += 1

        # Affichage des résultats
        for day_type, label in [
            ("weekday", "SEMAINE"),
            ("saturday", "SAMEDI"),
            ("sunday_holiday", "DIMANCHE/FÉRIÉ")
        ]:
            logger.info(f"\n{label}")
            logger.info("-" * 40)

            # Afficher d'abord les NL
            if day_type == "weekday":
                logger.info(f"NL (lundi-jeudi)   : {nl_slots['weekday']:3d} slots")
                logger.info(f"NL (vendredi)      : {nl_slots['nlv']:3d} slots")
            elif day_type == "saturday":
                logger.info(f"NL  : {nl_slots['nls']:3d} slots")
            else:
                logger.info(f"NL  : {nl_slots['nld']:3d} slots")

            # Afficher les autres postes triés
            if counts[day_type]:
                logger.info("\nAutres postes:")
                for post_type, count in sorted(counts[day_type].items()):
                    logger.info(f"{post_type:4}: {count:3d} slots")

        # Afficher les totaux NL
        logger.info("\nTOTAUX NL PAR CATÉGORIE:")
        logger.info("-" * 40)
        logger.info(f"NLv (Vendredi)        : {nl_slots['nlv']:3d} slots")
        logger.info(f"NLs (Samedi)          : {nl_slots['nls']:3d} slots")
        logger.info(f"NLd (Dimanche/Férié)  : {nl_slots['nld']:3d} slots")
        total_nl = sum(nl_slots.values())
        logger.info(f"Total NL              : {total_nl:3d} slots")

        # Statistiques NLd
        logger.info("\nSTATISTIQUES FINALES")
        logger.info("-" * 40)
        nld_days = nl_slots["nld"] // 2  # Car 2 slots par jour
        logger.info(f"Nombre total de jours NLd   : {nld_days}")
        logger.info(f"Nombre total de slots NLd   : {nl_slots['nld']}")

        # Vérification avec la pré-analyse
        if hasattr(planning, 'pre_analysis_results') and planning.pre_analysis_results is not None:
            target_nlw = planning.pre_analysis_results.get('adjusted_posts', {}).get('weekend_groups', {}).get('NLw', 0)
            if target_nlw:
                weekend_nl = nl_slots['nls'] + nl_slots['nld'] + nl_slots['nlv']
                logger.info(f"Requis selon pré-analyse    : {target_nlw}")
                if weekend_nl != target_nlw:
                    logger.warning(f"ATTENTION: Différence entre slots créés ({weekend_nl}) et requis ({target_nlw})")    
    def is_bridge_day(self, day: date) -> bool:
        """Détermine si une date est un jour de pont"""
        # 1) Lundi avant un mardi férié
        if day.weekday() == 0 and self.cal.is_holiday(day + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if day.weekday() in [4, 5] and self.cal.is_holiday(day - timedelta(days=1 if day.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if day.weekday() == 5 and self.cal.is_holiday(day - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= day.weekday() <= 4:
            if (self.cal.is_holiday(day - timedelta(days=1)) and 
                self.cal.is_holiday(day + timedelta(days=1))):
                return True
        
        return False


    def generate_planning(self, start_date: date, end_date: date) -> Optional[Planning]:
        """Génération initiale du planning (weekends uniquement)."""
        try:
            logger.info("=" * 80)
            logger.info(f"GÉNÉRATION DU PLANNING: {start_date} - {end_date}")
            logger.info("=" * 80)
            
            planning = Planning(start_date, end_date)
            
            # Initialiser les jours du planning
            self._initialize_planning_days(planning)
            
            # Pré-analyse
            pre_analyzer = PlanningPreAnalyzer(self.doctors, self.cats, self.post_configuration)
            pre_analyzer.set_date_range(start_date, end_date)
            pre_analysis_results = pre_analyzer.analyze()
            planning.set_pre_analysis_results(pre_analysis_results)
            
            # Distribution des weekend
            logger.info("\nDISTRIBUTION DES WEEKEND")
            weekend_success = self.distribute_weekend(planning)
            if not weekend_success:
                logger.warning("Distribution des weekend incomplète")
            
            return planning
            
        except Exception as e:
            logger.error(f"Erreur lors de la génération du planning: {e}")
            return None

    def generate_weekday_planning(self, planning: Planning) -> Optional[Planning]:
        """
        Génération du planning de semaine après validation des weekends.
        """
        try:
            if not planning:
                logger.error("Planning non initialisé")
                return None
                
            logger.info("\nGÉNÉRATION DU PLANNING DE SEMAINE")
            logger.info("=" * 80)
            
            # Créer le générateur de planning semaine
            weekday_generator = WeekdayGenerator(
                self.doctors,
                self.cats,
                planning,
                self.post_configuration
            )
            
            # Réinitialiser l'état pour une nouvelle génération
            weekday_generator.full_weekday_reset()
            
            # Distribution des NL de semaine
            if not weekday_generator.distribute_weekday_nl():
                logger.error("Échec distribution NL semaine")
                return planning
                
            # Distribution des NA/NM/NC de semaine
            if not weekday_generator.distribute_weekday_nanm():
                logger.error("Échec distribution NA/NM/NC semaine")
                return planning
                
            # Distribution des combinaisons de semaine
            if not weekday_generator.distribute_weekday_combinations():
                logger.error("Échec distribution combinaisons semaine")
                return planning
                
            # Distribution des autres postes de semaine
            if not weekday_generator.distribute_remaining_weekday_posts():
                logger.error("Échec distribution postes restants semaine")
                return planning
                
            # Mise à jour des statistiques
            pre_analyzer = PlanningPreAnalyzer(self.doctors, self.cats, self.post_configuration)
            pre_analyzer.set_date_range(planning.start_date, planning.end_date)
            pre_analysis_results = pre_analyzer.analyze()
            planning.set_pre_analysis_results(pre_analysis_results)
            
            return planning
            
        except Exception as e:
            logger.error(f"Erreur lors de la génération du planning de semaine: {e}")
            return planning
            
    def distribute_weekend(self, planning: Planning) -> bool:
        """Distribution complète des postes de weekend"""
        pre_analysis = planning.pre_analysis_results
        
        try:
            # 1. Distribution des NL weekend
            logger.info("\nDISTRIBUTION NL WEEKEND")
            nl_success = self.distribute_nlw(planning, pre_analysis)
            if not nl_success:
                logger.warning("Distribution des NL weekend incomplète")
            
            # 2. Distribution des NAMw - continuer même si incomplète
            logger.info("\nDISTRIBUTION NAMw")
            nam_success = self.distribute_namw(planning, pre_analysis)
            if not nam_success:
                logger.warning("Distribution NAMw incomplète - continuation avec postes restants")
            
            # 3. Distribution des combinaisons aux CAT
            logger.info("\nDISTRIBUTION COMBINAISONS CAT WEEKEND")
            cat_success = self._distribute_cat_weekend_combinations(planning)
            if not cat_success:
                logger.warning("Distribution des combinaisons CAT weekend incomplète")
            
            # 4. Distribution des combinaisons aux médecins
            logger.info("\nDISTRIBUTION COMBINAISONS MÉDECINS WEEKEND")
            med_success = self._distribute_doctor_weekend_combinations(planning)
            if not med_success:
                logger.warning("Distribution des combinaisons médecins weekend incomplète")
            
            # 5. Distribution des postes restants
            logger.info("\nDISTRIBUTION DES POSTES RESTANTS WEEKEND")
            remaining_success = self.distribute_remaining_weekend_posts(planning)
            if not remaining_success:
                logger.warning("Distribution des postes restants weekend incomplète")
            
           
            
            # Retourner True pour continuer le processus
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution weekend: {e}", exc_info=True)
            return False

   
    

    
    def distribute_nlw(self, planning: Planning, pre_analysis) -> bool:
        """Distribution des NL weekend en utilisant directement les résultats du pre_analyzer"""
        try:
            logger.info("\nDISTRIBUTION DES NL WEEKEND")
            logger.info("=" * 80)
            
            # 1. Récupération des totaux pour les CAT depuis pre_analysis["cat_posts"]
            cat_count = len(self.cats)
            cat_nlv = pre_analysis["cat_posts"]["weekday"].get("NLv", 0) 
            cat_nls = pre_analysis["cat_posts"]["saturday"].get("NL", 0)
            cat_nld = pre_analysis["cat_posts"]["sunday_holiday"].get("NL", 0)
            
            cat_totals = {
                "NLv": cat_nlv * cat_count,
                "NLs": cat_nls * cat_count,
                "NLd": cat_nld * cat_count
            }
            cat_total = sum(cat_totals.values())
            
            # 2. Récupération des totaux ajustés pour les médecins depuis pre_analysis["adjusted_posts"]
            med_nlv = pre_analysis["adjusted_posts"]["weekday_groups"]["NLv"]
            med_nlw = pre_analysis["adjusted_posts"]["weekend_groups"]["NLw"]
            
            # Les NLs et NLd sont déjà calculés dans pre_analysis
            med_nls = pre_analysis["adjusted_posts"]["saturday"]["NL"]
            med_nld = pre_analysis["adjusted_posts"]["sunday_holiday"]["NL"]
            
            med_totals = {
                "NLv": med_nlv,
                "NLs": med_nls,
                "NLd": med_nld
            }
            med_total = sum(med_totals.values())
            
            # Log des totaux à distribuer
            logger.info("\nTOTAUX CAT À DISTRIBUER:")
            logger.info(f"NLv: {cat_totals['NLv']} ({cat_nlv}/CAT)")
            logger.info(f"NLs: {cat_totals['NLs']} ({cat_nls}/CAT)")
            logger.info(f"NLd: {cat_totals['NLd']} ({cat_nld}/CAT)")
            logger.info(f"Total: {cat_total}")
            
            logger.info("\nTOTAUX MÉDECINS À DISTRIBUER:")
            logger.info(f"NLv: {med_totals['NLv']}")
            logger.info(f"NLs: {med_totals['NLs']}")
            logger.info(f"NLd: {med_totals['NLd']}")
            logger.info(f"Total NLw: {med_nlw}")
            
            # Vérification de la cohérence des totaux
            if med_nlw != sum(med_totals.values()):
                logger.error("Incohérence dans les totaux médecins: "
                            f"NLw ({med_nlw}) ≠ NLv+NLs+NLd ({sum(med_totals.values())})")
                return False
                
            # Créer les slots une seule fois et les partager
            nl_slots = self._create_nl_distribution_map(planning)
            
            # Vérification de disponibilité
            for nl_type in ["NLv", "NLs", "NLd"]:
                total_needed = cat_totals[nl_type] + med_totals[nl_type]
                available = len(nl_slots[nl_type])
                
                logger.info(f"\nVérification {nl_type}:")
                logger.info(f"Requis : {total_needed} slots")
                logger.info(f"Disponible : {available} slots")
                
                if available < total_needed:
                    logger.error(f"Pas assez de slots {nl_type} disponibles.")
                    return False
                    
            # Distribution aux CAT avec les slots partagés
            if not self._distribute_nl_to_cats(planning, 
                                            cat_totals["NLv"],
                                            cat_totals["NLs"], 
                                            cat_totals["NLd"],
                                            nl_slots):  # Nouveau paramètre
                return False
                
            # Distribution aux médecins - Corrigé pour passer nl_slots
            if not self._distribute_nl_to_doctors(planning,
                                                med_totals["NLv"],
                                                med_totals["NLs"],
                                                med_totals["NLd"],
                                                pre_analysis):  # Retirer nl_slots ici
                logger.error("Échec de la distribution des NL aux médecins")
                return False
                
            # 7. Vérification finale
            verification_data = {
                'cats': {
                    'total': cat_total,
                    'NLv': cat_totals["NLv"],
                    'NLs': cat_totals["NLs"],
                    'NLd': cat_totals["NLd"]
                },
                'doctors': {
                    'total': med_nlw,
                    'NLv': med_totals["NLv"],
                    'NLs': med_totals["NLs"],
                    'NLd': med_totals["NLd"]
                }
            }
            
            self._verify_nl_distribution(planning, verification_data)
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution NLw: {e}", exc_info=True)
            return False

    def _create_nl_distribution_map(self, planning):
        """
        Crée un dictionnaire organisé des slots NL déjà créés
        Assure que seuls les Vendredis, Samedis, et Dimanches/Fériés/Ponts soient inclus
        """
        nl_slots = {
            "NLv": [],  # UNIQUEMENT les vendredis non fériés/pont
            "NLs": [],  # UNIQUEMENT les samedis non fériés/pont
            "NLd": []   # Dimanches + tous les jours fériés/pont
        }

        for day in planning.days:
            # Ne traiter que les slots NL non assignés
            nl_slots_day = [slot for slot in day.slots if slot.abbreviation == "NL" and not slot.assignee]
            
            # Déterminer le type de jour précisément
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)
            weekday = day.date.weekday()

            # Distribution stricte selon le type de jour
            if weekday == 4 and not (day_type == "sunday_holiday" or is_bridge):
                # Uniquement les vendredis normaux
                nl_slots["NLv"].extend((day, slot) for slot in nl_slots_day)
            
            elif weekday == 5 and not (day_type == "sunday_holiday" or is_bridge):
                # Uniquement les samedis normaux
                nl_slots["NLs"].extend((day, slot) for slot in nl_slots_day)
            
            elif weekday == 6 or day_type == "sunday_holiday" or is_bridge:
                # Dimanches + tous les jours fériés/pont
                nl_slots["NLd"].extend((day, slot) for slot in nl_slots_day)


        # Log de vérification
        logger.debug("\nVérification des slots NL collectés:")
        for nl_type, slots in nl_slots.items():
            logger.debug(f"{nl_type}: {len(slots)} slots")

        return nl_slots
    
    

    def _distribute_nl_to_cats(self, planning: Planning, nlv_total: int, nls_total: int, nld_total: int, nl_slots: Dict) -> bool:
        try:
            logger.info("Distribution NL aux CAT")
            cat_counts = {
                cat.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0, "total": 0
                } for cat in self.cats
            }

            # Calculer les quotas par CAT
            cat_count = len(self.cats)
            quotas = {
                "NLv": nlv_total // cat_count,
                "NLs": nls_total // cat_count,
                "NLd": nld_total // cat_count
            }

            # Priorité à la distribution équitable
            for nl_type in ["NLv", "NLs", "NLd"]:
                quota = quotas[nl_type]
                available_slots = nl_slots[nl_type].copy()
                random.shuffle(available_slots)

                # Première passe : distribution égale garantie
                for cat in self.cats:
                    slots_needed = quota
                    slots_assigned = 0
                    
                    while slots_assigned < slots_needed and available_slots:
                        day, slot = available_slots[0]
                        if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                            slot.assignee = cat.name
                            cat_counts[cat.name][nl_type] += 1
                            cat_counts[cat.name]["total"] += 1
                            available_slots.pop(0)
                            slots_assigned += 1
                        else:
                            available_slots.pop(0)
                            continue

                    if slots_assigned < slots_needed:
                        logger.warning(f"Impossible d'atteindre le quota {nl_type} pour {cat.name} "
                                    f"({slots_assigned}/{slots_needed})")

            # Vérification des totaux
            total_assigned = sum(counts["total"] for counts in cat_counts.values())
            total_expected = sum(quotas.values()) * cat_count

            if total_assigned != total_expected:
                logger.warning(f"Distribution inégale des NL pour les CAT: "
                            f"Attendu {total_expected}, Obtenu {total_assigned}")

            return True

        except Exception as e:
            logger.error(f"Erreur distribution CAT: {e}", exc_info=True)
            return False

    def _distribute_nl_to_doctors(self, planning: Planning, nlv_total: int, nls_total: int, nld_total: int, pre_analysis: dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NL AUX MÉDECINS")
            logger.info("=" * 60)

            # Vérifier et logger les intervalles exacts
            nlw_distribution = pre_analysis["ideal_distribution"]
            max_plein_temps = 4  # Fixé d'après la pré-analyse
            max_mi_temps = 2     # Fixé d'après la pré-analyse
            
            logger.info("Intervalles de distribution NL:")
            logger.info(f"Plein temps: [3-{max_plein_temps}]")
            logger.info(f"Mi-temps: [1-{max_mi_temps}]")

            # Initialisation des compteurs
            doctor_nl_counts = {
                doctor.name: {
                    "NLv": 0, "NLs": 0, "NLd": 0,
                    "total": 0,
                    "max": max_plein_temps if doctor.half_parts == 2 else max_mi_temps,
                    "min": 3 if doctor.half_parts == 2 else 1
                } for doctor in self.doctors
            }

            # Slots disponibles
            available_slots = self._create_nl_distribution_map(planning)
            logger.info("\nSlots disponibles au début:")
            for nl_type, slots in available_slots.items():
                logger.info(f"{nl_type}: {len(slots)} slots")

            # Liste des médecins dans un ordre aléatoire
            all_doctors = self.doctors.copy()
            random.shuffle(all_doctors)
            max_failed_attempts = 5

            # Phase 1: Distribution du minimum à tous les médecins
            logger.info("\nPHASE 1: Distribution du minimum à tous les médecins")
            logger.info("=" * 50)

            for doctor in all_doctors:
                min_nlw = doctor_nl_counts[doctor.name]["min"]
                logger.info(f"\nDistribution pour {doctor.name} (minimum: {min_nlw}, maximum: {doctor_nl_counts[doctor.name]['max']})")
                

                failed_attempts = 0
                while doctor_nl_counts[doctor.name]["total"] < min_nlw:
                    # Vérifier la disponibilité des slots
                    if not any(len(slots) > 0 for slots in available_slots.values()):
                        logger.warning(f"Plus aucun slot disponible pour {doctor.name}")
                        break

                    # Choix aléatoire du type de NL
                    nl_type = self._distribute_nl_type_randomly(
                        doctor,
                        available_slots,
                        doctor_nl_counts[doctor.name]
                    )

                    if not nl_type:
                        failed_attempts += 1
                        if failed_attempts >= max_failed_attempts:
                            logger.warning(f"{doctor.name}: Abandon après {failed_attempts} échecs consécutifs")
                            break
                        continue

                    success = self._try_assign_nl_slot(
                        doctor,
                        available_slots[nl_type],
                        planning,
                        doctor_nl_counts[doctor.name],
                        nl_type
                    )

                    if success:
                        failed_attempts = 0
                        logger.info(f"{doctor.name}: {nl_type} attribué ({doctor_nl_counts[doctor.name]['total']}/{min_nlw})")
                    else:
                        failed_attempts += 1
                        if failed_attempts >= max_failed_attempts:
                            logger.warning(f"{doctor.name}: Abandon après {failed_attempts} échecs consécutifs")
                            break

             # Phase 2: Distribution du reste dans la limite des maximums stricts
            while any(len(slots) > 0 for slots in available_slots.values()):
                random.shuffle(all_doctors)
                assigned = False

                for doctor in all_doctors:
                    current_count = doctor_nl_counts[doctor.name]["total"]
                    max_allowed = doctor_nl_counts[doctor.name]["max"]
                    
                    # Vérification stricte du maximum
                    if current_count >= max_allowed:
                        continue

                    nl_type = self._distribute_nl_type_randomly(
                        doctor, 
                        available_slots,
                        doctor_nl_counts[doctor.name]
                    )
                    
                    if not nl_type:
                        continue

                    # Vérification supplémentaire avant l'assignation
                    if current_count + 1 > max_allowed:
                        logger.debug(f"Attribution impossible pour {doctor.name}: dépasserait le maximum ({max_allowed})")
                        continue

                    success = self._try_assign_nl_slot(
                        doctor,
                        available_slots[nl_type],
                        planning,
                        doctor_nl_counts[doctor.name],
                        nl_type
                    )
                    
                    if success:
                        assigned = True
                        logger.info(f"{doctor.name}: {nl_type} attribué (total: {doctor_nl_counts[doctor.name]['total']}/{max_allowed})")
                        break

                if not assigned:
                    logger.info("Aucune assignation possible, fin de la distribution")
                    break

            # Log des résultats finaux
            logger.info("\nRÉSULTAT FINAL DE LA DISTRIBUTION")
            logger.info("=" * 40)
            for doctor in sorted(all_doctors, key=lambda x: x.name):
                counts = doctor_nl_counts[doctor.name]
                logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
                logger.info(f"NLv: {counts['NLv']}")
                logger.info(f"NLs: {counts['NLs']}")
                logger.info(f"NLd: {counts['NLd']}")
                logger.info(f"Total: {counts['total']}")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NL: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Erreur dans la distribution NL: {e}", exc_info=True)
            return False

    def _try_assign_nl_slot(self, person, available_slots, planning, person_counts, nl_type, max_attempts=3):
        """Essaie d'assigner un slot NL avec un nombre limité de tentatives"""
        if not available_slots:
            return False

        slots_to_try = available_slots.copy()
        random.shuffle(slots_to_try)
        
        attempts = 0
        while slots_to_try and attempts < max_attempts:
            day, slot = slots_to_try.pop(0)  # Prendre et retirer le premier slot
            
            if self.constraints.can_assign_to_assignee(person, day.date, slot, planning):
                slot.assignee = person.name
                person_counts[nl_type] += 1
                person_counts["total"] += 1
                available_slots.remove((day, slot))
                logger.debug(f"Slot {nl_type} assigné à {person.name} le {day.date}")
                return True
                
            attempts += 1
        
        if attempts >= max_attempts:
            logger.debug(f"Limite de tentatives atteinte pour {person.name} sur {nl_type}")
        elif not slots_to_try:
            logger.debug(f"Plus de slots disponibles pour {person.name} sur {nl_type}")
        
        return False

    def _assign_nl_slots_to_person(self, person, quota, available_slots, planning, counts, nl_type):
        """Méthode commune pour assigner des slots à un médecin ou CAT"""
        remaining = quota
        assigned = 0
        
        while remaining > 0 and available_slots:
            success = self._try_assign_nl_slot(
                person,
                available_slots,
                planning,
                counts,
                nl_type
            )
            
            if success:
                assigned += 1
                remaining -= 1
            else:
                break
                
        if remaining > 0:
            logger.warning(f"  {person.name}: {assigned}/{quota} {nl_type} assignés")
        else:
            logger.info(f"  {person.name}: {assigned}/{quota} {nl_type} assignés")

        return assigned

    def _verify_nl_distribution(self, planning: Planning, expected_counts: Dict) -> bool:
        """
        Vérifie la distribution des NL et compare avec les totaux attendus
        """
        logger.info("\nVÉRIFICATION DE LA DISTRIBUTION NL")
        logger.info("=" * 80)
        
        actual_counts = {
            'cats': {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0},
            'doctors': {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0}
        }
        
        # Compter les NL distribués
        for day in planning.days:
            nl_slots = [slot for slot in day.slots if slot.abbreviation == "NL" and slot.assignee]
            
            # Ignorer les slots vides
            if not nl_slots:
                continue
                
            for slot in nl_slots:
                is_cat = any(cat.name == slot.assignee for cat in self.cats)
                person_type = 'cats' if is_cat else 'doctors'
                
                # Nouveau : Détection correcte du type de NL
                if day.date.weekday() == 4 and not day.is_holiday_or_bridge:  
                    # Vendredi normal
                    actual_counts[person_type]['NLv'] += 1
                elif day.date.weekday() == 5 and not day.is_holiday_or_bridge:  
                    # Samedi normal
                    actual_counts[person_type]['NLs'] += 1
                elif (day.date.weekday() == 6 or  # Dimanche
                    day.is_holiday_or_bridge or  # Jour férié ou pont
                    (day.date.weekday() == 5 and DayType.is_bridge_day(day.date, self.cal))):  # Samedi pont
                    actual_counts[person_type]['NLd'] += 1
                
                actual_counts[person_type]['total'] += 1

        
        # Comparer avec les totaux attendus
        all_match = True
        for person_type in ['cats', 'doctors']:
            logger.info(f"\n{person_type.upper()}:")
            for nl_type in ['NLv', 'NLs', 'NLd']:
                actual = actual_counts[person_type][nl_type]
                expected = expected_counts[person_type][nl_type]
                matches = actual == expected
                all_match &= matches
                
                logger.info(f"{nl_type}: {actual:3d} / {expected:3d} "
                        f"({'OK' if matches else 'ÉCART'})")
                
                # Log détaillé en cas d'écart
                if not matches:
                    logger.warning(f"Écart détecté pour {person_type} {nl_type}: "
                                f"Attendu {expected}, Obtenu {actual}")
            
            actual_total = actual_counts[person_type]['total']
            expected_total = expected_counts[person_type]['total']
            total_matches = actual_total == expected_total
            all_match &= total_matches
            
            logger.info(f"Total: {actual_total:3d} / {expected_total:3d} "
                    f"({'OK' if total_matches else 'ÉCART'})")
            
            if not total_matches:
                logger.warning(f"Écart total détecté pour {person_type}: "
                            f"Attendu {expected_total}, Obtenu {actual_total}")

        return all_match
    
    def _log_distribution_results(self, counts, quotas, person_type: str):
        """Log les résultats de distribution des NL"""
        logger.info(f"\nRÉSULTATS DISTRIBUTION {person_type}:")
        logger.info("=" * 40)
        
        for name, person_counts in sorted(counts.items()):
            logger.info(f"\n{name}:")
            total_assigned = 0
            total_quota = 0
            
            for nl_type in ["NLv", "NLs", "NLd"]:
                assigned = person_counts[nl_type]
                quota = quotas[nl_type]
                total_assigned += assigned
                total_quota += quota
                
                status = "OK" if assigned >= quota else f"MANQUE {quota - assigned}"
                logger.info(f"{nl_type}: {assigned}/{quota} ({status})")
            
            completion_rate = (total_assigned / total_quota * 100) if total_quota > 0 else 0
            logger.info(f"Total: {total_assigned}/{total_quota} ({completion_rate:.1f}%)")

    
    def _distribute_nl_type_randomly(self, doctor, available_slots, nl_counts):
        """
        Distribue les NL de manière aléatoire mais équilibrée
        """
        # Calculer les ratios actuels de chaque type de NL
        total_nl = sum(nl_counts.values())
        if total_nl == 0:
            # Premier NL : choix complètement aléatoire
            return random.choice(list(available_slots.keys()))
        
        # Calculer les ratios idéaux (environ 1/3 de chaque)
        ideal_ratio = 1/3
        
        # Calculer les écarts au ratio idéal
        ratios = {
            nl_type: count/total_nl if total_nl > 0 else 0 
            for nl_type, count in nl_counts.items()
        }
        deviations = {
            nl_type: ideal_ratio - ratio
            for nl_type, ratio in ratios.items()
        }
        
        # Ajouter un facteur aléatoire aux déviations
        random_factor = 0.2  # Facteur d'aléatoire (0.0 à 1.0)
        weighted_deviations = {
            nl_type: dev + (random.random() * random_factor)
            for nl_type, dev in deviations.items()
        }
        
        # Filtrer les types de NL disponibles
        available_types = [nl_type for nl_type, slots in available_slots.items() if slots]
        
        if not available_types:
            return None
        
        # Choisir le type avec la plus grande déviation positive + facteur aléatoire
        chosen_type = max(
            available_types,
            key=lambda x: weighted_deviations[x]
        )
        
        return chosen_type
    
    def _log_doctor_nl_distribution(self, doctor_name: str, counts: Dict):
        """Affiche la distribution actuelle des NL pour un médecin"""
        logger.info(f"\nDistribution pour {doctor_name}:")
        logger.info(f"NLv: {counts['NLv']}")
        logger.info(f"NLs: {counts['NLs']}")
        logger.info(f"NLd: {counts['NLd']}")
        logger.info(f"Total: {counts['total']}")
    
    
    
    
    
    def distribute_namw(self, planning: Planning, pre_analysis) -> bool:
        """Distribution des NA et NM du weekend suivant le même modèle que NLw"""
        try:
            logger.info("\nDISTRIBUTION NAM WEEKEND")
            logger.info("=" * 80)
            
            # 1. Récupération des totaux CAT avec le même format que NLw
            cat_count = len(self.cats)
            cat_nam = {
                "NAs": pre_analysis["cat_posts"]["saturday"].get("NA", 0),
                "NAd": pre_analysis["cat_posts"]["sunday_holiday"].get("NA", 0),
                "NMs": pre_analysis["cat_posts"]["saturday"].get("NM", 0),
                "NMd": pre_analysis["cat_posts"]["sunday_holiday"].get("NM", 0)
            }
            
            cat_totals = {k: v * cat_count for k, v in cat_nam.items()}
            cat_total = sum(cat_totals.values())
            
            # 2. Récupération des totaux médecins
            med_nam = {
                "NAs": pre_analysis["adjusted_posts"]["saturday"]["NA"],
                "NAd": pre_analysis["adjusted_posts"]["sunday_holiday"]["NA"],
                "NMs": pre_analysis["adjusted_posts"]["saturday"]["NM"],
                "NMd": pre_analysis["adjusted_posts"]["sunday_holiday"]["NM"]
            }
            med_total = sum(med_nam.values())
            med_namw = pre_analysis["adjusted_posts"]["weekend_groups"]["NAMw"]
            
            # Log des quotas comme pour NLw
            logger.info("\nTOTAUX CAT À DISTRIBUER:")
            for slot_type, count in cat_totals.items():
                logger.info(f"{slot_type}: {count} ({cat_nam[slot_type]}/CAT)")
            logger.info(f"Total: {cat_total}")
            
            logger.info("\nTOTAUX MÉDECINS À DISTRIBUER:")
            for slot_type, count in med_nam.items():
                logger.info(f"{slot_type}: {count}")
            logger.info(f"Total NAMw: {med_namw}")
            
            # 3. Vérification de cohérence comme pour NLw
            if med_namw != sum(med_nam.values()):
                logger.error("Incohérence dans les totaux médecins: "
                            f"NAMw ({med_namw}) ≠ Total NA+NM ({sum(med_nam.values())})")
                return False
            
            # Collecter les slots une seule fois
            nam_slots = self._collect_nam_slots(planning)

            # 5. Distribution aux CAT
            if not self._distribute_nam_to_cats(planning, cat_totals):  # Enlever nam_slots ici
                logger.error("Échec de la distribution des NAM aux CAT")
                return False
                
            # 7. Distribution médecins (3 phases)
            if not self._distribute_nam_to_doctors(planning, med_nam, pre_analysis):
                return False
                
           # Vérification finale
            verification_data = {
                'cats': cat_totals,
                'doctors': med_nam
            }
            
            completed = self._verify_nam_distribution(planning, verification_data)
            
            if not completed:
                logger.info("Des postes NAM restent non attribués - "
                        "ils seront traités dans la distribution finale")
                
            # Toujours retourner True pour continuer le processus
            return True
            
        except Exception as e:
            logger.error(f"Erreur dans la distribution NAMw: {e}", exc_info=True)
            return False

        
    
    def _distribute_nam_to_cats(self, planning: Planning, cat_totals: Dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NAM AUX CAT")
            logger.info("=" * 60)

            cat_counts = {
                cat.name: {
                    "NAs": 0, "NAd": 0, "NMs": 0, "NMd": 0
                } for cat in self.cats
            }

            # Récupérer les slots par type
            nam_slots = self._collect_nam_slots(planning)  # Déplacer la collecte ici

            # Pour chaque type de garde, respecter exactement les quotas
            for slot_type in ["NAs", "NAd", "NMs", "NMd"]:
                quota_per_cat = cat_totals[slot_type] // len(self.cats)
                available_slots = nam_slots[slot_type].copy()
                random.shuffle(available_slots)

                # Distribution stricte par CAT
                for cat in self.cats:
                    slots_assigned = 0
                    while slots_assigned < quota_per_cat and available_slots:
                        assigned = False
                        for slot_index in range(len(available_slots)):
                            day, slot = available_slots[slot_index]
                            if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                                slot.assignee = cat.name
                                cat_counts[cat.name][slot_type] += 1
                                available_slots.pop(slot_index)
                                slots_assigned += 1
                                assigned = True
                                break
                        if not assigned:
                            break
                    
                    if slots_assigned < quota_per_cat:
                        logger.warning(f"CAT {cat.name}: impossible d'atteindre le quota {slot_type} "
                                    f"({slots_assigned}/{quota_per_cat})")

            # Log des résultats
            self._log_nam_distribution_results(cat_counts, cat_totals, "CAT")
            return True

        except Exception as e:
            logger.error(f"Erreur distribution NAM CAT: {e}", exc_info=True)
            return False

    def _distribute_nam_to_doctors(self, planning: Planning, med_nam: Dict, pre_analysis: dict) -> bool:
        try:
            logger.info("\nDISTRIBUTION DES NAM AUX MÉDECINS")
            logger.info("=" * 60)

            # Définition des intervalles stricts
            max_plein_temps = 4  # Fixé d'après la pré-analyse
            max_mi_temps = 2     # Fixé d'après la pré-analyse
            min_plein_temps = 3
            min_mi_temps = 1

            logger.info("Intervalles de distribution NAM:")
            logger.info(f"Plein temps: [{min_plein_temps}-{max_plein_temps}]")
            logger.info(f"Mi-temps: [{min_mi_temps}-{max_mi_temps}]")

            # Initialisation des compteurs avec les limites
            doctor_counts = {
                doctor.name: {
                    "NAs": 0, "NAd": 0, "NMs": 0, "NMd": 0, "NAMw": 0,
                    "max": max_plein_temps if doctor.half_parts == 2 else max_mi_temps,
                    "min": min_plein_temps if doctor.half_parts == 2 else min_mi_temps
                } for doctor in self.doctors
            }

            # Récupération et mélange des slots disponibles
            all_slots = []
            nam_slots = self._collect_nam_slots(planning)
            for slot_type, slots in nam_slots.items():
                for slot_info in slots:
                    all_slots.append((slot_info[0], slot_info[1], slot_type))
            
            random.shuffle(all_slots)

            # Liste de tous les médecins dans un ordre aléatoire
            all_doctors = self.doctors.copy()
            random.shuffle(all_doctors)

            # Phase 1: Distribution du minimum à tous les médecins
            logger.info("\nPHASE 1: Distribution du minimum à tous les médecins")
            logger.info("=" * 50)

            for doctor in all_doctors:
                min_target = doctor_counts[doctor.name]["min"]
                logger.info(f"\nDistribution pour {doctor.name} (minimum: {min_target}, maximum: {doctor_counts[doctor.name]['max']})")

                while doctor_counts[doctor.name]["NAMw"] < min_target and all_slots:
                    assigned = False
                    for slot_index in range(len(all_slots)):
                        day, slot, slot_type = all_slots[slot_index]
                        if self.constraints.can_assign_to_assignee(doctor, day.date, slot, planning):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name][slot_type] += 1
                            doctor_counts[doctor.name]["NAMw"] += 1
                            all_slots.pop(slot_index)
                            assigned = True
                            logger.info(f"{doctor.name}: {slot_type} attribué (total: {doctor_counts[doctor.name]['NAMw']}/{min_target})")
                            break
                    if not assigned:
                        logger.warning(f"Impossible d'atteindre le minimum pour {doctor.name}")
                        break

            # Phase 2: Distribution du reste dans la limite des maximums
            logger.info("\nPHASE 2: Distribution du reste aux médecins")
            logger.info("=" * 50)

            while all_slots:
                random.shuffle(all_doctors)
                assigned = False

                for doctor in all_doctors:
                    current_count = doctor_counts[doctor.name]["NAMw"]
                    max_allowed = doctor_counts[doctor.name]["max"]

                    # Vérification stricte du maximum
                    if current_count >= max_allowed:
                        continue

                    # Vérification supplémentaire avant l'assignation
                    if current_count + 1 > max_allowed:
                        continue

                    # Tenter l'assignation
                    for slot_index in range(len(all_slots)):
                        day, slot, slot_type = all_slots[slot_index]
                        if self.constraints.can_assign_to_assignee(doctor, day.date, slot, planning):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name][slot_type] += 1
                            doctor_counts[doctor.name]["NAMw"] += 1
                            all_slots.pop(slot_index)
                            assigned = True
                            logger.info(f"{doctor.name}: {slot_type} attribué (total: {doctor_counts[doctor.name]['NAMw']}/{max_allowed})")
                            break

                if not assigned:
                    logger.info("Aucune assignation possible, fin de la distribution")
                    break

            # Log des résultats finaux
            logger.info("\nRÉSULTAT FINAL DE LA DISTRIBUTION")
            logger.info("=" * 40)
            for doctor in sorted(all_doctors, key=lambda x: x.name):
                counts = doctor_counts[doctor.name]
                logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
                logger.info(f"NAs: {counts['NAs']}")
                logger.info(f"NAd: {counts['NAd']}")
                logger.info(f"NMs: {counts['NMs']}")
                logger.info(f"NMd: {counts['NMd']}")
                logger.info(f"Total NAMw: {counts['NAMw']}")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NAM: {e}", exc_info=True)
            return False
        
    def _collect_nam_slots(self, planning: Planning) -> Dict:
        """Collecte tous les slots NA et NM disponibles"""
        nam_slots = {
            "NAs": [],  # NA samedi
            "NAd": [],  # NA dimanche/férié/pont
            "NMs": [],  # NM samedi
            "NMd": []   # NM dimanche/férié/pont
        }

        for day in planning.days:
            slots_available = [slot for slot in day.slots 
                            if slot.abbreviation in ["NA", "NM"] and not slot.assignee]
            
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)

            for slot in slots_available:
                if day_type == "sunday_holiday" or is_bridge:
                    suffix = "d"  # dimanche/férié/pont
                elif day.date.weekday() == 5 and not is_bridge:
                    suffix = "s"  # samedi normal
                else:
                    continue  # Ignorer les autres jours

                slot_type = f"{slot.abbreviation}{suffix}"
                nam_slots[slot_type].append((day, slot))

        return nam_slots

    def _try_assign_nam_slot(self, person, available_slots, planning, person_counts, nam_type, max_attempts=3):
        """Version NAM de _try_assign_nl_slot"""
        if not available_slots:
            return False

        slots_to_try = available_slots.copy()
        random.shuffle(slots_to_try)
        
        attempts = 0
        while slots_to_try and attempts < max_attempts:
            day, slot = slots_to_try.pop(0)
            
            if self.constraints.can_assign_to_assignee(person, day.date, slot, planning):
                slot.assignee = person.name
                person_counts[nam_type] += 1
                person_counts["total" if "total" in person_counts else "NAMw"] += 1
                available_slots.remove((day, slot))
                logger.debug(f"Slot {nam_type} assigné à {person.name} le {day.date}")
                return True
                
            attempts += 1
        
        return False
    
    def _assign_nam_slots_to_person(self, person, quota, available_slots, planning, counts, slot_type):
        """Méthode commune pour assigner des slots NAM à un médecin ou CAT"""
        remaining = quota
        assigned = 0
        
        while remaining > 0 and available_slots:
            success = self._try_assign_nam_slot(
                person,
                available_slots,
                planning,
                counts,
                slot_type
            )
            
            if success:
                assigned += 1
                remaining -= 1
            else:
                break
                
            # Log des résultats
            if remaining > 0:
                logger.warning(f"  {person.name}: {assigned}/{quota} {slot_type} assignés")
            else:
                logger.info(f"  {person.name}: {assigned}/{quota} {slot_type} assignés")

        return assigned

    def _distribute_nam_type_randomly(self, doctor, available_slots, nam_counts):
        """Version NAM de _distribute_nl_type_randomly"""
        # Calcul des ratios pour NA et NM séparément
        total_na = nam_counts.get("NAs", 0) + nam_counts.get("NAd", 0)
        total_nm = nam_counts.get("NMs", 0) + nam_counts.get("NMd", 0)
        total = total_na + total_nm
        
        if total == 0:
            # Premier choix : complètement aléatoire
            available_types = [t for t, slots in available_slots.items() if slots]
            return random.choice(available_types) if available_types else None
        
        # Calculer les ratios idéaux (équilibre entre NA et NM)
        ideal_ratio = 0.5
        
        # Calculer les déviations actuelles
        na_ratio = total_na / total if total > 0 else 0
        nm_ratio = total_nm / total if total > 0 else 0
        
        # Ajouter un facteur aléatoire
        random_factor = 0.2
        weighted_deviations = {
            "NA": (ideal_ratio - na_ratio) + (random.random() * random_factor),
            "NM": (ideal_ratio - nm_ratio) + (random.random() * random_factor)
        }
        
        # Choisir entre NA et NM
        prefer_na = weighted_deviations["NA"] > weighted_deviations["NM"]
        
        # Filtrer les types disponibles
        available_types = []
        for t, slots in available_slots.items():
            if not slots:
                continue
            if prefer_na and t.startswith("NA"):
                available_types.append(t)
            elif not prefer_na and t.startswith("NM"):
                available_types.append(t)
        
        return random.choice(available_types) if available_types else None

    def _log_nam_distribution_results(self, counts, quotas, person_type: str, ranges: Dict = None):
        """Log unifié et concis des résultats de distribution NAM"""
        logger.info(f"\nRÉSULTATS DISTRIBUTION {person_type} NAM WEEKEND")
        logger.info("=" * 80)

        # En-têtes adaptés selon le type de personne (CAT ou Médecin)
        if person_type == "CAT":
            headers = ["Nom", "NA(s/d)", "NM(s/d)", "Total", "Quota", "Statut"]
        else:
            headers = ["Médecin", "NA(s/d)", "NM(s/d)", "Total", "Cible", "Statut"]

        # Affichage des en-têtes
        logger.info(f"{headers[0]:<15} {headers[1]:<12} {headers[2]:<12} {headers[3]:<8} {headers[4]:<10} {headers[5]}")
        logger.info("-" * 80)

        for name, person_counts in sorted(counts.items()):
            # Calcul des totaux NA et NM
            na_total = person_counts.get("NAs", 0) + person_counts.get("NAd", 0)
            nm_total = person_counts.get("NMs", 0) + person_counts.get("NMd", 0)
            total = na_total + nm_total

            # Format compact pour NA et NM
            na_str = f"{na_total}({person_counts.get('NAs',0)}/{person_counts.get('NAd',0)})"
            nm_str = f"{nm_total}({person_counts.get('NMs',0)}/{person_counts.get('NMd',0)})"

            # Détermination du statut selon le type
            if person_type == "CAT":
                quota_total = sum(quotas.values())
                status = "OK" if total >= quota_total else f"MANQUE {quota_total - total}"
                target = f"{quota_total}"
            else:
                range_info = ranges.get(name, {"min": 0, "max": 0})
                target = f"[{range_info['min']}-{range_info['max']}]"
                if total < range_info["min"]:
                    status = "SOUS MIN"
                elif total > range_info["max"]:
                    status = "SUR MAX"
                else:
                    status = "OK"

            # Affichage de la ligne
            logger.info(f"{name:<15} {na_str:<12} {nm_str:<12} {total:<8} {target:<10} {status}")

        # Affichage du résumé uniquement en cas d'écarts
        ecarts = sum(1 for _, counts in counts.items() if "MANQUE" in counts or "SOUS" in counts or "SUR" in counts)
        if ecarts > 0:
            logger.info("\nRésumé des écarts :")
            for name, person_counts in counts.items():
                if "MANQUE" in person_counts or "SOUS" in person_counts or "SUR" in person_counts:
                    logger.warning(f"{name}: {person_counts['status']}")

    def _verify_nam_distribution(self, planning: Planning, expected_counts: Dict) -> bool:
        """Vérification concise de la distribution NAM"""
        logger.info("\nVÉRIFICATION DISTRIBUTION NAM")
        logger.info("=" * 60)

        actual_counts = {
            'cats': {'NAs': 0, 'NAd': 0, 'NMs': 0, 'NMd': 0},
            'doctors': {'NAs': 0, 'NAd': 0, 'NMs': 0, 'NMd': 0}
        }

        # Compter les NAM distribués
        for day in planning.days:
            day_type = DayType.get_day_type(day.date, self.cal)
            is_bridge = DayType.is_bridge_day(day.date, self.cal)
            
            for slot in day.slots:
                if slot.abbreviation not in ["NA", "NM"] or not slot.assignee:
                    continue
                    
                is_cat = any(cat.name == slot.assignee for cat in self.cats)
                person_type = 'cats' if is_cat else 'doctors'
                
                if day_type == "sunday_holiday" or is_bridge:
                    suffix = "d"
                elif day.date.weekday() == 5 and not is_bridge:
                    suffix = "s"
                else:
                    continue
                    
                slot_type = f"{slot.abbreviation}{suffix}"
                actual_counts[person_type][slot_type] += 1

        # Affichage en format tableau
        headers = ["Type", "NAs", "NAd", "NMs", "NMd", "Total", "Attendu", "Statut"]
        logger.info(f"{headers[0]:<10} {headers[1]:>5} {headers[2]:>5} {headers[3]:>5} {headers[4]:>5} {headers[5]:>7} {headers[6]:>8} {headers[7]}")
        logger.info("-" * 65)

        all_match = True
        for person_type in ['cats', 'doctors']:
            actual = actual_counts[person_type]
            expected = expected_counts[person_type]
            
            actual_total = sum(actual.values())
            expected_total = sum(expected.values())
            
            status = "OK" if actual_total == expected_total else "ÉCART"
            all_match &= actual_total == expected_total
            
            logger.info(f"{person_type:<10} {actual['NAs']:>5} {actual['NAd']:>5} {actual['NMs']:>5} {actual['NMd']:>5} "
                    f"{actual_total:>7} {expected_total:>8} {status}")

            # Log des écarts si présents
            if actual_total != expected_total:
                for slot_type in ['NAs', 'NAd', 'NMs', 'NMd']:
                    if actual[slot_type] != expected[slot_type]:
                        logger.warning(f"  {slot_type}: Attendu={expected[slot_type]}, Obtenu={actual[slot_type]}")

        return all_match
    
    
 



    def _get_critical_weekend_periods(self, planning: Planning) -> List[date]:
        """Identifie les périodes critiques du weekend basées sur les disponibilités des médecins"""
        critical_dates = []
        weekend_dates = self._get_weekend_dates(planning)
        
        for current_date in weekend_dates:
            # Compter les médecins disponibles pour cette date
            available_doctors = 0
            for doctor in self.doctors:
                if not any(
                    desiderata.start_date <= current_date <= desiderata.end_date 
                    for desiderata in doctor.desiderata
                ):
                    available_doctors += 1
            
            # Calculer le pourcentage de médecins disponibles
            availability_percentage = (available_doctors / len(self.doctors)) * 100
            
            # Si moins de 50% des médecins sont disponibles, c'est une période critique
            if availability_percentage < 65:
                critical_dates.append({
                    'date': current_date,
                    'availability': availability_percentage
                })
        
        # Trier les dates par ordre croissant de disponibilité
        critical_dates.sort(key=lambda x: x['availability'])
        
        logger.info("\nPÉRIODES CRITIQUES IDENTIFIÉES:")
        for period in critical_dates:
            logger.info(f"Date: {period['date'].strftime('%Y-%m-%d')} - "
                    f"Disponibilité: {period['availability']:.1f}%")
        
        return critical_dates

    def _distribute_cat_weekend_combinations(self, planning: Planning) -> bool:
        """Distribution des combinaisons weekend pour les CAT en incluant les postes personnalisés"""
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS WEEKEND AUX CAT")
            logger.info("=" * 60)

            # Identifier les périodes critiques
            critical_periods = self._get_critical_weekend_periods(planning)
            critical_dates = [period['date'] for period in critical_periods]

            # Organiser les dates
            weekend_dates = {
                "saturday": [],
                "sunday": []
            }
            
            # Séparer les dates normales des dates critiques
            normal_dates = []
            for date in self._get_weekend_dates(planning):
                if date not in critical_dates:
                    if date.weekday() == 5 and not self.is_bridge_day(date):
                        weekend_dates["saturday"].append(date)
                    else:
                        weekend_dates["sunday"].append(date)
                else:
                    normal_dates.append(date)

            day_type_mapping = {
                "saturday": "saturday",
                "sunday": "sunday_holiday"
            }

            for cat in self.cats:
                logger.info(f"\nAnalyse des combinaisons pour {cat.name}:")
                
                # Récupérer toutes les combinaisons possibles (standards + personnalisées)
                combinations = self._get_cat_possible_combinations(cat, planning)
                logger.debug(f"Combinaisons disponibles pour {cat.name}: {combinations}")
                
                used_posts = {
                    "saturday": defaultdict(int),
                    "sunday": defaultdict(int)
                }
                assignments = {
                    "saturday": defaultdict(int),
                    "sunday": defaultdict(int)
                }

                # 1. Traiter d'abord les périodes critiques
                for critical_date in critical_dates:
                    day_type = "saturday" if critical_date.weekday() == 5 and not self.is_bridge_day(critical_date) else "sunday"
                    
                    if not self._is_cat_available_for_date(cat, critical_date, planning):
                        continue

                    self._try_assign_cat_combination(
                        cat, critical_date, day_type, combinations,
                        used_posts, assignments, planning,
                        is_critical=True
                    )

                # 2. Traiter ensuite les autres dates
                for day_type, dates in weekend_dates.items():
                    dates_to_process = dates.copy()
                    random.shuffle(dates_to_process)

                    for date in dates_to_process:
                        if not self._is_cat_available_for_date(cat, date, planning):
                            continue

                        self._try_assign_cat_combination(
                            cat, date, day_type, combinations,
                            used_posts, assignments, planning,
                            is_critical=False
                        )

                # Log des résultats
                self._log_cat_weekend_distribution(cat, used_posts, assignments, combinations, planning)

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution CAT weekend: {e}", exc_info=True)
            return False

    def _try_assign_cat_combination(self, cat: CAT, date: date, day_type: str,
                            combinations: Dict, used_posts: Dict, assignments: Dict,
                            planning: Planning, is_critical: bool) -> bool:
        """Tente d'attribuer une combinaison pour une date donnée"""
        pre_analysis_day_type = "saturday" if day_type == "saturday" else "sunday_holiday"
        quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_day_type]

        available_combinations = []
        for combo, max_count in combinations[day_type]:
            # Vérifier si c'est une combinaison de poste personnalisé
            is_custom = combo in sum([list(p.possible_combinations.values()) 
                                    for p in self.custom_posts.values()], [])
            
            if is_custom:
                # Récupérer les postes de la combinaison à partir du nom du combo
                for custom_post in self.custom_posts.values():
                    if combo in custom_post.possible_combinations.values():
                        for post, combo_name in custom_post.possible_combinations.items():
                            if combo_name == combo:
                                first_post = custom_post.name
                                second_post = post
                                break
            else:
                first_post, second_post = combo[:2], combo[2:]

            if (used_posts[day_type][first_post] < quotas.get(first_post, 0) and
                used_posts[day_type][second_post] < quotas.get(second_post, 0) and
                assignments[day_type][combo] < max_count and
                self._can_assign_cat_combination(cat, combo, date, planning)):
                available_combinations.append(combo)

        if available_combinations:
            weighted_combinations = []
            for combo in available_combinations:
                weight = (max_count + 1 - assignments[day_type][combo])
                if is_critical:
                    weight *= 2
                weighted_combinations.extend([combo] * weight)

            if weighted_combinations:
                combo = random.choice(weighted_combinations)
                if self._assign_combination_to_cat(cat, combo, date, planning):
                    if combo in sum([list(p.possible_combinations.values()) 
                                for p in self.custom_posts.values()], []):
                        # Trouver les postes pour la combinaison personnalisée
                        for custom_post in self.custom_posts.values():
                            if combo in custom_post.possible_combinations.values():
                                for post, combo_name in custom_post.possible_combinations.items():
                                    if combo_name == combo:
                                        first_post = custom_post.name
                                        second_post = post
                                        break
                    else:
                        first_post, second_post = combo[:2], combo[2:]

                    used_posts[day_type][first_post] += 1
                    used_posts[day_type][second_post] += 1
                    assignments[day_type][combo] += 1
                    logger.info(f"{cat.name}: {combo} attribué pour {date} "
                            f"({day_type}) {'[CRITIQUE]' if is_critical else ''}")
                    return True

        return False

    def _get_weekend_dates(self, planning: Planning) -> List[date]:
        weekend_dates = []
        current_date = planning.start_date
        
        while current_date <= planning.end_date:
            if (current_date.weekday() >= 5 or
                self.cal.is_holiday(current_date) or
                self.is_bridge_day(current_date)):
                weekend_dates.append(current_date)
            current_date += timedelta(days=1)
        
        return weekend_dates

    def _can_assign_cat_combination(self, cat: CAT, combo: str, date: date, planning: Planning) -> bool:
        """Vérifie si une combinaison peut être attribuée à un CAT pour une date donnée"""
        # Récupérer les slots pour la date
        day = planning.get_day(date)
        if not day:
            return False

        # Vérifier si c'est une combinaison de poste personnalisé
        is_custom_combo = any(combo in post.possible_combinations.values() 
                            for post in self.custom_posts.values())

        if is_custom_combo:
            # Trouver les postes impliqués dans la combinaison personnalisée
            first_post = None
            second_post = None
            for custom_post in self.custom_posts.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        first_post = custom_post.name
                        second_post = post
                        break
                if first_post:
                    break
        else:
            # Combinaison standard
            first_post, second_post = combo[:2], combo[2:]

        if not (first_post and second_post):
            logger.error(f"Impossible de déterminer les postes pour la combinaison {combo}")
            return False

        # Vérifier la disponibilité des slots
        first_slot = next((s for s in day.slots if s.abbreviation == first_post and not s.assignee), None)
        second_slot = next((s for s in day.slots if s.abbreviation == second_post and not s.assignee), None)

        if not (first_slot and second_slot):
            logger.debug(f"Slots non disponibles pour {combo} le {date}")
            return False

        # Vérifier les contraintes pour chaque slot
        can_assign = (self.constraints.can_assign_to_assignee(cat, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, planning))
        
        if can_assign:
            logger.debug(f"Combinaison {combo} possible pour {cat.name} le {date}")
        
        return can_assign

    def _assign_combination_to_cat(self, cat: CAT, combo: str, date: date, planning: Planning) -> bool:
        """Attribution d'une combinaison à un CAT"""
        try:
            day = planning.get_day(date)
            if not day:
                return False

            # Vérifier si c'est une combinaison personnalisée
            is_custom_combo = any(combo in post.possible_combinations.values() 
                                for post in self.custom_posts.values())

            if is_custom_combo:
                # Trouver les postes impliqués
                first_post = None
                second_post = None
                for custom_post in self.custom_posts.values():
                    for post, combo_name in custom_post.possible_combinations.items():
                        if combo_name == combo:
                            first_post = custom_post.name
                            second_post = post
                            break
                    if first_post:
                        break
            else:
                first_post, second_post = combo[:2], combo[2:]

            if not (first_post and second_post):
                logger.error(f"Impossible de déterminer les postes pour la combinaison {combo}")
                return False

            # Trouver les slots non assignés
            first_slot = next((s for s in day.slots if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots if s.abbreviation == second_post and not s.assignee), None)

            if not (first_slot and second_slot):
                logger.debug(f"Slots non disponibles pour {combo} le {date}")
                return False

            # Vérifier les contraintes
            if not (self.constraints.can_assign_to_assignee(cat, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, planning)):
                return False

            # Assigner les slots
            first_slot.assignee = cat.name
            second_slot.assignee = cat.name

            logger.info(f"Attribution réussie: {combo} ({first_post}+{second_post}) à {cat.name} pour {date}")
            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution de {combo} à {cat.name}: {e}")
            return False

    def _get_cat_possible_combinations(self, cat: CAT, planning: Planning) -> Dict[str, List[Tuple[str, int]]]:
        """Détermine les combinaisons possibles pour un CAT"""
        combinations = {"saturday": [], "sunday": []}
        
        # Récupérer les quotas pour chaque type de jour
        for day_type, pre_analysis_key in [("saturday", "saturday"), ("sunday", "sunday_holiday")]:
            quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_key]
            
            # Debug des quotas disponibles
            logger.debug(f"Quotas {day_type} pour {cat.name}: {quotas}")

            # Ajouter les combinaisons standards
            for combo in WEEKEND_COMBINATIONS:
                first_post, second_post = combo[:2], combo[2:]
                if quotas.get(first_post, 0) > 0 and quotas.get(second_post, 0) > 0:
                    max_count = min(quotas[first_post], quotas[second_post])
                    if max_count > 0:
                        combinations[day_type].append((combo, max_count))

            # Ajouter les combinaisons des postes personnalisés
            for post_name, custom_post in self.custom_posts.items():
                if custom_post.assignment_type in ['cats', 'both']:
                    if day_type.replace('sunday', 'sunday_holiday') in custom_post.day_types:
                        quota_custom = quotas.get(post_name, 0)
                        if quota_custom > 0:
                            for other_post, combo_name in custom_post.possible_combinations.items():
                                quota_other = quotas.get(other_post, 0)
                                if quota_other > 0:
                                    max_count = min(quota_custom, quota_other)
                                    combinations[day_type].append((combo_name, max_count))
                                    logger.debug(f"Ajout combinaison {combo_name} pour {cat.name} "
                                            f"({post_name}+{other_post}) avec max={max_count}")

        # Log des combinaisons disponibles
        logger.debug(f"Combinaisons disponibles pour {cat.name}: {combinations}")
        
        return combinations

    def _is_cat_available_for_date(self, cat: CAT, date: date, planning: Planning) -> bool:
        """Vérifie si un CAT est disponible pour une date donnée"""
        # Vérifier les desiderata
        for desiderata in cat.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                return False
                
        # Vérifier si le CAT a déjà des postes ce jour
        day = planning.get_day(date)
        if day:
            return not any(slot.assignee == cat.name for slot in day.slots)
        
        return True

    def _verify_cat_combinations(self, cat_combinations: Dict):
        """Vérifie et log la distribution finale des combinaisons aux CAT"""
        logger.info("\nVÉRIFICATION FINALE DES COMBINAISONS CAT")
        logger.info("=" * 60)
        
        for cat_name, counts in cat_combinations.items():
            logger.info(f"\n{cat_name}:")
            for combo, count in counts.items():
                if combo != "total" and count > 0:
                    logger.info(f"{combo}: {count}")
            logger.info(f"Total combinaisons: {counts['total']}")
            
    def _log_cat_weekend_distribution(self, cat: CAT, used_posts: Dict, 
                                    assignments: Dict, combinations: Dict, planning: Planning):
        """Log détaillé de la distribution pour un CAT"""
        logger.info(f"\nRésultats de distribution pour {cat.name}:")
        
        for day_type in ["saturday", "sunday"]:
            logger.info(f"\n{day_type.upper()}:")
            logger.info("-" * 40)
            
            # Log des combinaisons utilisées
            logger.info("Combinaisons utilisées:")
            for combo, count in assignments[day_type].items():
                if count > 0:
                    max_count = next(m for c, m in combinations[day_type] if c == combo)
                    logger.info(f"{combo}: {count}/{max_count}")
            
            # Log des postes utilisés
            logger.info("\nPostes utilisés:")
            pre_analysis_day_type = "saturday" if day_type == "saturday" else "sunday_holiday"
            quotas = planning.pre_analysis_results["cat_posts"][pre_analysis_day_type]
            
            for post_type, used in used_posts[day_type].items():
                if used > 0:
                    is_custom = post_type in self.custom_posts
                    quota = quotas.get(post_type, 0)
                    logger.info(f"{post_type}: {used}/{quota}" + 
                            " (Personnalisé)" if is_custom else "")
    
    
    
    
    def _distribute_doctor_weekend_combinations(self, planning: Planning) -> bool:
        """
        Distribue les combinaisons de postes weekend aux médecins.
        Prend en compte les périodes critiques, les indisponibilités et les contraintes.
        """
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS WEEKEND AUX MÉDECINS")
            logger.info("=" * 80)

            # Initialisation des structures de données
            doctor_counts = self._initialize_doctor_counts(planning)  # Modification ici
            critical_periods = self._get_critical_weekend_periods(planning)

            # Récupération et organisation des combinaisons disponibles
            available_combinations = self._get_available_doctor_combinations(planning)
            if not available_combinations:
                logger.error("Aucune combinaison disponible pour la distribution")
                return False

            # 1. Distribution pour les périodes critiques
            if critical_periods:
                logger.info("\nPHASE 1: DISTRIBUTION PÉRIODES CRITIQUES")
                logger.info("-" * 60)
                sorted_doctors = self._sort_doctors_by_unavailability(planning)
                
                for period in critical_periods:
                    date = period['date']
                    logger.info(f"\nTraitement période critique: {date} "
                            f"(disponibilité: {period['availability']:.1f}%)")
                    
                    if not self._distribute_critical_period(
                        date, sorted_doctors, doctor_counts,
                        available_combinations, planning
                    ):
                        logger.warning(f"Distribution incomplète pour {date}")

            # 2. Distribution générale équilibrée
            logger.info("\nPHASE 2: DISTRIBUTION GÉNÉRALE")
            logger.info("-" * 60)

            if not self._distribute_remaining_combinations(
                doctor_counts, available_combinations, planning
            ):
                logger.warning("Distribution générale incomplète")

            # Vérification et log des résultats
            self._verify_doctor_distribution(doctor_counts, planning)
            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution des combinaisons médecins: {e}", 
                        exc_info=True)
            return False

    def _initialize_doctor_counts(self, planning: Planning) -> Dict:
        """Initialise les compteurs pour chaque médecin."""
        doctor_counts = {}
        
        for doctor in self.doctors:
            doctor_counts[doctor.name] = {
                "posts": {post_type: 0 for post_type in ALL_POST_TYPES},
                "combinations": {combo: 0 for combo in WEEKEND_COMBINATIONS},
                "total_combinations": 0,
                "custom_posts": {name: 0 for name in self.custom_posts.keys()},
                "intervals": self._get_doctor_intervals(doctor, planning)
            }
            
        return doctor_counts

    def _get_doctor_intervals(self, doctor: Doctor, planning: Planning) -> Dict:
        """
        Récupère les intervalles min-max pour un médecin depuis la pré-analyse.
        """
        intervals = {}
        pre_analysis = planning.pre_analysis_results
        if not pre_analysis or 'ideal_distribution' not in pre_analysis:
            return intervals

        doctor_distribution = pre_analysis['ideal_distribution'].get(doctor.name, {})
        
        # Intervalles pour les postes standards
        for post_type in ALL_POST_TYPES:
            if post_type in doctor_distribution.get('weekend_posts', {}):
                intervals[post_type] = {
                    'min': doctor_distribution['weekend_posts'][post_type]['min'],
                    'max': doctor_distribution['weekend_posts'][post_type]['max']
                }
                
        # Intervalles pour les postes personnalisés
        for post_name in self.custom_posts.keys():
            if post_name in doctor_distribution.get('weekend_posts', {}):
                intervals[post_name] = {
                    'min': doctor_distribution['weekend_posts'][post_name]['min'],
                    'max': doctor_distribution['weekend_posts'][post_name]['max']
                }
                
        return intervals

    def _sort_doctors_by_unavailability(self, planning: Planning) -> List[Doctor]:
        """
        Trie les médecins par ordre décroissant d'indisponibilités weekend.
        Ajoute un facteur aléatoire pour éviter la monotonie.
        """
        doctor_unavailability = {}
        
        for doctor in self.doctors:
            weekend_unavailable = 0
            for desiderata in doctor.desiderata:
                # Compte les weekends dans la période de desiderata
                current_date = max(desiderata.start_date, planning.start_date)
                end_date = min(desiderata.end_date, planning.end_date)
                
                while current_date <= end_date:
                    if (current_date.weekday() >= 5 or 
                        self.cal.is_holiday(current_date) or
                        self.is_bridge_day(current_date)):
                        weekend_unavailable += 1
                    current_date += timedelta(days=1)
                    
            # Ajout d'un facteur aléatoire (±10%)
            random_factor = 1 + (random.random() * 0.2 - 0.1)
            doctor_unavailability[doctor.name] = weekend_unavailable * random_factor

        # Tri par indisponibilité décroissante en utilisant le nom comme clé
        return sorted(self.doctors, 
                    key=lambda d: doctor_unavailability[d.name], 
                    reverse=True)

    def _distribute_critical_period(self, date: date, sorted_doctors: List[Doctor],
                                doctor_counts: Dict, available_combinations: Dict,
                                planning: Planning) -> bool:
        """
        Distribution prioritaire pour une période critique.
        """
        try:
            # Identifier le type de jour
            is_saturday = date.weekday() == 5 and not self.is_bridge_day(date)
            day_type = "saturday" if is_saturday else "sunday_holiday"
            
            # Filtrer les médecins disponibles pour cette date
            available_doctors = [
                doctor for doctor in sorted_doctors
                if self._is_doctor_available_for_date(doctor, date, planning)
            ]
            
            if not available_doctors:
                logger.warning(f"Aucun médecin disponible pour {date}")
                return False
                
            combinations_assigned = 0
            max_combinations = len(available_combinations[day_type])
            
            # Attribution des combinaisons
            for doctor in available_doctors:
                if combinations_assigned >= max_combinations:
                    break
                    
                # Tenter d'attribuer une combinaison appropriée
                combo = self._get_best_combination_for_doctor(
                    doctor, date, available_combinations[day_type],
                    doctor_counts[doctor.name], planning
                )
                
                if combo and self._try_assign_combination(
                    doctor, combo, date, doctor_counts[doctor.name], planning
                ):
                    combinations_assigned += 1
                    logger.info(f"{doctor.name}: {combo} attribué pour {date}")
                    
            return combinations_assigned > 0
            
        except Exception as e:
            logger.error(f"Erreur distribution période critique {date}: {e}")
            return False

    def _is_doctor_available_for_date(self, doctor: Doctor, date: date, 
                                planning: Planning) -> bool:
        """
        Vérifie la disponibilité d'un médecin pour une date donnée.
        """
        # Vérifier les desiderata
        for desiderata in doctor.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                return False
                
        # Vérifier les postes déjà attribués ce jour
        day = planning.get_day(date)
        if day:
            return not any(slot.assignee == doctor.name for slot in day.slots)
            
        return True

    def _get_best_combination_for_doctor(self, doctor: Doctor, date: date,
                                    available_combinations: List[str],
                                    doctor_state: Dict,
                                    planning: Planning) -> Optional[str]:
        """
        Sélectionne la meilleure combinaison pour un médecin.
        Prend en compte les limites max et l'équilibre des postes.
        """
        suitable_combinations = []
        
        for combo in available_combinations:
            # Vérifier si la combinaison est possible
            if self._can_assign_combination(doctor, combo, date, 
                                        doctor_state, planning):
                # Calcul du score de pertinence
                score = self._calculate_combination_score(
                    combo, doctor_state, doctor.half_parts
                )
                suitable_combinations.append((combo, score))
                
        if not suitable_combinations:
            return None
                
        # Sélection pondérée par le score
        total_score = sum(score for _, score in suitable_combinations)
        if total_score == 0:
            return None
                
        random_value = random.uniform(0, total_score)
        current_sum = 0
        
        for combo, score in suitable_combinations:
            current_sum += score
            if current_sum >= random_value:
                return combo
                    
        return suitable_combinations[-1][0] if suitable_combinations else None

    def _calculate_combination_score(self, combo: str, doctor_state: Dict,
                                half_parts: int) -> float:
        """
        Calcule un score de pertinence pour une combinaison.
        Prend en compte:
        - L'écart aux intervalles idéaux
        - Le nombre de demi-parts du médecin
        - L'historique des attributions
        """
        score = 10.0  # Score de base
        
        # Pénaliser si proche des maximums
        for post in self._get_posts_from_combo(combo):
            if post in doctor_state['intervals']:
                current = doctor_state['posts'].get(post, 0)
                max_val = doctor_state['intervals'][post]['max']
                if max_val > 0:
                    ratio = current / max_val
                    score *= (1 - ratio)  # Réduction progressive du score
        
        # Bonus pour les combinaisons moins utilisées
        combo_count = doctor_state['combinations'].get(combo, 0)
        score *= (1 + (3 - combo_count) * 0.2)  # +20% par combo manquant
        
        # Ajustement selon les demi-parts
        score *= 1.2 if half_parts == 2 else 0.8
        
        # Facteur aléatoire (±10%)
        score *= 1 + (random.random() * 0.2 - 0.1)
        
        return max(0.1, score)  # Score minimum pour garder une chance

    def _distribute_remaining_combinations(self, doctor_counts: Dict,
                                    available_combinations: Dict,
                                    planning: Planning) -> bool:
        """
        Distribution des combinaisons restantes de manière équilibrée.
        """
        try:
            remaining_dates = self._get_remaining_weekend_dates(planning)
            if not remaining_dates:
                return True
                
            # Organisation par type de jour
            dates_by_type = {
                "saturday": [],
                "sunday_holiday": []
            }
            
            for date in remaining_dates:
                if date.weekday() == 5 and not self.is_bridge_day(date):
                    dates_by_type["saturday"].append(date)
                else:
                    dates_by_type["sunday_holiday"].append(date)
                    
            # Distribution pour chaque type de jour
            for day_type, dates in dates_by_type.items():
                if not dates:
                    continue
                    
                logger.info(f"\nDistribution {day_type}:")
                random.shuffle(dates)  # Ordre aléatoire
                
                for date in dates:
                    available_doctors = self._get_available_doctors_weighted(
                        date, doctor_counts, planning
                    )
                    
                    if not available_doctors:
                        logger.warning(f"Aucun médecin disponible pour {date}")
                        continue
                        
                    # Distribution pondérée
                    assignments_made = self._distribute_day_combinations(
                        date, available_doctors, doctor_counts,
                        available_combinations[day_type], planning
                    )
                    
                    if not assignments_made:
                        logger.warning(f"Impossible de distribuer pour {date}")
                        
            return True
            
        except Exception as e:
            logger.error(f"Erreur distribution générale: {e}")
            return False
    def _get_available_doctors_weighted(self, date: date, doctor_counts: Dict,
                                    planning: Planning) -> List[Tuple[Doctor, float]]:
        """
        Retourne les médecins disponibles avec leur pondération.
        """
        weighted_doctors = []
        
        for doctor in self.doctors:
            if not self._is_doctor_available_for_date(doctor, date, planning):
                continue
                
            # Calcul du poids basé sur plusieurs facteurs
            weight = self._calculate_doctor_weight(
                doctor, doctor_counts[doctor.name], date, planning
            )
            
            if weight > 0:
                weighted_doctors.append((doctor, weight))
                
        return sorted(weighted_doctors, key=lambda x: x[1], reverse=True)

    def _calculate_doctor_weight(self, doctor: Doctor, doctor_state: Dict, 
                            date: date, planning: Planning) -> float:
        """
        Calcule le poids d'un médecin pour la distribution.
        Prend en compte:
        - Le nombre de combinaisons reçues
        - Les demi-parts du médecin 
        - Le temps depuis la dernière attribution
        - L'atteinte des intervalles cibles
        """
        # 1. Calcul du poids basé sur les combinaisons reçues
        total_combos = doctor_state.get('total_combinations', 0)
        max_combos = max((state.get('total_combinations', 0) 
                for state in self._get_all_doctor_states(planning)), default=1)
        combo_weight = 1 - (total_combos / max_combos) if max_combos > 0 else 1.0

        # 2. Poids basé sur les demi-parts
        half_parts_weight = 1.2 if doctor.half_parts == 2 else 0.8

        # 3. Poids basé sur le temps depuis la dernière attribution
        last_weekend = self._get_last_weekend_date(doctor, planning)
        if last_weekend:
            days_since = (date - last_weekend).days
            time_weight = min(1.5, days_since / 14)  # Bonus max après 2 semaines
        else:
            time_weight = 1.5  # Bonus pour première attribution

        # 4. Poids basé sur les intervalles
        interval_weights = []
        for post_type, interval in doctor_state['intervals'].items():
            current = doctor_state['posts'].get(post_type, 0)
            if interval['max'] > 0:
                ratio = current / interval['max']
                interval_weights.append(1 - ratio)
        
        interval_weight = (sum(interval_weights) / len(interval_weights)) if interval_weights else 1.0
        
        # Combinaison des facteurs avec pondération
        base_weight = (combo_weight * 0.4 + 
                    half_parts_weight * 0.2 + 
                    time_weight * 0.2 + 
                    interval_weight * 0.2)
        
        random_factor = 1 + (random.random() * 0.2 - 0.1)  # ±10%
        return max(0.1, base_weight * random_factor)


    def _get_last_weekend_date(self, doctor: Doctor, planning: Planning) -> Optional[date]:
        """
        Trouve la date du dernier weekend où le médecin a été assigné.
        """
        last_date = None
        for day in reversed(planning.days):
            if not (day.date.weekday() >= 5 or 
                    self.cal.is_holiday(day.date) or
                    self.is_bridge_day(day.date)):
                continue
                
            if any(slot.assignee == doctor.name for slot in day.slots):
                last_date = day.date
                break
                
        return last_date

    def _distribute_day_combinations(self, date: date, 
                                weighted_doctors: List[Tuple[Doctor, float]],
                                doctor_counts: Dict, 
                                available_combinations: List[str],
                                planning: Planning) -> bool:
        """
        Distribue les combinaisons pour un jour donné aux médecins en quatre passes :
        1. Première passe : priorité aux médecins sans combinaison
        2. Deuxième passe : compléter pour les médecins sous la moyenne
        3. Troisième passe : optimiser pour les médecins disponibles sous-utilisés
        4. Quatrième passe : maximiser l'utilisation de toutes les combinaisons restantes
        """
        try:
            assignments_made = False
            remaining_combinations = available_combinations.copy()
            if not remaining_combinations:
                return False

            # Calculer la moyenne actuelle des combinaisons
            total_combinations = sum(state['total_combinations'] 
                                for state in doctor_counts.values())
            nb_doctors = len(self.doctors)
            average_combinations = total_combinations / nb_doctors if nb_doctors > 0 else 0
            
            logger.debug(f"Moyenne actuelle: {average_combinations:.2f} combinaisons par médecin")

            # Première passe : médecins sans combinaison
            doctors_no_combo = sorted(
                [d for d, w in weighted_doctors if doctor_counts[d.name]['total_combinations'] == 0],
                key=lambda d: doctor_counts[d.name]['total_combinations']
            )
            
            if doctors_no_combo:
                logger.debug(f"Passe 1: {len(doctors_no_combo)} médecins sans combinaison")
                for doctor in doctors_no_combo:
                    if not remaining_combinations:
                        break
                        
                    combo = self._get_best_combination_for_doctor(
                        doctor, date, remaining_combinations,
                        doctor_counts[doctor.name], planning
                    )
                    
                    if combo and self._try_assign_combination(
                        doctor, combo, date, doctor_counts[doctor.name], planning
                    ):
                        remaining_combinations.remove(combo)
                        assignments_made = True
                        logger.info(f"Passe 1: {doctor.name}: {combo} attribué")

            # Deuxième passe : médecins sous la moyenne
            if remaining_combinations:
                doctors_under_avg = sorted(
                    [d for d, w in weighted_doctors 
                    if doctor_counts[d.name]['total_combinations'] < average_combinations],
                    key=lambda d: doctor_counts[d.name]['total_combinations']
                )
                
                if doctors_under_avg:
                    logger.debug(f"Passe 2: {len(doctors_under_avg)} médecins sous la moyenne")
                    for doctor in doctors_under_avg:
                        if not remaining_combinations:
                            break
                            
                        combo = self._get_best_combination_for_doctor(
                            doctor, date, remaining_combinations,
                            doctor_counts[doctor.name], planning
                        )
                        
                        if combo and self._try_assign_combination(
                            doctor, combo, date, doctor_counts[doctor.name], planning
                        ):
                            remaining_combinations.remove(combo)
                            assignments_made = True
                            logger.info(f"Passe 2: {doctor.name}: {combo} attribué")

            # Troisième passe : médecins disponibles sous-utilisés
            if remaining_combinations:
                available_doctors = [
                    d for d, w in weighted_doctors
                    if self._can_receive_more_combinations(d, doctor_counts[d.name])
                ]
                
                if available_doctors:
                    logger.debug(f"Passe 3: {len(available_doctors)} médecins disponibles")
                    available_doctors.sort(
                        key=lambda d: doctor_counts[d.name]['total_combinations']
                    )
                    
                    for doctor in available_doctors:
                        if not remaining_combinations:
                            break
                            
                        combo = self._get_best_combination_for_doctor(
                            doctor, date, remaining_combinations,
                            doctor_counts[doctor.name], planning
                        )
                        
                        if combo and self._try_assign_combination(
                            doctor, combo, date, doctor_counts[doctor.name], planning
                        ):
                            remaining_combinations.remove(combo)
                            assignments_made = True
                            logger.info(f"Passe 3: {doctor.name}: {combo} attribué")

            # Quatrième passe : maximiser l'utilisation des combinaisons restantes
            if remaining_combinations:
                # Récupérer tous les médecins qui peuvent recevoir des combinaisons
                all_available_doctors = [
                    doctor for doctor, _ in weighted_doctors
                    if self._is_doctor_available_for_date(doctor, date, planning) and
                    any(self._can_assign_combination(doctor, combo, date, 
                                                    doctor_counts[doctor.name], planning)
                        for combo in remaining_combinations)
                ]

                if all_available_doctors:
                    logger.debug(f"Passe 4: {len(all_available_doctors)} médecins disponibles "
                            f"pour {len(remaining_combinations)} combinaisons restantes")
                    
                    # Trier par nombre de combinaisons possibles
                    all_available_doctors.sort(
                        key=lambda d: sum(1 for combo in remaining_combinations 
                                        if self._can_assign_combination(
                                            d, combo, date, 
                                            doctor_counts[d.name], planning)
                                    ),
                        reverse=True
                    )

                    for doctor in all_available_doctors:
                        if not remaining_combinations:
                            break

                        # Essayer toutes les combinaisons possibles
                        possible_combinations = [
                            combo for combo in remaining_combinations
                            if self._can_assign_combination(
                                doctor, combo, date, 
                                doctor_counts[doctor.name], planning)
                        ]

                        if possible_combinations:
                            combo = self._get_best_combination_for_doctor(
                                doctor, date, possible_combinations,
                                doctor_counts[doctor.name], planning
                            )
                            if combo and self._try_assign_combination(
                                doctor, combo, date, doctor_counts[doctor.name], planning
                            ):
                                remaining_combinations.remove(combo)
                                assignments_made = True
                                logger.info(f"Passe 4: {doctor.name}: {combo} attribué")

            # Log du résultat final
            combinations_used = len(available_combinations) - len(remaining_combinations)
            if assignments_made:
                distribution_rate = (combinations_used / len(available_combinations)) * 100
                logger.info(f"Distribution finale pour {date}: "
                        f"{combinations_used}/{len(available_combinations)} "
                        f"combinaisons attribuées ({distribution_rate:.1f}%)")
                if remaining_combinations:
                    logger.info(f"Combinaisons non attribuées: {', '.join(remaining_combinations)}")
            else:
                logger.warning(f"Aucune attribution pour {date}")

            return assignments_made

        except Exception as e:
            logger.error(f"Erreur dans la distribution des combinaisons du jour {date}: {e}")
            return False

    def _can_receive_more_combinations(self, doctor: Doctor, doctor_state: Dict) -> bool:
        """
        Vérifie si un médecin peut encore recevoir des combinaisons
        en fonction de ses limites pour chaque type de poste.
        """
        for post_type, interval in doctor_state['intervals'].items():
            current = doctor_state['posts'].get(post_type, 0)
            if current < interval['max']:
                return True
        return False
    def _can_assign_combination(self, doctor: Doctor, combo: str, date: date,
                                doctor_state: Dict, planning: Planning) -> bool:
        """
        Version corrigée de la vérification des limites de groupe pour les combinaisons.
        Vérifie l'impact combiné des deux postes sur les limites de groupe.
        """
        # 1. Extraire les deux postes de la combinaison
        first_post, second_post = self._get_posts_from_combo(combo)
        
        # 2. Identifier les groupes impactés
        first_group = self._get_post_group(first_post, date)
        second_group = self._get_post_group(second_post, date)
        
        # 3. Vérifier les limites de groupe de manière combinée
        impacted_groups = {}
        
        if first_group:
            impacted_groups[first_group] = impacted_groups.get(first_group, 0) + 1
        if second_group:
            impacted_groups[second_group] = impacted_groups.get(second_group, 0) + 1
            
        # 4. Pour chaque groupe impacté, vérifier si l'ajout violerait la limite
        for group, impact in impacted_groups.items():
            current_count = self._count_group_posts(doctor, group, planning)
            group_max = (planning.pre_analysis_results.get('ideal_distribution', {})
                        .get(doctor.name, {})
                        .get('weekend_groups', {})
                        .get(group, {})
                        .get('max', float('inf')))
                        
            if current_count + impact > group_max:
                logger.debug(f"Attribution impossible: {doctor.name} - {combo} "
                            f"dépasserait la limite du groupe {group} "
                            f"({current_count + impact} > {group_max})")
                return False
        # 1. Vérification de base des desiderata
        if not self._is_doctor_available_for_date(doctor, date, planning):
            return False
            
        # 2. Détermination du type de jour
        is_saturday = date.weekday() == 5 and not self.is_bridge_day(date)
        day_type = "saturday" if is_saturday else "sunday_holiday"
        
        # 3. Extraction des postes de la combinaison
        first_post, second_post = self._get_posts_from_combo(combo)
        day = planning.get_day(date)
        if not day:
            return False

        # 4. Vérification des slots disponibles
        first_slot = next((s for s in day.slots if s.abbreviation == first_post and not s.assignee), None)
        second_slot = next((s for s in day.slots if s.abbreviation == second_post and not s.assignee), None)
        if not (first_slot and second_slot):
            return False

        # 5. Vérification des contraintes globales
        if not (self.constraints.can_assign_to_assignee(doctor, date, first_slot, planning) and
                self.constraints.can_assign_to_assignee(doctor, date, second_slot, planning)):
            return False

        # 6. Vérification des limites pour chaque poste
        for post in [first_post, second_post]:
            # 6.1 Vérification du groupe
            group = self._get_post_group(post, date)
            if group:
                current_group = self._count_group_posts(doctor, group, planning)
                group_max = (planning.pre_analysis_results.get('ideal_distribution', {})
                            .get(doctor.name, {})
                            .get('weekend_groups', {})
                            .get(group, {})
                            .get('max', float('inf')))
                
                # Vérification par type de jour pour le groupe
                group_this_type = sum(
                    1 for d in planning.days
                    if ((d.date.weekday() == 5 and not self.is_bridge_day(d.date)) == is_saturday)
                    for s in d.slots
                    if s.assignee == doctor.name and self._get_post_group(s.abbreviation, d.date) == group
                )
                
                group_max_per_type = (group_max + 1) // 2  # Arrondissement supérieur
                if group_this_type >= group_max_per_type:
                    logger.debug(f"{doctor.name}: Limite de groupe {group} atteinte pour {day_type}")
                    return False

            # 6.2 Vérification du type de poste
            if post in doctor_state['intervals']:
                post_max = doctor_state['intervals'][post]['max']
                current_type = sum(
                    1 for d in planning.days
                    if ((d.date.weekday() == 5 and not self.is_bridge_day(d.date)) == is_saturday)
                    for s in d.slots
                    if s.assignee == doctor.name and s.abbreviation == post
                )
                
                post_max_per_type = (post_max + 1) // 2  # Arrondissement supérieur
                if current_type >= post_max_per_type:
                    logger.debug(f"{doctor.name}: Limite de poste {post} atteinte pour {day_type}")
                    return False
                    
        return True

    

    def _try_assign_combination(self, doctor: Doctor, combo: str, date: date,
                                    doctor_state: Dict, planning: Planning) -> bool:
        """
        Version corrigée de l'attribution des combinaisons avec double vérification
        des limites de groupe avant l'attribution.
        """
        try:
            # 1. Vérifier une dernière fois les limites de groupe avant l'attribution
            if not self._can_assign_combination(doctor, combo, date, 
                                                    doctor_state, planning):
                return False
                
            # 2. Procéder à l'attribution comme avant
            day = planning.get_day(date)
            if not day:
                return False
                
            first_post, second_post = self._get_posts_from_combo(combo)
            
            # 3. Rechercher les slots et attribuer
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)
                            
            if not (first_slot and second_slot):
                return False
                
            # 4. Double vérification finale des contraintes
            if not (self.constraints.can_assign_to_assignee(doctor, date, first_slot, planning) and
                    self.constraints.can_assign_to_assignee(doctor, date, second_slot, planning)):
                return False
                
            # 5. Attribution et mise à jour des compteurs
            first_slot.assignee = doctor.name
            second_slot.assignee = doctor.name
            
            doctor_state['posts'][first_post] = doctor_state['posts'].get(first_post, 0) + 1
            doctor_state['posts'][second_post] = doctor_state['posts'].get(second_post, 0) + 1
            doctor_state['combinations'][combo] = doctor_state['combinations'].get(combo, 0) + 1
            doctor_state['total_combinations'] += 1
            
            return True
                
        except Exception as e:
            logger.error(f"Erreur attribution {combo} à {doctor.name}: {e}")
            return False

    def _get_available_doctor_combinations(self, planning: Planning) -> Dict[str, List[str]]:
        """
        Récupère les combinaisons disponibles pour les médecins sur le weekend.
        Retourne un dictionnaire séparé pour samedi et dimanche/férié.
        """
        combinations = {
            "saturday": [],
            "sunday_holiday": []
        }
        
        pre_analysis = planning.pre_analysis_results
        if not pre_analysis or 'adjusted_posts' not in pre_analysis:
            return combinations
        
        # Récupération des quotas ajustés pour les médecins
        for day_type in ["saturday", "sunday_holiday"]:
            quotas = pre_analysis['adjusted_posts'][day_type]
            
            # Ajout des combinaisons standards
            for combo in WEEKEND_COMBINATIONS:
                first_post, second_post = combo[:2], combo[2:]
                if quotas.get(first_post, 0) > 0 and quotas.get(second_post, 0) > 0:
                    combinations[day_type].append(combo)
                    
            # Ajout des combinaisons personnalisées
            for post_name, custom_post in self.custom_posts.items():
                if custom_post.assignment_type in ['doctors', 'both']:
                    if day_type in custom_post.day_types:
                        quota_custom = quotas.get(post_name, 0)
                        if quota_custom > 0:
                            for other_post, combo_name in custom_post.possible_combinations.items():
                                if quotas.get(other_post, 0) > 0:
                                    combinations[day_type].append(combo_name)
        
        return combinations

    def _get_remaining_weekend_dates(self, planning: Planning) -> List[date]:
        """
        Récupère les dates weekend restantes où il y a encore des slots non assignés.
        """
        remaining_dates = []
        
        for day in planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge):
                continue
                
            # Vérifier s'il reste des slots non assignés
            unassigned_slots = [slot for slot in day.slots if not slot.assignee]
            if unassigned_slots:
                remaining_dates.append(day.date)
        
        return remaining_dates

    def _get_posts_from_combo(self, combo: str) -> Tuple[str, str]:
        """
        Extrait les deux postes d'une combinaison, en gérant les cas personnalisés.
        Retourne un tuple (premier_poste, second_poste).
        """
        # Vérifier si c'est une combinaison personnalisée
        for custom_post in self.custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post
        
        # Combinaison standard
        return combo[:2], combo[2:]
    def _get_all_doctor_states(self, planning: Planning) -> List[Dict]:
        """
        Récupère l'état de distribution pour tous les médecins.
        Utilisé pour calculer les maximums globaux.
        """
        states = []
        for day in planning.days:
            for slot in day.slots:
                if slot.assignee:
                    doctor_state = next(
                        (state for state in states 
                        if state.get('doctor_name') == slot.assignee),
                        None
                    )
                    if not doctor_state:
                        doctor_state = {
                            'doctor_name': slot.assignee,
                            'total_combinations': 0
                        }
                        states.append(doctor_state)
                    # Compte uniquement les combinaisons weekend
                    if day.is_weekend or day.is_holiday_or_bridge:
                        doctor_state['total_combinations'] += 1
        return states


    def _verify_doctor_distribution(self, doctor_counts: Dict, planning: Planning) -> bool:
        """
        Vérifie et log la distribution finale des combinaisons aux médecins.
        """
        logger.info("\nVÉRIFICATION FINALE DE LA DISTRIBUTION")
        logger.info("=" * 60)
        
        all_ok = True
        for doctor in self.doctors:
            logger.info(f"\n{doctor.name} ({doctor.half_parts} demi-parts):")
            state = doctor_counts[doctor.name]
            
            # Vérification des postes
            logger.info("Postes attribués:")
            for post_type, count in sorted(state['posts'].items()):
                if count > 0:
                    if post_type in state['intervals']:
                        min_val = state['intervals'][post_type]['min']
                        max_val = state['intervals'][post_type]['max']
                        status = "OK"
                        if count < min_val:
                            status = "SOUS MIN"
                            all_ok = False
                        elif count > max_val:
                            status = "SUR MAX"
                            all_ok = False
                        logger.info(f"{post_type:4}: {count:2d} [{min_val}-{max_val}] {status}")
                    else:
                        logger.info(f"{post_type:4}: {count:2d}")
            
            # Vérification des combinaisons
            logger.info("\nCombinaisons utilisées:")
            for combo, count in sorted(state['combinations'].items()):
                if count > 0:
                    logger.info(f"{combo}: {count}")
            logger.info(f"Total combinaisons: {state['total_combinations']}")
            
        return all_ok
    
    
    
    
    
    
    def distribute_remaining_weekend_posts(self, planning: Planning) -> bool:
        """
        Distribution des postes restants du weekend après NL, NAM et combinaisons.
        Processus en 3 phases : analyse, CAT, médecins.
        """
        try:
            logger.info("\nDISTRIBUTION DES POSTES RESTANTS WEEKEND")
            logger.info("=" * 80)

            # 1. Collecte et analyse des postes restants
            posts_to_distribute = self._collect_remaining_weekend_posts(planning)
            if not posts_to_distribute["saturday"] and not posts_to_distribute["sunday_holiday"]:
                logger.info("Aucun poste restant à distribuer")
                return True

            # 2. Distribution aux CAT
            cat_quotas = self._calculate_cat_remaining_quotas(planning)
            if not self._distribute_remaining_to_cats(planning, posts_to_distribute, cat_quotas):
                logger.warning("Distribution incomplète aux CAT")
                return False

            # 3. Distribution aux médecins
            return self._distribute_remaining_to_doctors(planning, posts_to_distribute)
        
        

        except Exception as e:
            logger.error(f"Erreur distribution postes restants weekend: {e}", exc_info=True)
            return False

    def _collect_remaining_weekend_posts(self, planning: Planning) -> Dict:
        """Collecte tous les postes non attribués du weekend."""
        posts = {
            "saturday": defaultdict(list),
            "sunday_holiday": defaultdict(list)
        }

        for day in planning.days:
            if not day.is_weekend and not day.is_holiday_or_bridge:
                continue

            day_type = "saturday" if day.date.weekday() == 5 and not DayType.is_bridge_day(day.date, self.cal) else "sunday_holiday"
            
            for slot in day.slots:
                if not slot.assignee and slot.abbreviation not in ["NL", "NM", "NA"]:
                    # Ajouter à la liste avec la date
                    posts[day_type][slot.abbreviation].append((day.date, slot))

        # Log des postes collectés
        for day_type, type_posts in posts.items():
            logger.info(f"\nPostes restants {day_type}:")
            for post_type, slots in type_posts.items():
                if slots:
                    logger.info(f"{post_type}: {len(slots)} slots")

        return posts

    def _calculate_cat_remaining_quotas(self, planning: Planning) -> Dict:
        """Calcule les quotas restants pour les CAT."""
        pre_analysis = planning.pre_analysis_results
        cat_quotas = {cat.name: {
            "saturday": defaultdict(int),
            "sunday_holiday": defaultdict(int)
        } for cat in self.cats}

        # Pour chaque CAT, calculer les quotas par type de jour
        for cat in self.cats:
            for day_type in ["saturday", "sunday_holiday"]:
                # Quotas attendus depuis la pré-analyse
                expected = pre_analysis["cat_posts"][day_type]
                
                # Compter les postes déjà attribués
                assigned = defaultdict(int)
                for day in planning.days:
                    if ((day_type == "saturday" and day.date.weekday() == 5 and not DayType.is_bridge_day(day.date, self.cal)) or
                        (day_type == "sunday_holiday" and (day.date.weekday() == 6 or day.is_holiday_or_bridge))):
                        for slot in day.slots:
                            if slot.assignee == cat.name:
                                assigned[slot.abbreviation] += 1

                # Calculer les quotas restants
                for post_type, quota in expected.items():
                    remaining = quota - assigned[post_type]
                    if remaining > 0:
                        cat_quotas[cat.name][day_type][post_type] = remaining

        return cat_quotas

    def _distribute_remaining_to_cats(self, planning: Planning, 
                                    available_posts: Dict,
                                    cat_quotas: Dict) -> bool:
        """
        Distribution des postes restants aux CAT selon leurs quotas.
        Fait deux passes et continue même si certains quotas ne sont pas atteints.
        """
        try:
            logger.info("\nDISTRIBUTION CAT DES POSTES RESTANTS")
            logger.info("-" * 60)
            
            # Phase 1 : Distribution sur les périodes critiques
            logger.info("\nPHASE 1: Distribution sur périodes critiques")
            critical_periods = self._get_critical_weekend_periods(planning)
            for period in critical_periods:
                date = period['date']
                day_type = "saturday" if date.weekday() == 5 and not DayType.is_bridge_day(date, self.cal) else "sunday_holiday"
                
                # Distribution prioritaire aux CAT disponibles
                for cat in self.cats:
                    if not self._is_cat_available_for_date(cat, date, planning):
                        continue
                        
                    quota = cat_quotas[cat.name][day_type]
                    for post_type, count in quota.items():
                        available = [slot for d, slot in available_posts[day_type][post_type] if d == date]
                        for slot in available:
                            if count > 0 and self.constraints.can_assign_to_assignee(cat, date, slot, planning):
                                slot.assignee = cat.name
                                cat_quotas[cat.name][day_type][post_type] -= 1
                                count -= 1
                                logger.info(f"CAT {cat.name}: {post_type} attribué le {date} (période critique)")

            # Phase 2 : Distribution normale
            logger.info("\nPHASE 2: Distribution normale")
            for day_type in ["saturday", "sunday_holiday"]:
                for post_type in ALL_POST_TYPES:
                    if post_type not in available_posts[day_type]:
                        continue

                    # Pour chaque date disponible
                    available_slots = available_posts[day_type][post_type].copy()
                    random.shuffle(available_slots)  # Mélanger pour plus d'équité
                    
                    for date, slot in available_slots:
                        if slot.assignee:  # Déjà attribué
                            continue

                        # Trouver un CAT qui a encore besoin de ce type de poste
                        available_cats = [
                            cat for cat in self.cats
                            if (cat_quotas[cat.name][day_type][post_type] > 0 and
                                self._is_cat_available_for_date(cat, date, planning))
                        ]

                        if available_cats:
                            cat = random.choice(available_cats)  # Choix aléatoire
                            if self.constraints.can_assign_to_assignee(cat, date, slot, planning):
                                slot.assignee = cat.name
                                cat_quotas[cat.name][day_type][post_type] -= 1
                                logger.info(f"CAT {cat.name}: {post_type} attribué le {date}")

            # Phase 3 : Deuxième passe pour tenter de compléter les quotas
            logger.info("\nPHASE 3: Distribution complémentaire")
            random.shuffle(self.cats)  # Ordre aléatoire pour l'équité
            for cat in self.cats:
                for day_type in ["saturday", "sunday_holiday"]:
                    quotas_restants = cat_quotas[cat.name][day_type]
                    for post_type, quota in quotas_restants.items():
                        if quota <= 0:
                            continue

                        available = []
                        for date, slot in available_posts[day_type].get(post_type, []):
                            if not slot.assignee and self._is_cat_available_for_date(cat, date, planning):
                                available.append((date, slot))

                        random.shuffle(available)  # Mélanger les slots disponibles
                        for date, slot in available:
                            if self.constraints.can_assign_to_assignee(cat, date, slot, planning):
                                slot.assignee = cat.name
                                cat_quotas[cat.name][day_type][post_type] -= 1
                                logger.info(f"CAT {cat.name}: {post_type} attribué le {date} (phase complémentaire)")
                                if cat_quotas[cat.name][day_type][post_type] <= 0:
                                    break
            # Phase 4 : Distribution avec assouplissement des desideratas secondaires
            logger.info("\nPHASE 4: Distribution avec assouplissement des desideratas secondaires")
            
            # Récupérer les périodes critiques non couvertes
            critical_periods = self._get_critical_weekend_periods(planning)
            critical_periods.sort(key=lambda x: x['availability'])  # Trier par criticité croissante
            
            # Pour chaque CAT ayant encore des quotas non remplis
            for cat_name, quotas in cat_quotas.items():
                cat = next(c for c in self.cats if c.name == cat_name)
                
                # Parcourir d'abord les périodes critiques
                for period in critical_periods:
                    date = period['date']
                    day_type = "saturday" if date.weekday() == 5 and not DayType.is_bridge_day(date, self.cal) else "sunday_holiday"
                    
                    # Pour chaque type de poste avec quota non atteint
                    for post_type, remaining in quotas[day_type].items():
                        if remaining <= 0:
                            continue
                            
                        # Chercher un slot disponible pour ce post_type à cette date
                        available = [slot for d, slot in available_posts[day_type].get(post_type, []) 
                                   if d == date and not slot.assignee]
                        
                        for slot in available:
                            # Vérifier les contraintes en ignorant les desideratas secondaires
                            if self.constraints.can_assign_to_assignee(
                                cat, date, slot, planning, respect_secondary=False
                            ):
                                slot.assignee = cat.name
                                quotas[day_type][post_type] -= 1
                                logger.info(f"CAT {cat.name}: {post_type} attribué le {date} "
                                          f"(assouplissement, criticité: {period['availability']:.1f}%)")
                                break
                
                # Puis traiter les dates restantes
                for day_type in ["saturday", "sunday_holiday"]:
                    for post_type, remaining in quotas[day_type].items():
                        if remaining <= 0:
                            continue
                            
                        # Chercher parmi tous les slots disponibles restants
                        available = [(d, s) for d, s in available_posts[day_type].get(post_type, [])
                                   if not s.assignee]
                        random.shuffle(available)  # Mélanger pour l'équité
                        
                        for date, slot in available:
                            if self.constraints.can_assign_to_assignee(
                                cat, date, slot, planning, respect_secondary=False
                            ):
                                slot.assignee = cat.name
                                quotas[day_type][post_type] -= 1
                                logger.info(f"CAT {cat.name}: {post_type} attribué le {date} "
                                          f"(assouplissement)")
                                if quotas[day_type][post_type] <= 0:
                                    break
            # Log final des quotas non atteints
            incomplete = False
            for cat_name, quotas in cat_quotas.items():
                for day_type, type_quotas in quotas.items():
                    for post_type, remaining in type_quotas.items():
                        if remaining > 0:
                            logger.warning(f"CAT {cat_name}: {remaining} {post_type} non attribués ({day_type})")
                            incomplete = True

            if incomplete:
                logger.warning("Distribution incomplète aux CAT - Poursuite avec les médecins")
                
            # Toujours retourner True pour continuer avec les médecins
            return True

        except Exception as e:
            logger.error(f"Erreur distribution CAT: {e}", exc_info=True)
            # Continuer malgré l'erreur pour passer aux médecins
            return True

    def _distribute_remaining_to_doctors(self, planning: Planning, available_posts: Dict) -> bool:
        """
        Distribution optimisée des postes restants aux médecins avec respect strict des limites de groupe.
        """
        try:
            logger.info("\nDISTRIBUTION MÉDECINS DES POSTES RESTANTS")
            logger.info("=" * 60)

            # Récupération des intervalles et initialisation des compteurs
            intervals = planning.pre_analysis_results.get('ideal_distribution', {})
            doctor_states = self._initialize_doctor_states(planning)

            # PHASE 1: Distribution minimale obligatoire
            logger.info("\nPHASE 1: Distribution minimale obligatoire")
            self._distribute_minimum_requirements(planning, available_posts, intervals, doctor_states)

            # PHASE 2: Distribution équilibrée
            logger.info("\nPHASE 2: Distribution équilibrée")
            self._distribute_balanced_posts(planning, available_posts, intervals, doctor_states)

            # PHASE 3: Distribution finale
            remaining = self._count_unassigned_slots(planning)
            if remaining > 0:
                logger.info(f"\nPHASE 3: Distribution finale ({remaining} slots)")
                self._distribute_final_posts(planning, available_posts, intervals, doctor_states)

            # Vérification finale des limites de groupe
            status = self._verify_group_limits(planning, intervals)
            if not status:
                logger.error("Des dépassements de limites de groupe ont été détectés")
            return status

        except Exception as e:
            logger.error(f"Erreur distribution médecins: {e}", exc_info=True)
            return False

    def _initialize_doctor_states(self, planning: Planning) -> Dict:
        """Initialise l'état de distribution pour chaque médecin."""
        states = {}
        for doctor in self.doctors:
            states[doctor.name] = {
                'post_counts': self._get_doctor_weekend_counts(doctor, planning),
                'group_counts': {
                    group: self._count_group_posts(doctor, group, planning)
                    for group in ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]
                }
            }
        return states

    def _can_assign_post(self, doctor: Doctor, post_type: str, date: date, 
                        slot: TimeSlot, planning: Planning, intervals: Dict, 
                        doctor_state: Dict) -> bool:
        """
        Vérifie si un poste peut être attribué en respectant toutes les contraintes.
        Ajoute une double vérification pour les chevauchements.
        """
        # 1. Vérification explicite des postes déjà attribués ce jour
        day = planning.get_day(date)
        if day:
            day_posts = [s for s in day.slots if s.assignee == doctor.name]
            for existing_slot in day_posts:
                # Vérifier si même type de poste
                if existing_slot.abbreviation == post_type:
                    return False
                # Vérifier le chevauchement horaire
                if (slot.start_time < existing_slot.end_time and 
                    slot.end_time > existing_slot.start_time):
                    return False

        # 2. Vérifier la limite du groupe
        group = self._get_post_group(post_type, date)
        if group:
            group_max = intervals.get(doctor.name, {}).get('weekend_groups', {}).get(group, {}).get('max', float('inf'))
            current_group = doctor_state['group_counts'].get(group, 0)
            if current_group >= group_max:
                return False

        # 3. Vérifier la limite du type de poste
        post_max = intervals.get(doctor.name, {}).get('weekend_posts', {}).get(post_type, {}).get('max', float('inf'))
        current_post = sum(
            counts.get(post_type, 0)
            for counts in doctor_state['post_counts'].values()
        )
        if current_post >= post_max:
            return False

        # 4. Vérifier toutes les autres contraintes via le système de contraintes
        return self.constraints.can_assign_to_assignee(doctor, date, slot, planning)

    def _distribute_minimum_requirements(self, planning: Planning, available_posts: Dict,
                                    intervals: Dict, doctor_states: Dict) -> None:
        """
        Distribution améliorée des minimums requis avec gestion prioritaire des groupes.
        """
        logger.info("\nDISTRIBUTION DES MINIMUMS REQUIS")
        logger.info("-" * 60)
        
        # Phase 1: Distribution basée sur les groupes
        logger.info("\nPhase 1: Distribution par groupe")
        
        # Trier les médecins par nombre de demi-parts décroissant
        sorted_doctors = sorted(self.doctors, key=lambda x: x.half_parts, reverse=True)
        
        for doctor in sorted_doctors:
            logger.info(f"\nTraitement de {doctor.name} ({doctor.half_parts} demi-parts)")
            doctor_state = doctor_states[doctor.name]
            
            while True:
                # Trouver le meilleur slot selon les priorités de groupe
                best_assignment = self._prioritize_group_distribution(
                    doctor, available_posts, doctor_state, planning, intervals
                )
                
                if not best_assignment:
                    break
                    
                post_type, date, slot = best_assignment
                
                # Effectuer l'attribution
                self._assign_post_and_update_state(
                    doctor, post_type, date, slot, planning, doctor_state
                )
                
                # Retirer le slot des disponibles
                day_type = ("saturday" if date.weekday() == 5 and 
                        not DayType.is_bridge_day(date, self.cal) 
                        else "sunday_holiday")
                if (date, slot) in available_posts[day_type][post_type]:
                    available_posts[day_type][post_type].remove((date, slot))
        
        # Phase 2: Distribution des postes individuels
        logger.info("\nPhase 2: Distribution des postes individuels")
        
        for doctor in sorted_doctors:
            doctor_intervals = intervals.get(doctor.name, {}).get('weekend_posts', {})
            doctor_state = doctor_states[doctor.name]
            
            for post_type in ALL_POST_TYPES:
                if post_type not in doctor_intervals:
                    continue
                    
                min_required = doctor_intervals[post_type]['min']
                current = sum(counts.get(post_type, 0) 
                            for counts in doctor_state['post_counts'].values())
                
                if current >= min_required:
                    continue
                    
                needed = min_required - current
                logger.info(f"{doctor.name}: {needed} {post_type} manquants")
                
                # Attribution par type de jour
                for day_type in ["saturday", "sunday_holiday"]:
                    if needed <= 0:
                        break

                    available_slots = available_posts[day_type].get(post_type, [])
                    # Trier les slots par criticité
                    critical_periods = self._get_critical_weekend_periods(planning)
                    critical_dates = {p['date']: p['availability'] for p in critical_periods}
                    available_slots.sort(key=lambda x: critical_dates.get(x[0], 100))
                    
                    for date, slot in available_slots[:]:  # Copie pour itération sûre
                        if (not slot.assignee and 
                            self._can_assign_post(doctor, post_type, date, slot,
                                            planning, intervals, doctor_state)):
                            # Effectuer l'attribution
                            self._assign_post_and_update_state(
                                doctor, post_type, date, slot, planning, doctor_state
                            )
                            
                            # Retirer le slot des disponibles
                            if (date, slot) in available_posts[day_type][post_type]:
                                available_posts[day_type][post_type].remove((date, slot))
                                
                            needed -= 1
                            if needed <= 0:
                                break

        # Vérification finale et log des résultats
        logger.info("\nRÉSULTATS DE LA DISTRIBUTION MINIMALE")
        logger.info("-" * 60)
        
        for doctor in sorted_doctors:
            group_tracking = self._track_group_minimums(doctor, planning, intervals)
            logger.info(f"\n{doctor.name}:")
            
            for group, data in group_tracking.items():
                if data['needed'] > 0:
                    logger.warning(f"  {group}: {data['needed']} postes manquants "
                            f"(actuel: {data['current']}/{data['min']})")
                else:
                    logger.info(f"  {group}: OK ({data['current']}/{data['min']})")

    def _track_group_minimums(self, doctor: Doctor, planning: Planning, intervals: Dict) -> Dict[str, Dict]:
        """
        Suit les minimums requis pour chaque groupe de postes pour un médecin.
        
        Args:
            doctor: Le médecin concerné
            planning: Le planning en cours
            intervals: Les intervalles de la pré-analyse
            
        Returns:
            Dict contenant pour chaque groupe:
                - current: nombre actuel de postes
                - min: minimum requis
                - needed: nombre encore nécessaire
        """
        # Groupes à suivre
        weekend_groups = ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]
        
        # Initialisation du suivi
        group_tracking = {}
        doctor_intervals = intervals.get(doctor.name, {}).get('weekend_groups', {})
        
        for group in weekend_groups:
            current_count = self._count_group_posts(doctor, group, planning)
            min_required = doctor_intervals.get(group, {}).get('min', 0)
            
            group_tracking[group] = {
                'current': current_count,
                'min': min_required,
                'needed': max(0, min_required - current_count)
            }
        
        return group_tracking

    def _update_distribution_priorities(self, doctor_states: Dict[str, Dict], 
                                    planning: Planning, intervals: Dict) -> Dict[str, List[str]]:
        """
        Détermine l'ordre de priorité des groupes pour la distribution en fonction des minimums manquants.
        
        Args:
            doctor_states: État actuel de la distribution par médecin
            planning: Le planning en cours
            intervals: Les intervalles de la pré-analyse
            
        Returns:
            Dict[str, List[str]]: Liste des groupes prioritaires par médecin
        """
        priorities = {}
        
        for doctor in self.doctors:
            # Suivre les minimums pour ce médecin
            group_tracking = self._track_group_minimums(doctor, planning, intervals)
            
            # Trier les groupes par nombre de postes manquants
            groups_needed = [(group, data['needed']) 
                            for group, data in group_tracking.items() 
                            if data['needed'] > 0]
                            
            # Trier par nombre de postes manquants décroissant
            sorted_groups = [group for group, needed in 
                            sorted(groups_needed, key=lambda x: x[1], reverse=True)]
                            
            priorities[doctor.name] = sorted_groups
            
            # Log des priorités
            if sorted_groups:
                logger.info(f"\nPriorités pour {doctor.name}:")
                for group in sorted_groups:
                    needed = group_tracking[group]['needed']
                    logger.info(f"  {group}: {needed} postes manquants")
                    
        return priorities

    def _prioritize_group_distribution(self, doctor: Doctor, 
                                    available_slots: Dict,
                                    doctor_state: Dict,
                                    planning: Planning,
                                    intervals: Dict) -> Optional[Tuple[str, date, TimeSlot]]:
        """
        Trouve le meilleur slot à attribuer en fonction des minimums de groupe.
        
        Returns:
            Tuple[str, date, TimeSlot] ou None: Le meilleur post à attribuer
        """
        # Obtenir les priorités actuelles
        group_tracking = self._track_group_minimums(doctor, planning, intervals)
        
        # Filtrer les groupes qui ont encore besoin de postes
        needed_groups = {group: data for group, data in group_tracking.items() 
                        if data['needed'] > 0}
        
        if not needed_groups:
            return None
            
        # Pour chaque groupe prioritaire
        for group, data in sorted(needed_groups.items(), 
                                key=lambda x: x[1]['needed'], 
                                reverse=True):
            # Récupérer les membres du groupe
            group_members = self._get_group_members(group)
            
            # Pour chaque type de jour
            for day_type in ["saturday", "sunday_holiday"]:
                for post_type in group_members:
                    if post_type not in available_slots[day_type]:
                        continue
                        
                    # Chercher un slot disponible pour ce post
                    for date, slot in available_slots[day_type][post_type]:
                        if (not slot.assignee and 
                            self._can_assign_post(doctor, post_type, date, slot, 
                                            planning, intervals, doctor_state)):
                            return post_type, date, slot
                            
        return None

    def _distribute_balanced_posts(self, planning: Planning, available_posts: Dict,
                                intervals: Dict, doctor_states: Dict) -> None:
        """
        Distribution équilibrée des postes restants après la phase minimale.
        Se concentre uniquement sur le respect des intervalles min/max avec une gestion
        améliorée des slots disponibles.
        """
        # Créer une copie de travail des posts disponibles pour éviter les problèmes de référence
        available_slots = {
            day_type: {
                post_type: [(date, slot) for date, slot in slots if not slot.assignee]
                for post_type, slots in day_posts.items()
            }
            for day_type, day_posts in available_posts.items()
        }

        # Pour chaque type de jour
        for day_type in ["saturday", "sunday_holiday"]:
            while any(slots for slots in available_slots[day_type].values()):
                doctors_copy = self.doctors.copy()
                random.shuffle(doctors_copy)
                assignment_made = False

                for doctor in doctors_copy:
                    doctor_state = doctor_states[doctor.name]

                    # Parcourir tous les types de postes disponibles
                    for post_type, slots in list(available_slots[day_type].items()):
                        if not slots:  # Ignorer les types de poste sans slots disponibles
                            continue

                        # Vérifier les limites du type de poste
                        post_max = intervals.get(doctor.name, {}).get('weekend_posts', {}).get(post_type, {}).get('max', float('inf'))
                        current_posts = sum(
                            counts.get(post_type, 0)
                            for counts in doctor_state['post_counts'].values()
                        )

                        if current_posts >= post_max:
                            continue

                        # Essayer chaque slot disponible
                        for idx, (date, slot) in enumerate(slots):
                            if self._can_assign_post(doctor, post_type, date, slot, planning, 
                                                intervals, doctor_state):
                                
                                # Vérification supplémentaire des postes du même jour
                                day = planning.get_day(date)
                                has_same_post_today = any(
                                    s.assignee == doctor.name and s.abbreviation == post_type
                                    for s in day.slots
                                )
                                if has_same_post_today:
                                    continue

                                # Attribution du slot
                                self._assign_post_and_update_state(doctor, post_type, date, slot, 
                                                                planning, doctor_state)
                                
                                # Retirer le slot des disponibles
                                slots.pop(idx)
                                
                                # Retirer aussi de available_posts pour cohérence
                                original_slots = available_posts[day_type][post_type]
                                if (date, slot) in original_slots:
                                    original_slots.remove((date, slot))
                                    
                                assignment_made = True
                                logger.debug(f"Attribution à {doctor.name}: {post_type} le {date}")
                                break

                        if assignment_made:
                            break

                # Si aucune attribution n'a été possible sur cette itération
                if not assignment_made:
                    # Compter et logger les slots non attribués
                    remaining = sum(len(slots) for slots in available_slots[day_type].values())
                    if remaining > 0:
                        logger.warning(f"{remaining} slots ({day_type}) n'ont pas pu être attribués")
                    break
    def _assign_post_and_update_state(self, doctor: Doctor, post_type: str,
                                    date: date, slot: TimeSlot, planning: Planning,
                                    doctor_state: Dict) -> None:
        """
        Attribue un poste et met à jour tous les compteurs d'état.
        """
        slot.assignee = doctor.name
        
        # Mettre à jour les compteurs de type de poste
        day_type = "saturday" if date.weekday() == 5 and not DayType.is_bridge_day(date, self.cal) else "sunday_holiday"
        doctor_state['post_counts'][day_type][post_type] = doctor_state['post_counts'][day_type].get(post_type, 0) + 1
        
        # Mettre à jour les compteurs de groupe
        group = self._get_post_group(post_type, date)
        if group:
            doctor_state['group_counts'][group] = doctor_state['group_counts'].get(group, 0) + 1
            
        logger.info(f"{doctor.name}: {post_type} attribué le {date} "
                    f"(groupe {group if group else 'N/A'})")

    def _verify_group_limits(self, planning: Planning, intervals: Dict) -> bool:
        """
        Vérifie que toutes les limites de groupe sont respectées.
        """
        all_ok = True
        for doctor in self.doctors:
            doctor_intervals = intervals.get(doctor.name, {}).get('weekend_groups', {})
            
            for group, max_allowed in doctor_intervals.items():
                current = self._count_group_posts(doctor, group, planning)
                if current > max_allowed.get('max', float('inf')):
                    logger.error(f"Dépassement pour {doctor.name}: "
                            f"groupe {group} = {current}/{max_allowed.get('max')}")
                    all_ok = False
                    
        return all_ok
    

    def _assign_needed_posts(self, doctor: Doctor, post_type: str, needed: int,
                            day_type: str, available_slots: List[Tuple[date, TimeSlot]],
                            planning: Planning) -> int:
        """
        Assigne un nombre déterminé de postes à un médecin en respectant toutes 
        les contraintes.

        Args:
            doctor (Doctor): Médecin à qui attribuer les postes
            post_type (str): Type de poste à attribuer (ex: ML, CM, etc.)
            needed (int): Nombre de postes à attribuer
            day_type (str): Type de jour (saturday/sunday_holiday)
            available_slots (List[Tuple[date, TimeSlot]]): Slots disponibles
            planning (Planning): Planning en cours

        Returns:
            int: Nombre de postes effectivement attribués
        """
        # Validations initiales
        if not doctor or not available_slots or needed <= 0:
            return 0

        # Initialisation
        assigned_count = 0
        doctor_intervals = planning.pre_analysis_results.get('ideal_distribution', {}).get(doctor.name, {})
        
        try:
            # Récupérer les compteurs actuels du médecin
            current_counts = self._get_doctor_weekend_counts(doctor, planning)
            
            # Pour chaque slot disponible
            for date, slot in available_slots:
                # Si on a atteint le nombre nécessaire
                if assigned_count >= needed:
                    break

                if slot.assignee:  # Déjà attribué
                    continue

                # Vérifications principales
                if not self._is_doctor_available_for_date(doctor, date, planning):
                    continue

                # Vérifier le maximum pour ce type de poste
                doctor_max = (doctor_intervals.get('weekend_posts', {})
                            .get(post_type, {})
                            .get('max', float('inf')))
                current_count = (current_counts.get(day_type, {})
                            .get(post_type, 0))
                if current_count >= doctor_max:
                    continue

                # Vérifier les limites de groupe
                group = self._get_post_group(post_type, date)
                if group:
                    group_intervals = doctor_intervals.get('weekend_groups', {}).get(group, {})
                    group_max = group_intervals.get('max', float('inf'))
                    group_count = self._count_group_posts(doctor, group, planning)
                    if group_count >= group_max:
                        continue

                # Vérifier les contraintes globales du planning
                if not self.constraints.can_assign_to_assignee(doctor, date, slot, planning):
                    continue

                # Attribution du slot
                slot.assignee = doctor.name
                assigned_count += 1

                # Log de l'attribution
                logger.info(f"{doctor.name} ({doctor.half_parts} demi-parts): "
                        f"{post_type} attribué le {date.strftime('%d/%m/%Y')} "
                        f"({assigned_count}/{needed})")

                # Mise à jour des compteurs
                current_counts[day_type][post_type] = current_count + 1

            # Log du résultat final
            if assigned_count < needed:
                logger.warning(
                    f"{doctor.name}: {assigned_count}/{needed} {post_type} attribués "
                    f"pour {day_type}")
            else:
                logger.info(
                    f"{doctor.name}: Attribution complète - {assigned_count} {post_type} "
                    f"pour {day_type}")

            return assigned_count

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution des postes pour {doctor.name}: {e}")
            return assigned_count  # Retourner le nombre attribué avant l'erreur

    def _check_group_limit(self, doctor: Doctor, post_type: str, date: date,
                        planning: Planning) -> bool:
        """Vérifie si l'attribution respecte les limites de groupe."""
        # Identifier le groupe du poste
        group = self._get_post_group(post_type, date)
        if not group:
            return True  # Pas de groupe = pas de limite
            
        # Récupérer l'intervalle du groupe
        intervals = planning.pre_analysis_results.get('ideal_distribution', {})
        group_intervals = intervals.get(doctor.name, {}).get('weekend_groups', {})
        if group not in group_intervals:
            return True
            
        # Compter les postes actuels du groupe
        current_count = self._count_group_posts(doctor, group, planning)
        max_count = group_intervals[group].get('max', float('inf'))
        
        return current_count < max_count

    def _get_doctor_weekend_counts(self, doctor: Doctor, planning: Planning) -> Dict:
        """Compte les postes weekend déjà attribués à un médecin."""
        counts = {
            "saturday": defaultdict(int),
            "sunday_holiday": defaultdict(int)
        }
        
        for day in planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge):
                continue
                
            day_type = "saturday" if day.date.weekday() == 5 and not DayType.is_bridge_day(day.date, self.cal) else "sunday_holiday"
            
            for slot in day.slots:
                if slot.assignee == doctor.name:
                    counts[day_type][slot.abbreviation] += 1
                    
        return counts

    def _count_unassigned_slots(self, planning: Planning) -> int:
        """Compte les slots weekend non attribués."""
        count = 0
        for day in planning.days:
            if day.is_weekend or day.is_holiday_or_bridge:
                count += sum(1 for slot in day.slots if not slot.assignee)
        return count
    
    
    
    def _get_post_group(self, post_type: str, date: date) -> Optional[str]:
        """
        Détermine le groupe weekend du poste.
        
        Args:
            post_type: Type de poste (ML, CM, etc.)
            date: Date du poste
            
        Returns:
            str: Nom du groupe ou None si le poste n'appartient à aucun groupe
        """
        # Vérifier si c'est un poste personnalisé
        if post_type in self.custom_posts:
            return self.custom_posts[post_type].statistic_group

        # Déterminer le type de jour
        is_saturday = date.weekday() == 5 and not self.is_bridge_day(date)

        # Groupes de consultation matin
        if post_type in ["MM", "CM", "HM", "SM", "RM"]:
            return "CmS" if is_saturday else "CmD"

        # Groupes de consultation après-midi
        elif post_type in ["CA", "HA", "SA", "RA"]:
            return "CaSD"  # Même groupe pour samedi et dimanche

        # Groupes de consultation soir
        elif post_type in ["CS", "HS", "SS", "RS"]:
            return "CsSD"  # Même groupe pour samedi et dimanche

        # Groupes de visites matin
        elif post_type in ["ML", "MC"]:
            return "VmS" if is_saturday else "VmD"

        # Groupes de visites après-midi
        elif post_type in ["AL", "AC"]:
            return "VaSD"  # Même groupe pour samedi et dimanche

        # Groupes de nuit
        elif post_type in ["NM", "NA"]:
            return "NAMw"  # Groupe commun weekend

        # NL week-end
        elif post_type == "NL":
            if date.weekday() == 4:  # Vendredi
                return "NLw"  # NLv compte dans le groupe NLw
            elif is_saturday:
                return "NLw"  # NLs compte dans le groupe NLw
            else:
                return "NLw"  # NLd compte dans le groupe NLw

        return None

    def _count_group_posts(self, doctor: Doctor, group: str, planning: Planning) -> int:
        """
        Compte précisément le nombre de postes d'un groupe déjà attribués à un médecin.
        """
        count = 0
        
        # Mappings des postes par groupe
        group_mappings = {
            "CmS": ["MM", "CM", "HM", "SM", "RM"],  # Consultation matin samedi
            "CmD": ["MM", "CM", "HM", "SM", "RM"],  # Consultation matin dimanche
            "CaSD": ["CA", "HA", "SA", "RA"],  # Consultation après-midi samedi/dimanche
            "CsSD": ["CS", "HS", "SS", "RS"],  # Consultation soir samedi/dimanche
            "VmS": ["ML", "MC"],  # Visites matin samedi
            "VmD": ["ML", "MC"],  # Visites matin dimanche
            "VaSD": ["AL", "AC"],  # Visites après-midi samedi/dimanche
        }
        
        posts_to_count = group_mappings.get(group, [])
        
        # Ajouter les postes personnalisés du même groupe
        for post_name, custom_post in self.custom_posts.items():
            if custom_post.statistic_group == group:
                posts_to_count.append(post_name)
                
        # Comptage précis par type de jour
        for day in planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge):
                continue

            # Pour les groupes spécifiques au samedi
            is_saturday = day.date.weekday() == 5 and not self.is_bridge_day(day.date)
            if group in ["CmS", "VmS"] and not is_saturday:
                continue

            # Pour les groupes spécifiques au dimanche
            if group in ["CmD", "VmD"] and is_saturday:
                continue

            count += sum(1 for slot in day.slots
                        if slot.assignee == doctor.name
                        and slot.abbreviation in posts_to_count)
                        
        return count

    def _get_group_members(self, group: str) -> List[str]:
        """
        Retourne la liste des types de poste appartenant à un groupe.
        
        Args:
            group: Nom du groupe
            
        Returns:
            List[str]: Liste des types de poste du groupe
        """
        # Définition des groupes standard
        standard_groups = {
            "CmS": ["MM", "CM", "HM", "SM", "RM"],  # Consultation matin samedi
            "CmD": ["MM", "CM", "HM", "SM", "RM"],  # Consultation matin dimanche
            "CaSD": ["CA", "HA", "SA", "RA"],  # Consultation après-midi samedi/dimanche
            "CsSD": ["CS", "HS", "SS", "RS"],  # Consultation soir samedi/dimanche
            "VmS": ["ML", "MC"],  # Visites matin samedi
            "VmD": ["ML", "MC"],  # Visites matin dimanche
            "VaSD": ["AL", "AC"],  # Visites après-midi samedi/dimanche
            "NAMw": ["NM", "NA"],  # Nuits courtes/moyennes weekend
            "NLw": ["NL"]  # Nuits longues weekend
        }
        
        members = standard_groups.get(group, []).copy()
        
        # Ajouter les postes personnalisés du groupe
        for post_name, custom_post in self.custom_posts.items():
            if custom_post.statistic_group == group:
                members.append(post_name)
                
        return members

    def _get_group_stats(self, group: str, planning: Planning) -> Dict:
        """
        Calcule les statistiques d'utilisation d'un groupe.
        
        Args:
            group: Nom du groupe
            planning: Le planning en cours
            
        Returns:
            Dict: Statistiques du groupe (total, par médecin, etc.)
        """
        stats = {
            "total": 0,
            "by_doctor": defaultdict(int),
            "by_type": defaultdict(int)
        }
        
        members = self._get_group_members(group)
        
        for day in planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge):
                if not (group == "NLw" and day.date.weekday() == 4):  # NLv compte pour NLw
                    continue

            for slot in day.slots:
                if slot.abbreviation in members and slot.assignee:
                    stats["total"] += 1
                    stats["by_doctor"][slot.assignee] += 1
                    stats["by_type"][slot.abbreviation] += 1
                    
        return stats
    
    def _get_remaining_slots(self, available_posts: Dict) -> Dict:
        """
        Récupère les slots encore disponibles, filtrés et organisés.
        
        Args:
            available_posts: Structure de données contenant tous les posts disponibles
                Format: {
                    "saturday": {post_type: [(date, slot), ...], ...},
                    "sunday_holiday": {post_type: [(date, slot), ...], ...}
                }
        
        Returns:
            Dict: Slots restants filtrés et organisés
                Format similaire à available_posts mais uniquement avec les slots non assignés
        """
        remaining = {
            "saturday": defaultdict(list),
            "sunday_holiday": defaultdict(list)
        }
        
        # Pour chaque type de jour
        for day_type, day_posts in available_posts.items():
            # Pour chaque type de poste
            for post_type, slots in day_posts.items():
                # Ne garder que les slots non assignés
                remaining_slots = [(date, slot) for date, slot in slots if not slot.assignee]
                if remaining_slots:
                    remaining[day_type][post_type] = remaining_slots
                    count = len(remaining_slots)
                    logger.debug(f"Slots restants {day_type} {post_type}: {count}")

        return remaining

    def _get_remaining_slots_for_group(self, group: str, available_posts: Dict) -> List[Tuple[date, TimeSlot]]:
        """
        Récupère tous les slots disponibles pour un groupe donné.
        
        Args:
            group: Nom du groupe (CmS, CmD, etc.)
            available_posts: Structure des posts disponibles
            
        Returns:
            List[Tuple[date, TimeSlot]]: Liste des slots disponibles pour ce groupe
        """
        remaining_slots = []
        group_members = self._get_group_members(group)
        
        for day_type, day_posts in available_posts.items():
            for post_type, slots in day_posts.items():
                if post_type in group_members:
                    # Filtrer selon le type de jour si nécessaire
                    for date, slot in slots:
                        slot_group = self._get_post_group(post_type, date)
                        if slot_group == group and not slot.assignee:
                            remaining_slots.append((date, slot))
        
        return remaining_slots

    def _get_slots_by_criticality(self, available_posts: Dict, planning: Planning = None) -> Dict[str, List[Tuple[date, TimeSlot]]]:
        """
        Organise les slots disponibles par niveau de criticité.
        
        Args:
            available_posts: Structure des posts disponibles
            
        Returns:
            Dict: Slots organisés par niveau de criticité
                Keys: "critical", "high", "normal"
        """
        slots_by_criticality = {
            "critical": [],  # < 40% disponibilité
            "high": [],     # 40-60% disponibilité
            "normal": []    # > 60% disponibilité
        }
        
        # Récupérer les périodes critiques
        critical_periods = self._get_critical_weekend_periods(planning)
        critical_dates = {period['date']: period['availability'] for period in critical_periods}
        
        # Pour chaque type de jour
        for day_type, day_posts in available_posts.items():
            for post_type, slots in day_posts.items():
                for date, slot in slots:
                    if not slot.assignee:
                        availability = critical_dates.get(date, 100)  # 100% par défaut
                        if availability < 40:
                            slots_by_criticality["critical"].append((date, slot))
                        elif availability < 60:
                            slots_by_criticality["high"].append((date, slot))
                        else:
                            slots_by_criticality["normal"].append((date, slot))
        
        # Log du résultat
        for criticality, slots in slots_by_criticality.items():
            logger.debug(f"Slots {criticality}: {len(slots)}")
        
        return slots_by_criticality

    
    
    def _distribute_final_posts(self, planning: Planning, available_posts: Dict,
                            intervals: Dict, doctor_states: Dict) -> bool:
        """
        Distribution finale de tous les postes restants non attribués.
        Processus en 4 étapes avec réattribution des postes si nécessaire.
        """
        try:
            # Collecte des slots restants
            remaining_slots = self._get_remaining_slots(available_posts)
            if not any(slots for day_slots in remaining_slots.values() 
                    for slots in day_slots.values()):
                return True

            initial_remaining = self._count_total_remaining(remaining_slots)
            logger.info(f"\nDISTRIBUTION FINALE: {initial_remaining} postes à attribuer")
            logger.info("=" * 80)

            # 1. Distribution aux CAT sous leurs quotas
            logger.info("\nPHASE 1: Distribution aux CAT sous quotas")
            self._distribute_remaining_to_cats_with_quotas(planning, remaining_slots)
            remaining_after_cats = self._count_total_remaining(remaining_slots)
            logger.info(f"Postes restants après CAT: {remaining_after_cats}")

            # 2. Distribution aux médecins sous minimum de groupe
            if remaining_after_cats > 0:
                logger.info("\nPHASE 2: Distribution aux médecins sous minimum")
                self._distribute_to_doctors_under_minimum(
                    planning, remaining_slots, intervals, doctor_states
                )
                remaining_after_min = self._count_total_remaining(remaining_slots)
                logger.info(f"Postes restants après minimum: {remaining_after_min}")

            # 3. Distribution avec assouplissement des desideratas
            if remaining_after_min > 0:
                logger.info("\nPHASE 3: Distribution avec assouplissement")
                remaining = self._distribute_with_relaxed_constraints(
                    planning, remaining_slots, intervals, doctor_states
                )
                logger.info(f"Postes restants après assouplissement: {remaining}")

                # 4. Réattribution si nécessaire
            if remaining > 0:
                logger.info("\nPHASE 4: Processus de réattribution")
                for day_type in ["saturday", "sunday_holiday"]:
                    for post_type, slots in list(remaining_slots[day_type].items()):
                        for date, slot in slots[:]:
                            if slot.assignee:
                                continue
                                
                            logger.info(f"\nTraitement du poste {post_type} du {date}")
                            
                            # Trouver les médecins disponibles
                            available_doctors = self._get_available_doctors_for_forced(
                                planning, date, slot
                            )

                            for doctor in available_doctors:
                                # Tenter l'attribution forcée
                                if self._force_assign_post(doctor, date, slot, post_type, 
                                                    planning, doctor_states):
                                    logger.info(f"Attribution forcée à {doctor.name}")
                                    
                                    # Tenter le rééquilibrage
                                    success = self._try_rebalance_group(
                                        doctor, post_type, date, planning, 
                                        intervals, doctor_states
                                    )
                                    
                                    if success:
                                        slots.remove((date, slot))
                                        break
                                    else:
                                        # Si échec du rééquilibrage, annuler l'attribution
                                        slot.assignee = None

                # Vérification finale
                remaining = sum(
                    len(slots) for day_slots in remaining_slots.values()
                    for slots in day_slots.values()
                )
                if remaining == 0:
                    logger.info("Réattribution réussie - tous les postes sont attribués")
                    return True
                else:
                    logger.error(f"Distribution incomplète: {remaining} postes non attribués")
                    self._log_unassigned_posts(remaining_slots)
                    return False

            logger.info("\nDistribution finale terminée avec succès")
            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution finale: {e}")
            return False

    def _count_total_remaining(self, remaining_slots: Dict) -> int:
        """Compte le nombre total de slots restants à attribuer."""
        return sum(
            len(slots) for day_slots in remaining_slots.values()
            for slots in day_slots.values()
        )

    def _log_unassigned_posts(self, remaining_slots: Dict) -> None:
        """Log détaillé des postes non attribués."""
        logger.warning("\nDétail des postes non attribués:")
        for day_type in ["saturday", "sunday_holiday"]:
            unassigned = {
                post_type: [(date.strftime("%Y-%m-%d"), slot.abbreviation)
                        for date, slot in slots]
                for post_type, slots in remaining_slots[day_type].items()
                if slots
            }
            if unassigned:
                logger.warning(f"\n{day_type.upper()}:")
                for post_type, dates_slots in unassigned.items():
                    for date, abbrev in dates_slots:
                        logger.warning(f"  - {abbrev} le {date}")

    def _distribute_remaining_to_cats_with_quotas(self, planning: Planning, 
                                                remaining_slots: Dict) -> None:
        """Distribution aux CAT n'ayant pas atteint leurs quotas."""
        # Calcul des quotas restants pour les CAT
        cat_quotas = self._calculate_cat_remaining_quotas(planning)

        # Pour chaque type de jour
        for day_type in ["saturday", "sunday_holiday"]:
            # Pour chaque type de poste restant
            for post_type, slots in list(remaining_slots[day_type].items()):
                if not slots:
                    continue

                # Pour chaque CAT n'ayant pas atteint son quota
                for cat in self.cats:
                    quota = cat_quotas[cat.name][day_type].get(post_type, 0)
                    if quota <= 0:
                        continue

                    # Pour chaque slot disponible
                    for idx, (date, slot) in enumerate(slots[:]):
                        if not slot.assignee:
                            # Essayer d'abord sans ignorer les desideratas secondaires
                            assigned = self._try_assign_to_cat(
                                cat, date, slot, planning, respect_secondary=True
                            )
                            
                            # Si impossible, essayer en ignorant les desideratas secondaires
                            if not assigned:
                                assigned = self._try_assign_to_cat(
                                    cat, date, slot, planning, respect_secondary=False
                                )

                            if assigned:
                                slots.pop(idx)
                                quota -= 1
                                if quota <= 0:
                                    break
    def _try_assign_to_cat(self, cat: CAT, date: date, slot: TimeSlot, 
                            planning: Planning, respect_secondary: bool = True) -> bool:
        """
        Tente d'attribuer un poste à un CAT.
        
        Args:
            cat: Le CAT à qui attribuer le poste
            date: Date du poste
            slot: Slot à attribuer
            planning: Planning en cours
            respect_secondary: Si False, ignore les desideratas secondaires
            
        Returns:
            bool: True si l'attribution est réussie, False sinon
        """
        try:
            # 1. Vérification des desideratas
            if respect_secondary:
                # Vérification normale avec tous les desideratas
                if not self.constraints.can_assign_to_assignee(cat, date, slot, planning):
                    return False
            else:
                # Vérifier uniquement les desideratas primaires
                for desiderata in cat.desiderata:
                    if (not hasattr(desiderata, 'priority') or 
                        desiderata.priority == "primary"):
                        if (desiderata.start_date <= date <= desiderata.end_date and
                            desiderata.overlaps_with_slot(slot)):
                            return False

                # Vérifier les autres contraintes (repos, chevauchement)
                temp_desiderata = cat.desiderata
                cat.desiderata = [d for d in cat.desiderata 
                                if not hasattr(d, 'priority') or 
                                d.priority == "primary"]
                can_assign = self.constraints.can_assign_to_assignee(cat, date, slot, planning)
                cat.desiderata = temp_desiderata
                
                if not can_assign:
                    return False

            # 2. Attribution du poste
            slot.assignee = cat.name
            logger.info(f"CAT {cat.name}: {slot.abbreviation} attribué le {date} "
                        f"{'(sans desiderata secondaire)' if not respect_secondary else ''}")
            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution au CAT {cat.name}: {e}")
            return False
        
        
    def _distribute_to_doctors_under_minimum(self, planning: Planning, 
                                        remaining_slots: Dict,
                                        intervals: Dict,
                                        doctor_states: Dict) -> None:
        """Distribution prioritaire aux médecins sous le minimum de groupe."""
        # Pour chaque type de jour
        for day_type in ["saturday", "sunday_holiday"]:
            # Pour chaque type de poste
            for post_type, slots in list(remaining_slots[day_type].items()):
                if not slots:
                    continue

                # Pour chaque slot
                for date, slot in slots[:]:
                    if slot.assignee:
                        continue

                    # Identifier le groupe du poste
                    group = self._get_post_group(post_type, date)
                    if not group:
                        continue

                    # Trouver les médecins sous le minimum pour ce groupe
                    doctors_under_min = []
                    for doctor in self.doctors:
                        doctor_intervals = intervals.get(doctor.name, {})
                        group_min = (doctor_intervals.get('weekend_groups', {})
                                .get(group, {})
                                .get('min', 0))
                        current = doctor_states[doctor.name]['group_counts'].get(group, 0)
                        
                        if current < group_min:
                            doctors_under_min.append((doctor, group_min - current))

                    # Trier par écart au minimum décroissant
                    doctors_under_min.sort(key=lambda x: x[1], reverse=True)

                    # Essayer d'attribuer aux médecins sous le minimum
                    for doctor, _ in doctors_under_min:
                        if self._try_assign_post(
                            doctor, date, slot, post_type, planning, 
                            intervals, doctor_states
                        ):
                            slots.remove((date, slot))
                            break

    def _distribute_with_relaxed_constraints(self, planning: Planning,
                                        remaining_slots: Dict,
                                        intervals: Dict,
                                        doctor_states: Dict) -> int:
        """
        Distribution finale avec assouplissement des contraintes.
        Retourne le nombre de slots non attribués.
        """
        # Compter les desideratas par médecin
        desiderata_counts = {
            doctor.name: len(doctor.desiderata)
            for doctor in self.doctors
        }

        # Pour chaque type de jour
        for day_type in ["saturday", "sunday_holiday"]:
            for post_type, slots in list(remaining_slots[day_type].items()):
                for date, slot in slots[:]:
                    if slot.assignee:
                        continue

                    # Identifier le groupe du poste
                    group = self._get_post_group(post_type, date)

                    # Trouver les médecins disponibles ce jour
                    available_doctors = []
                    for doctor in self.doctors:
                        # Vérifier si le médecin est sous le maximum du groupe
                        if group:
                            max_allowed = (intervals.get(doctor.name, {})
                                        .get('weekend_groups', {})
                                        .get(group, {})
                                        .get('max', float('inf')))
                            current = doctor_states[doctor.name]['group_counts'].get(group, 0)
                            if current >= max_allowed:
                                continue

                        # Vérifier si le médecin a un desiderata secondaire
                        has_secondary = False
                        for desiderata in doctor.desiderata:
                            if (hasattr(desiderata, 'priority') and 
                                desiderata.priority == "secondary" and
                                desiderata.start_date <= date <= desiderata.end_date):
                                has_secondary = True
                                break

                        if has_secondary:
                            # Score basé sur le minimum de groupe et le nombre de desideratas
                            group_min = (intervals.get(doctor.name, {})
                                    .get('weekend_groups', {})
                                    .get(group, {})
                                    .get('min', 0))
                            current = doctor_states[doctor.name]['group_counts'].get(group, 0)
                            under_min = max(0, group_min - current)
                            
                            desiderata_score = desiderata_counts[doctor.name]
                            score = (under_min * 100) + desiderata_score  # Priorité au minimum
                            
                            available_doctors.append((doctor, score))

                    # Trier par score décroissant
                    available_doctors.sort(key=lambda x: x[1], reverse=True)

                    # Essayer d'attribuer le poste
                    for doctor, _ in available_doctors:
                        if self._try_assign_post(
                            doctor, date, slot, post_type, planning,
                            intervals, doctor_states,
                            ignore_secondary=True  # Ignorer les desideratas secondaires
                        ):
                            slots.remove((date, slot))
                            break

        # Compter les slots restants non attribués
        remaining = sum(len(slots) for day_slots in remaining_slots.values()
                    for slots in day_slots.values())
        return remaining

    def _try_assign_post(self, doctor: Doctor, date: date, slot: TimeSlot,
                        post_type: str, planning: Planning,
                        intervals: Dict, doctor_states: Dict,
                        ignore_secondary: bool = False) -> bool:
        """
        Version corrigée de la tentative d'attribution d'un poste.
        Gère correctement les compteurs de groupe.
        """
        try:
            # Initialiser l'état du docteur s'il n'existe pas
            if doctor.name not in doctor_states:
                doctor_states[doctor.name] = {
                    'post_counts': self._get_doctor_weekend_counts(doctor, planning),
                    'group_counts': {
                        group: self._count_group_posts(doctor, group, planning)
                        for group in ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]
                    }
                }
            
            # Vérifier les contraintes de base
            day = planning.get_day(date)
            if not day:
                return False

            # Vérification des chevauchements
            for existing_slot in day.slots:
                if existing_slot.assignee == doctor.name:
                    if (slot.start_time < existing_slot.end_time and 
                        slot.end_time > existing_slot.start_time):
                        return False

            # Si on ignore les desideratas secondaires
            if ignore_secondary:
                has_primary = False
                for desiderata in doctor.desiderata:
                    if (not hasattr(desiderata, 'priority') or 
                        desiderata.priority == "primary"):
                        if (desiderata.start_date <= date <= desiderata.end_date and
                            desiderata.overlaps_with_slot(slot)):
                            has_primary = True
                            break
                if has_primary:
                    return False
            else:
                # Vérification normale des desideratas
                if not self.constraints.can_assign_to_assignee(
                    doctor, date, slot, planning
                ):
                    return False

            # Attribution et mise à jour des compteurs
            slot.assignee = doctor.name

            # Mise à jour des compteurs de groupe
            group = self._get_post_group(post_type, date)
            if group:
                doctor_states[doctor.name]['group_counts'][group] = (
                    doctor_states[doctor.name]['group_counts'].get(group, 0) + 1
                )

            # Mise à jour des compteurs de poste
            day_type = ("saturday" if date.weekday() == 5 and 
                    not self.is_bridge_day(date) else "sunday_holiday")
            if day_type not in doctor_states[doctor.name]['post_counts']:
                doctor_states[doctor.name]['post_counts'][day_type] = {}
            doctor_states[doctor.name]['post_counts'][day_type][post_type] = (
                doctor_states[doctor.name]['post_counts'][day_type].get(post_type, 0) + 1
            )

            logger.info(f"{doctor.name}: {post_type} attribué le {date} "
                    f"(groupe {group if group else 'N/A'})")
            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution à {doctor.name}: {e}")
            return False
    
    
    def _get_available_doctors_for_forced(self, planning: Planning, date: date, 
                                    slot: TimeSlot) -> List[Doctor]:
        """
        Retourne la liste des médecins disponibles pour une attribution forcée.
        Ne vérifie que les contraintes de base (repos, chevauchement).
        """
        available_doctors = []
        
        for doctor in self.doctors:
            # Vérifier uniquement les contraintes critiques
            available = True
            
            # 1. Vérifier les desideratas primaires
            for desiderata in doctor.desiderata:
                if (not hasattr(desiderata, 'priority') or 
                    desiderata.priority == "primary"):
                    if (desiderata.start_date <= date <= desiderata.end_date and
                        desiderata.overlaps_with_slot(slot)):
                        available = False
                        break
            
            if not available:
                continue
            
            # 2. Vérifier les chevauchements
            day = planning.get_day(date)
            if day:
                for existing_slot in day.slots:
                    if existing_slot.assignee == doctor.name:
                        if (slot.start_time < existing_slot.end_time and 
                            slot.end_time > existing_slot.start_time):
                            available = False
                            break
            
            if available:
                available_doctors.append(doctor)
        
        # Trier les médecins (pleins temps d'abord)
        return sorted(available_doctors, key=lambda d: d.half_parts, reverse=True)
    
    
    def _reattribute_remaining_posts(self, planning: Planning, 
                                    remaining_slots: Dict, 
                                    intervals: Dict,
                                    doctor_states: Dict) -> bool:
        """
        Processus de réattribution des postes non attribués avec rééquilibrage.
        
        Returns:
            bool: True si tous les postes ont été attribués
        """
        try:
            logger.info("\nDÉMARRAGE DU PROCESSUS DE RÉATTRIBUTION")
            logger.info("=" * 80)

            # Créer une copie de sauvegarde du planning initial
            initial_state = self._save_planning_state(planning)
            best_state = None
            min_unassigned = float('inf')

            # Pour chaque poste non attribué
            for day_type in ["saturday", "sunday_holiday"]:
                for post_type, slots in list(remaining_slots[day_type].items()):
                    for date, slot in slots[:]:
                        if slot.assignee:
                            continue

                        logger.info(f"\nTraitement du poste {post_type} du {date}")
                        
                        # Identifier les médecins disponibles (sans contrainte de groupe)
                        available_doctors = self._get_available_doctors_for_forced(
                            planning, date, slot
                        )

                        for doctor in available_doctors:
                            # Sauvegarder l'état avant tentative
                            current_state = self._save_planning_state(planning)

                            # 1. Attribution forcée
                            if self._force_assign_post(doctor, date, slot, post_type, planning):
                                logger.info(f"Attribution forcée à {doctor.name}")

                                # 2. Tenter le rééquilibrage
                                if self._try_rebalance_group(
                                    doctor, post_type, date, planning, intervals
                                ):
                                    # Vérifier si c'est la meilleure solution
                                    unassigned = self._count_unassigned_slots(planning)
                                    if unassigned < min_unassigned:
                                        min_unassigned = unassigned
                                        best_state = self._save_planning_state(planning)
                                        logger.info("Nouvelle meilleure solution trouvée")

                                # Revenir à l'état avant tentative
                                self._restore_planning_state(planning, current_state)

            # Restaurer la meilleure solution si trouvée
            if best_state is not None:
                logger.info("\nApplication de la meilleure solution")
                self._restore_planning_state(planning, best_state)
                return min_unassigned == 0
            else:
                # Restaurer l'état initial si aucune solution
                logger.warning("\nAucune solution trouvée")
                self._restore_planning_state(planning, initial_state)
                return False

        except Exception as e:
            logger.error(f"Erreur dans le processus de réattribution: {e}")
            return False

    def _save_planning_state(self, planning: Planning) -> Dict:
        """
        Crée une copie de l'état actuel du planning.
        """
        state = {
            'assignments': []
        }
        
        for day in planning.days:
            for slot in day.slots:
                if slot.assignee:
                    state['assignments'].append({
                        'date': day.date,
                        'post_type': slot.abbreviation,
                        'assignee': slot.assignee
                    })
        
        return state

    def _restore_planning_state(self, planning: Planning, state: Dict) -> None:
        """
        Restaure un état sauvegardé du planning.
        """
        # Réinitialiser tous les slots
        for day in planning.days:
            for slot in day.slots:
                slot.assignee = None
                
        # Restaurer les assignations
        for assignment in state['assignments']:
            date = assignment['date']
            post_type = assignment['post_type']
            assignee = assignment['assignee']
            
            day = planning.get_day(date)
            if day:
                for slot in day.slots:
                    if slot.abbreviation == post_type and not slot.assignee:
                        slot.assignee = assignee
                        break

    

    def _try_rebalance_group(self, doctor: Doctor, post_type: str, date: date,
                            planning: Planning, intervals: Dict, doctor_states: Dict) -> bool:
        """
        Tente de rééquilibrer un groupe en retirant et réattribuant un poste.
        """
        try:
            group = self._get_post_group(post_type, date)
            if not group:
                return False

            # 1. Trouver tous les postes du même groupe attribués à ce médecin
            group_posts = self._find_group_posts(doctor, group, planning)
            if not group_posts:
                return False

            # 2. Trier par facilité de réattribution
            sorted_posts = self._sort_posts_by_reattribution_ease(
                group_posts, planning, intervals
            )

            # 3. Essayer de réattribuer chaque poste
            for old_date, old_slot in sorted_posts:
                # Sauvegarder l'assignation actuelle
                original_assignee = old_slot.assignee
                old_slot.assignee = None

                # Chercher un nouveau médecin pour ce poste
                if self._reassign_post(old_date, old_slot, planning, intervals, 
                                doctor_states, [doctor.name]):
                    logger.info(f"Rééquilibrage réussi pour {post_type} du {date}")
                    return True

                # Restaurer si échec
                old_slot.assignee = original_assignee

            return False

        except Exception as e:
            logger.error(f"Erreur lors du rééquilibrage: {e}")
            return False

    def _force_assign_post(self, doctor: Doctor, date: date, slot: TimeSlot,
                        post_type: str, planning: Planning, doctor_states: Dict) -> bool:
        """
        Force l'attribution d'un poste sans vérifier les limites de groupe.
        Vérifie uniquement les contraintes de repos et chevauchement.
        """
        try:
            # Vérifie uniquement les contraintes de base
            day = planning.get_day(date)
            if not day:
                return False

            # Vérifier les contraintes de repos et chevauchement
            for existing_slot in day.slots:
                if existing_slot.assignee == doctor.name:
                    if (slot.start_time < existing_slot.end_time and 
                        slot.end_time > existing_slot.start_time):
                        return False

            # Force l'attribution et met à jour les compteurs
            slot.assignee = doctor.name
            
            # Mise à jour des compteurs
            group = self._get_post_group(post_type, date)
            if group:
                if 'group_counts' not in doctor_states[doctor.name]:
                    doctor_states[doctor.name]['group_counts'] = {}
                doctor_states[doctor.name]['group_counts'][group] = (
                    doctor_states[doctor.name]['group_counts'].get(group, 0) + 1
                )

            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution forcée: {e}")
            return False

    def _find_group_posts(self, doctor: Doctor, group: str, 
                        planning: Planning) -> List[Tuple[date, TimeSlot]]:
        """
        Trouve tous les postes d'un groupe attribués à un médecin.
        Les retourne triés par date.
        """
        group_posts = []
        
        for day in planning.days:
            for slot in day.slots:
                if (slot.assignee == doctor.name and 
                    self._get_post_group(slot.abbreviation, day.date) == group):
                    group_posts.append((day.date, slot))
                    
        return sorted(group_posts, key=lambda x: x[0])

    def _sort_posts_by_reattribution_ease(self, posts: List[Tuple[date, TimeSlot]],
                                    planning: Planning,
                                    intervals: Dict) -> List[Tuple[date, TimeSlot]]:
        """
        Trie les postes par facilité de réattribution estimée.
        """
        def get_reattribution_score(date_slot: Tuple[date, TimeSlot]) -> float:
            date, slot = date_slot
            score = 0.0
            
            # Compter les médecins disponibles et sous leur maximum
            available_count = 0
            for doctor in self.doctors:
                if self._can_potentially_take_post(doctor, date, slot, planning, intervals):
                    available_count += 1
                    
            # Score basé sur le nombre de médecins disponibles
            score = available_count / len(self.doctors)
            
            # Bonus pour les dates plus éloignées
            days_ahead = (date - planning.start_date).days
            score += days_ahead * 0.01
            
            return score

        return sorted(posts, key=get_reattribution_score, reverse=True)

    def _can_potentially_take_post(self, doctor: Doctor, date: date, 
                            slot: TimeSlot, planning: Planning,
                            intervals: Dict) -> bool:
        """
        Vérifie si un médecin pourrait potentiellement prendre un poste,
        même avec des desideratas secondaires.
        """
        # Vérifier les contraintes de base (repos, chevauchement)
        day = planning.get_day(date)
        if not day:
            return False
            
        for existing_slot in day.slots:
            if existing_slot.assignee == doctor.name:
                if (slot.start_time < existing_slot.end_time and 
                    slot.end_time > existing_slot.start_time):
                    return False

        # Vérifier la limite de groupe
        group = self._get_post_group(slot.abbreviation, date)
        if group:
            current = self._count_group_posts(doctor, group, planning)
            max_allowed = (intervals.get(doctor.name, {})
                        .get('weekend_groups', {})
                        .get(group, {})
                        .get('max', float('inf')))
            if current >= max_allowed:
                return False

        # Vérifier uniquement les desideratas primaires
        for desiderata in doctor.desiderata:
            if (not hasattr(desiderata, 'priority') or 
                desiderata.priority == "primary"):
                if (desiderata.start_date <= date <= desiderata.end_date and
                    desiderata.overlaps_with_slot(slot)):
                    return False

        return True

    def _reassign_post(self, date: date, slot: TimeSlot, planning: Planning,
                    intervals: Dict, doctor_states: Dict, excluded_doctors: List[str]) -> bool:
        """
        Tente de réattribuer un poste à un nouveau médecin.
        """
        try:
            # Identifier les médecins potentiels
            available_doctors = [
                doctor for doctor in self.doctors
                if doctor.name not in excluded_doctors and
                self._can_potentially_take_post(doctor, date, slot, planning, intervals)
            ]

            # Trier par préférence (médecins pleins temps d'abord)
            available_doctors.sort(key=lambda d: d.half_parts, reverse=True)
            
            # Essayer d'attribuer
            for doctor in available_doctors:
                if self._try_assign_post(
                    doctor, date, slot, slot.abbreviation,
                    planning, intervals, doctor_states, ignore_secondary=True
                ):
                    logger.info(f"Poste réattribué à {doctor.name}")
                    return True

            return False

        except Exception as e:
            logger.error(f"Erreur lors de la réattribution: {e}")
            return False

# core/Generator/weekday_gen.py

from datetime import datetime, date, timedelta, time
from typing import List, Dict, Optional, Tuple, Set
import random
import logging
from collections import defaultdict
from core.Constantes.models import Doctor, CAT, Planning, DayPlanning, TimeSlot, WEEKDAY_COMBINATIONS, ALL_POST_TYPES, WEEKDAY_PRIORITY_GROUPS, PRIORITY_WEIGHTS
from core.Constantes.constraints import PlanningConstraints
from core.Constantes.day_type import DayType
from core.Constantes.data_persistence import DataPersistence
from core.Constantes.custom_post import CustomPost
from core.Constantes.QuotasTracking import QuotaTracker
from core.Analyzer.availability_matrix import AvailabilityMatrix
from workalendar.europe import France

logger = logging.getLogger(__name__)


class WeekdayGenerator:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], planning: Planning,
                 post_configuration):
        """
        Générateur pour les postes de semaine.
        Ne doit être utilisé qu'après validation des weekends.
        """
        self.doctors = doctors
        self.cats = cats
        self.planning = planning
        self.post_configuration = post_configuration
        self.constraints = PlanningConstraints()
        self.cal = France()

        # Chargement des postes personnalisés
        data_persistence = DataPersistence()
        self.custom_posts = data_persistence.load_custom_posts()
        
        # Vérification que tous les postes sont bien des objets CustomPost
        invalid_posts = []
        for name, post in list(self.custom_posts.items()):
            if not isinstance(post, CustomPost):
                try:
                    self.custom_posts[name] = CustomPost.from_dict(post if isinstance(post, dict) else post.__dict__)
                except Exception as e:
                    logger.error(f"Impossible de convertir le poste {name}: {e}")
                    invalid_posts.append(name)
        
        # Supprimer les postes invalides
        for name in invalid_posts:
            del self.custom_posts[name]
        
        logger.info(f"Postes personnalisés chargés: {list(self.custom_posts.keys())}")
        
        
        
  

    def reset_weekday_slots(self) -> None:
        """
        Réinitialise les slots de semaine avant une nouvelle génération.
        Préserve les NLv du vendredi et les weekends.
        """
        try:
            logger.info("\nRÉINITIALISATION DES SLOTS DE SEMAINE")
            logger.info("=" * 60)
            
            slots_cleared = 0
            
            for day in self.planning.days:
                # Ignorer les weekends et jours fériés/ponts
                if day.is_weekend or day.is_holiday_or_bridge:
                    continue
                    
                # Traitement spécial pour les vendredis (NLv)
                is_friday = day.date.weekday() == 4
                
                for slot in day.slots:
                    # Conserver les NLv du vendredi
                    if is_friday and slot.abbreviation == "NL":
                        continue
                        
                    # Réinitialiser les autres slots
                    if slot.assignee:
                        slots_cleared += 1
                        slot.assignee = None
            
            logger.info(f"Slots réinitialisés: {slots_cleared}")
            
        except Exception as e:
            logger.error(f"Erreur lors de la réinitialisation des slots: {e}")
            
    def reset_distribution_state(self) -> None:
        """
        Réinitialise les compteurs de distribution pour les médecins.
        Conserve les compteurs de weekends.
        """
        try:
            logger.info("Réinitialisation des compteurs de distribution")
            
            for doctor in self.doctors:
                # Réinitialiser uniquement les compteurs de semaine
                doctor_counts = {
                    "posts": self._get_doctor_weekday_counts(doctor, self.planning),
                    "group_counts": {
                        group: self._count_group_posts(doctor, group, self.planning)
                        for group in ["XM", "XA", "XS", "NMC"]  # Groupes de semaine uniquement
                    }
                }
                
            logger.info("Compteurs réinitialisés")
            
        except Exception as e:
            logger.error(f"Erreur lors de la réinitialisation des compteurs: {e}")

    def full_weekday_reset(self) -> None:
        """
        Effectue une réinitialisation complète de la partie semaine.
        À appeler avant chaque nouvelle génération.
        """
        self.reset_weekday_slots()
        self.reset_distribution_state()

    def distribute_weekday_nl(self) -> bool:
        """
        Distribution des NL de semaine (lundi à jeudi).
        Suit le même processus que les NL weekend.
        """
        try:
            logger.info("\nDISTRIBUTION DES NL SEMAINE")
            logger.info("=" * 80)

            # 1. Récupérer les quotas depuis la pré-analyse
            pre_analysis = self.planning.pre_analysis_results
            if not pre_analysis:
                logger.error("Pré-analyse manquante")
                return False

            # Calculer les quotas pour les CAT
            cat_count = len(self.cats)
            cat_nl_quota = pre_analysis["cat_posts"]["weekday"].get("NL", 0)
            cat_total = cat_nl_quota * cat_count

            # Calculer les quotas pour les médecins
            med_nl_quota = pre_analysis["adjusted_posts"]["weekday"]["NL"]

            # Log des quotas
            logger.info("\nQUOTAS NL SEMAINE:")
            logger.info(f"CAT: {cat_nl_quota}/CAT (total: {cat_total})")
            logger.info(f"Médecins total: {med_nl_quota}")

            # 2. Collecter les slots NL disponibles
            nl_slots = self._collect_weekday_nl_slots()
            total_slots = len(nl_slots)

            if total_slots < (cat_total + med_nl_quota):
                logger.error(f"Nombre de slots insuffisant: {total_slots} slots "
                           f"pour {cat_total + med_nl_quota} requis")
                return False

            # 3. Distribution aux CAT
            if not self._distribute_nl_to_cats(nl_slots, cat_total):
                logger.error("Échec distribution NL CAT semaine")
                return False

            # 4. Distribution aux médecins
            if not self._distribute_nl_to_doctors(nl_slots, med_nl_quota):
                logger.error("Échec distribution NL médecins semaine")
                return False

            # 5. Vérification finale
            unassigned = sum(1 for date, slot in nl_slots if not slot.assignee)
            if unassigned > 0:
                logger.warning(f"{unassigned} slots NL semaine non attribués")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NL semaine: {e}", exc_info=True)
            return False

    def _collect_weekday_nl_slots(self) -> List[Tuple[date, TimeSlot]]:
        """Collecte tous les slots NL de semaine disponibles."""
        nl_slots = []

        for day in self.planning.days:
            # Ne prendre que lundi à jeudi
            if (day.is_weekend or day.is_holiday_or_bridge or
                day.date.weekday() == 4):  # Exclure vendredi
                continue

            for slot in day.slots:
                if slot.abbreviation == "NL" and not slot.assignee:
                    nl_slots.append((day.date, slot))

        logger.info(f"\nSlots NL semaine disponibles: {len(nl_slots)}")
        return nl_slots

    def _distribute_nl_to_cats(self, nl_slots: List[Tuple[date, TimeSlot]], 
                             total_quota: int) -> bool:
        """Distribution des NL de semaine aux CAT."""
        try:
            logger.info("\nDISTRIBUTION NL SEMAINE AUX CAT")
            quota_per_cat = total_quota // len(self.cats)
            available_slots = nl_slots.copy()
            
            # Distribution par CAT
            for cat in self.cats:
                slots_assigned = 0
                
                while slots_assigned < quota_per_cat and available_slots:
                    random.shuffle(available_slots)
                    assigned = False
                    
                    for slot_index in range(len(available_slots)):
                        date, slot = available_slots[slot_index]
                        
                        if self.constraints.can_assign_to_assignee(cat, date, slot, 
                                                                 self.planning):
                            slot.assignee = cat.name
                            available_slots.pop(slot_index)
                            slots_assigned += 1
                            assigned = True
                            logger.info(f"CAT {cat.name}: NL attribué le {date} "
                                      f"({slots_assigned}/{quota_per_cat})")
                            break
                            
                    if not assigned:
                        logger.warning(f"Impossible d'attribuer plus de NL à {cat.name}")
                        break
                        
                if slots_assigned < quota_per_cat:
                    logger.warning(f"CAT {cat.name}: quota non atteint "
                                 f"({slots_assigned}/{quota_per_cat})")
                    
            return True
            
        except Exception as e:
            logger.error(f"Erreur distribution NL CAT: {e}")
            return False

    def _distribute_nl_to_doctors(self, nl_slots: List[Tuple[date, TimeSlot]], 
                                total_quota: int) -> bool:
        """Distribution des NL de semaine aux médecins."""
        try:
            logger.info("\nDISTRIBUTION NL SEMAINE AUX MÉDECINS")
            
            # Récupérer les intervalles depuis la distribution idéale ajustée
            pre_analysis = self.planning.pre_analysis_results
            if not pre_analysis or 'adjusted_posts' not in pre_analysis:
                logger.error("Pré-analyse ou distribution ajustée manquante")
                return False

            # Intervalles ajustés pour les NL de semaine
            adjusted_posts = pre_analysis['adjusted_posts']
            weekday_nl_intervals = adjusted_posts.get('weekday', {}).get('NL', {})
            
            # Initialiser les compteurs avec les intervalles ajustés
            doctor_counts = {}
            for doctor in self.doctors:
                if doctor.half_parts == 2:  # Plein temps
                    min_nl = 4  # Min 4 pour les pleins temps
                    max_nl = 5  # Max 5 pour les pleins temps
                else:  # Mi-temps
                    min_nl = 2  # Min 2 pour les mi-temps
                    max_nl = 3  # Max 3 pour les mi-temps
                
                doctor_counts[doctor.name] = {
                    "NL": 0,
                    "max": max_nl,
                    "min": min_nl
                }

            logger.info("\nIntervalles NL semaine par médecin:")
            for doctor in self.doctors:
                logger.info(f"{doctor.name} ({doctor.half_parts} demi-parts): "
                          f"[{doctor_counts[doctor.name]['min']}-"
                          f"{doctor_counts[doctor.name]['max']}]")

            def get_doctor_score(doctor_name, date):
                """Calcule un score pour un médecin à une date donnée."""
                doctor_count = doctor_counts[doctor_name]["NL"]
                max_count = doctor_counts[doctor_name]["max"]
                score = max_count - doctor_count  # Plus de chance si moins de NL

                # Vérifier les NL déjà attribués à ce médecin
                for day in self.planning.days:
                    if day.date == date:
                        continue
                    delta_days = abs((date - day.date).days)
                    for slot in day.slots:
                        if slot.assignee == doctor_name and slot.abbreviation == "NL":
                            # Pénaliser les dates proches d'un NL déjà attribué
                            if delta_days < 7:  # Une semaine
                                score -= (7 - delta_days) * 2
                
                # Ajouter un facteur aléatoire
                score += random.uniform(0, 2)
                return max(0, score)

            # Phase 1: Distribution du minimum requis avec équilibrage
            logger.info("\nPHASE 1: Distribution minimale")
            available_slots = [s for s in nl_slots if not s[1].assignee]
            random.shuffle(self.doctors)  # Ordre aléatoire initial des médecins
            
            while available_slots and any(doctor_counts[d.name]["NL"] < doctor_counts[d.name]["min"] 
                                        for d in self.doctors):
                # Pour chaque date disponible
                best_assignment = None
                best_score = -float('inf')
                
                # Essayer plusieurs slots aléatoires pour plus de variété
                sample_size = min(5, len(available_slots))
                sample_slots = random.sample(available_slots, sample_size)
                
                for date, slot in sample_slots:
                    # Évaluer chaque médecin pour ce slot
                    for doctor in self.doctors:
                        if doctor_counts[doctor.name]["NL"] >= doctor_counts[doctor.name]["min"]:
                            continue
                            
                        if self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning):
                            score = get_doctor_score(doctor.name, date)
                            if score > best_score:
                                best_score = score
                                best_assignment = (doctor, date, slot)
                
                if best_assignment:
                    doctor, date, slot = best_assignment
                    slot.assignee = doctor.name
                    doctor_counts[doctor.name]["NL"] += 1
                    available_slots.remove((date, slot))
                    logger.info(f"{doctor.name}: NL attribué le {date} "
                              f"({doctor_counts[doctor.name]['NL']}/{doctor_counts[doctor.name]['min']})")
                else:
                    # Si aucune attribution possible, passer au slot suivant
                    if available_slots:
                        available_slots.pop(0)

            # Phase 2: Distribution équilibrée du reste
            logger.info("\nPHASE 2: Distribution équilibrée")
            while available_slots:
                doctors_list = list(self.doctors)
                random.shuffle(doctors_list)
                assigned = False
                
                for doctor in doctors_list:
                    current = doctor_counts[doctor.name]["NL"]
                    max_allowed = doctor_counts[doctor.name]["max"]
                    
                    if current >= max_allowed:
                        continue
                    
                    for slot_index in range(len(available_slots)):
                        date, slot = available_slots[slot_index]
                        if self.constraints.can_assign_to_assignee(doctor, date, slot, 
                                                                 self.planning):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name]["NL"] += 1
                            available_slots.pop(slot_index)
                            assigned = True
                            logger.info(f"{doctor.name}: NL attribué le {date} "
                                      f"(total: {doctor_counts[doctor.name]['NL']})")
                            break
                            
                    if assigned:
                        break
                        
                if not assigned:
                    logger.warning("Plus aucune attribution possible")
                    break

            # Vérification finale
            for doctor_name, counts in doctor_counts.items():
                logger.info(f"\n{doctor_name}:")
                logger.info(f"NL attribués: {counts['NL']}")
                logger.info(f"Intervalle: [{counts['min']}-{counts['max']}]")
                
                if counts['NL'] < counts['min']:
                    logger.warning(f"Minimum non atteint pour {doctor_name}")
                    
            return True
            
        except Exception as e:
            logger.error(f"Erreur distribution NL médecins: {e}")
            return False
        
    def distribute_weekday_nanm(self) -> bool:
        """
        Distribution des NA, NM et NC de semaine avec une logique améliorée.
        """
        try:
            logger.info("\nDISTRIBUTION DES NA/NM/NC SEMAINE")
            logger.info("=" * 80)

            # 1. Récupération et validation des quotas
            quotas = self._get_nanm_quotas()
            if not quotas:
                return False

            # 2. Collecte et organisation des slots
            available_slots = self._collect_and_organize_nanm_slots()
            if not available_slots:
                logger.error("Aucun slot NANM disponible")
                return False

            # 3. Distribution aux CAT
            if not self._distribute_weekday_nanm_to_cats(available_slots, quotas['cats']):
                logger.warning("Distribution CAT incomplète - continuation")

            # 4. Distribution aux médecins en trois phases
            # Phase 1: Veille des NL
            self._distribute_nam_before_nl(available_slots)
            
            # Phase 2: Distribution minimale
            if not self._distribute_nanm_minimum_to_doctors(available_slots, quotas['doctors']):
                logger.warning("Distribution minimale médecins incomplète")

            # Phase 3: Distribution équilibrée
            if not self._distribute_remaining_nanm_to_doctors(available_slots):
                logger.warning("Distribution équilibrée incomplète")

            # 5. Vérification finale
            unassigned = self._count_unassigned_nanm(available_slots)
            if unassigned > 0:
                logger.warning(f"{unassigned} slots NANM non attribués")

            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution NANM: {e}", exc_info=True)
            return False

    def _get_nanm_quotas(self) -> Optional[Dict]:
        """Récupère et valide les quotas NANM."""
        try:
            pre_analysis = self.planning.pre_analysis_results
            if not pre_analysis:
                logger.error("Pré-analyse manquante")
                return None

            # Quotas CAT
            cat_count = len(self.cats)
            cat_quotas = {
                post_type: pre_analysis["cat_posts"]["weekday"].get(post_type, 0) * cat_count
                for post_type in ["NA", "NM", "NC"]
            }

            # Quotas médecins
            med_quotas = {
                post_type: pre_analysis["adjusted_posts"]["weekday"].get(post_type, 0)
                for post_type in ["NA", "NM", "NC"]
            }

            # Log des quotas
            logger.info("\nQUOTAS NANM:")
            for post_type in ["NA", "NM", "NC"]:
                logger.info(f"CAT {post_type}: {cat_quotas[post_type]}")
                logger.info(f"MED {post_type}: {med_quotas[post_type]}")

            return {'cats': cat_quotas, 'doctors': med_quotas}

        except Exception as e:
            logger.error(f"Erreur lors de la récupération des quotas: {e}")
            return None

    def _collect_and_organize_nanm_slots(self) -> Dict:
        """
        Collecte et organise les slots NANM par criticité.
        """
        slots = {
            post_type: {
                'critical': [],    # < 40% médecins disponibles
                'standard': [],    # >= 40% médecins disponibles
                'all': []          # Tous les slots
            }
            for post_type in ["NA", "NM", "NC"]
        }

        # Parcourir les jours du planning
        for day in self.planning.days:
            if day.is_weekend or day.is_holiday_or_bridge:
                continue

            # Calculer le pourcentage de médecins disponibles
            available_doctors = sum(
                1 for doctor in self.doctors
                if self._is_doctor_available_for_weekday(doctor, day.date)
            )
            availability = (available_doctors / len(self.doctors)) * 100

            for slot in day.slots:
                if slot.abbreviation in ["NA", "NM", "NC"] and not slot.assignee:
                    slots[slot.abbreviation]['all'].append((day.date, slot))
                    
                    if availability < 40:
                        slots[slot.abbreviation]['critical'].append((day.date, slot))
                    else:
                        slots[slot.abbreviation]['standard'].append((day.date, slot))

        # Log des slots disponibles
        for post_type in ["NA", "NM", "NC"]:
            logger.info(f"\nSlots {post_type}:")
            logger.info(f"Critique: {len(slots[post_type]['critical'])}")
            logger.info(f"Standard: {len(slots[post_type]['standard'])}")
            logger.info(f"Total: {len(slots[post_type]['all'])}")

        return slots
    
    
    def _distribute_weekday_nanm_to_cats(self, available_slots: Dict, quotas: Dict) -> bool:
        """
        Distribution améliorée des NA, NM et NC de semaine aux CAT.
        Priorise les périodes critiques.
        """
        try:
            logger.info("\nDISTRIBUTION NANM SEMAINE AUX CAT")
            logger.info("=" * 60)

            # Pour chaque type de poste
            for post_type in ["NA", "NM", "NC"]:
                quota_per_cat = quotas[post_type] // len(self.cats)
                if quota_per_cat == 0:
                    continue

                logger.info(f"\nDistribution {post_type}:")
                logger.info(f"Quota par CAT: {quota_per_cat}")

                # Phase 1: Distribution sur les périodes critiques
                self._distribute_critical_nanm_to_cats(
                    post_type,
                    available_slots[post_type]['critical'],
                    quota_per_cat
                )

                # Phase 2: Distribution sur les périodes standard
                self._distribute_standard_nanm_to_cats(
                    post_type,
                    available_slots[post_type]['standard'],
                    quota_per_cat
                )

            return True

        except Exception as e:
            logger.error(f"Erreur distribution NANM CAT: {e}")
            return False

    def _distribute_critical_nanm_to_cats(self, post_type: str, 
                                        critical_slots: List[Tuple[date, TimeSlot]],
                                        quota_per_cat: int) -> None:
        """Distribution des slots critiques aux CAT."""
        if not critical_slots:
            return

        logger.info(f"\nDistribution des slots critiques {post_type}")
        cats = list(self.cats)
        random.shuffle(cats)  # Ordre aléatoire des CAT

        for cat in cats:
            slots_assigned = 0
            slots_to_process = critical_slots.copy()
            random.shuffle(slots_to_process)

            while slots_assigned < quota_per_cat and slots_to_process:
                date, slot = slots_to_process.pop(0)
                
                if not slot.assignee and self.constraints.can_assign_to_assignee(
                    cat, date, slot, self.planning
                ):
                    slot.assignee = cat.name
                    slots_assigned += 1
                    critical_slots.remove((date, slot))
                    logger.info(f"CAT {cat.name}: {post_type} critique attribué le {date}")

    def _distribute_standard_nanm_to_cats(self, post_type: str,
                                        standard_slots: List[Tuple[date, TimeSlot]],
                                        quota_per_cat: int) -> None:
        """Distribution des slots standard aux CAT."""
        if not standard_slots:
            return

        logger.info(f"\nDistribution des slots standard {post_type}")
        cats = list(self.cats)
        random.shuffle(cats)

        for cat in cats:
            # Compter les slots déjà attribués
            current_count = sum(
                1 for day in self.planning.days
                for slot in day.slots
                if slot.assignee == cat.name and slot.abbreviation == post_type
            )

            # Continuer l'attribution si nécessaire
            remaining = quota_per_cat - current_count
            if remaining <= 0:
                continue

            slots_to_process = standard_slots.copy()
            random.shuffle(slots_to_process)

            for date, slot in slots_to_process:
                if remaining <= 0:
                    break

                if not slot.assignee and self.constraints.can_assign_to_assignee(
                    cat, date, slot, self.planning
                ):
                    slot.assignee = cat.name
                    standard_slots.remove((date, slot))
                    remaining -= 1
                    logger.info(f"CAT {cat.name}: {post_type} standard attribué le {date}")



    def _distribute_nam_before_nl(self, available_slots: Dict) -> None:
        """
        Distribution prioritaire des NA/NM/NC la veille des NL.
        Ne traite que les NL attribuées aux médecins, pas aux CAT.
        Respecte strictement les limites maximales de chaque type de poste.
        """
        logger.info("\nDISTRIBUTION NAM AVANT NL")
        logger.info("=" * 60)

        # Liste des noms des médecins pour vérification rapide
        doctor_names = {doctor.name for doctor in self.doctors}
        
        # Récupérer les intervalles et les compteurs actuels
        doctor_intervals = self._get_doctor_nanm_intervals()
        doctor_counts = self._initialize_doctor_nanm_counts()

        # Parcourir les jours du planning
        for day in self.planning.days:
            if day.is_weekend or day.is_holiday_or_bridge:
                continue

            # Chercher les NL du lendemain
            next_day = self.planning.get_day(day.date + timedelta(days=1))
            if not next_day:
                continue

            # Ne traiter que les NL attribuées aux médecins
            nl_slots = [
                slot for slot in next_day.slots 
                if slot.abbreviation == "NL" 
                and slot.assignee 
                and slot.assignee in doctor_names
            ]

            if not nl_slots:
                continue

            # Pour chaque NL trouvée
            for nl_slot in nl_slots:
                doctor_name = nl_slot.assignee
                doctor = next(d for d in self.doctors if d.name == doctor_name)

                # Chercher un slot NAM disponible la veille
                for post_type in ["NM", "NA", "NC"]:  # Ordre de priorité
                    # Vérifier si le médecin a atteint sa limite pour ce type de poste
                    current_count = doctor_counts[doctor.name][post_type]['count']
                    max_allowed = doctor_counts[doctor.name][post_type]['max']
                    
                    if current_count >= max_allowed:
                        logger.info(f"{doctor_name}: Maximum atteint pour {post_type} "
                                f"({current_count}/{max_allowed}) - essai type suivant")
                        continue

                    available = [
                        (date, slot) for date, slot 
                        in available_slots[post_type]['all']
                        if date == day.date and not slot.assignee
                    ]

                    if available:
                        assigned = False
                        for date, slot in available:
                            # Double vérification des contraintes et limites
                            if (self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning) and
                                self._verify_post_limits(doctor, post_type, doctor_counts[doctor.name][post_type])):
                                
                                slot.assignee = doctor_name
                                doctor_counts[doctor.name][post_type]['count'] += 1
                                available_slots[post_type]['all'].remove((date, slot))
                                
                                # Retirer aussi des listes critique/standard
                                for category in ['critical', 'standard']:
                                    if (date, slot) in available_slots[post_type][category]:
                                        available_slots[post_type][category].remove((date, slot))
                                
                                logger.info(f"{doctor_name}: {post_type} attribué le {date} "
                                        f"(veille de NL) - count: {doctor_counts[doctor.name][post_type]['count']}/"
                                        f"max: {max_allowed}")
                                assigned = True
                                break
                        
                        if assigned:
                            break  # Passer au prochain médecin
                            
                logger.debug(f"Traitement NL de {doctor_name} terminé")
        
        logger.info("Distribution NAM avant NL terminée")

    def _distribute_nanm_minimum_to_doctors(self, available_slots: Dict, quotas: Dict) -> bool:
        """
        Distribution du minimum requis de NA/NM/NC aux médecins.
        S'assure que chaque médecin atteint son minimum pour chaque type de poste.
        """
        try:
            logger.info("\nDISTRIBUTION MINIMUM NANM MÉDECINS")
            logger.info("=" * 60)

            # Initialisation des compteurs
            doctor_counts = self._initialize_doctor_nanm_counts()
            max_attempts = 3

            # Continuer tant qu'il y a des progrès possibles
            for attempt in range(max_attempts):
                logger.info(f"\nTentative {attempt + 1}/{max_attempts}")
                progress_made = False

                # Pour chaque médecin (ordre aléatoire)
                doctors = list(self.doctors)
                random.shuffle(doctors)

                for doctor in doctors:
                    # Vérifier les minimums pour chaque type
                    for post_type in ["NA", "NM", "NC"]:
                        if quotas[post_type] == 0:
                            continue

                        current = doctor_counts[doctor.name][post_type]['count']
                        min_required = doctor_counts[doctor.name][post_type]['min']

                        if current < min_required:
                            logger.info(f"\n{doctor.name}: {post_type} {current}/{min_required}")
                            
                            # Essayer d'attribuer jusqu'à atteindre le minimum
                            while current < min_required:
                                if self._try_assign_nam_to_doctor(
                                    doctor, post_type, available_slots[post_type],
                                    doctor_counts[doctor.name][post_type]
                                ):
                                    current += 1
                                    progress_made = True
                                    logger.info(f"{doctor.name}: {post_type} attribué "
                                            f"({current}/{min_required})")
                                else:
                                    break

            

                # Si aucun progrès, passer à la tentative suivante
                if not progress_made:
                    logger.info("Aucun progrès possible dans cette tentative")
                    continue

        except Exception as e:
            logger.error(f"Erreur distribution minimum NANM: {e}")
            return False

    def _distribute_remaining_nanm_to_doctors(self, available_slots: Dict) -> bool:
        """
        Distribution des slots NANM restants en priorisant les médecins
        n'ayant pas atteint leurs minimums et en respectant strictement les maximums.
        """
        try:
            logger.info("\nDISTRIBUTION FINALE NANM MÉDECINS")
            logger.info("=" * 60)

            doctor_intervals = self._get_doctor_nanm_intervals()
            doctor_counts = self._initialize_doctor_nanm_counts()

            for post_type in ["NA", "NM", "NC"]:
                remaining_slots = available_slots[post_type]['all']
                if not remaining_slots:
                    continue

                logger.info(f"\nDistribution finale {post_type}")
                max_passes = 3
                current_pass = 1

                while remaining_slots and current_pass <= max_passes:
                    logger.info(f"\nPasse {current_pass}/{max_passes}")
                    slots_to_process = remaining_slots.copy()
                    random.shuffle(slots_to_process)
                    assignment_made = False

                    for date, slot in slots_to_process:
                        if slot.assignee:
                            continue

                        # Vérification stricte des maximums pour tous les médecins
                        available_doctors = []
                        for doctor in self.doctors:
                            # Vérifier les limites maximales avant d'ajouter le médecin
                            current_count = doctor_counts[doctor.name][post_type]['count']
                            max_allowed = doctor_counts[doctor.name][post_type]['max']
                            
                            if (current_count >= max_allowed or 
                                not self._can_take_additional_nam(doctor, post_type, date, slot, doctor_intervals)):
                                continue

                            # Vérifier si sous le minimum
                            min_required = doctor_counts[doctor.name][post_type]['min']
                            if current_count < min_required:
                                # Priorité plus élevée aux médecins sous le minimum
                                available_doctors.insert(0, doctor)
                            else:
                                available_doctors.append(doctor)

                        if not available_doctors:
                            continue

                        # Sélection aléatoire parmi les médecins disponibles
                        doctor = available_doctors[0] if len(available_doctors) == 1 else random.choice(available_doctors[:2])
                        
                        # Double vérification des limites avant attribution finale
                        if self._verify_post_limits(doctor, post_type, doctor_counts[doctor.name][post_type]):
                            slot.assignee = doctor.name
                            doctor_counts[doctor.name][post_type]['count'] += 1
                            remaining_slots.remove((date, slot))
                            assignment_made = True

                            # Nettoyage des autres listes
                            for category in ['critical', 'standard']:
                                if (date, slot) in available_slots[post_type][category]:
                                    available_slots[post_type][category].remove((date, slot))

                            logger.info(f"{doctor.name}: {post_type} attribué le {date} "
                                    f"(count: {doctor_counts[doctor.name][post_type]['count']}/"
                                    f"max: {doctor_counts[doctor.name][post_type]['max']})")

                    if not assignment_made:
                        current_pass += 1

                if remaining_slots:
                    logger.warning(f"Slots {post_type} non attribués: {len(remaining_slots)}")

            return True

        except Exception as e:
            logger.error(f"Erreur distribution finale NANM: {e}")
            return False

    def _verify_post_limits(self, doctor: Doctor, post_type: str, 
                        doctor_intervals: Dict) -> bool:
        """Vérifie strictement les limites de poste et de groupe."""
        try:
            # 1. Vérifier le maximum du type de poste
            current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
            max_allowed = doctor_intervals['posts'].get(post_type, {}).get('max', float('inf'))
            if current >= max_allowed:
                return False

            # 2. Vérifier le maximum du groupe
            group = self._get_post_group(post_type, datetime.now().date())
            if group:
                current_group = doctor_intervals['current_counts']['groups'].get(group, 0)
                group_max = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                if current_group >= group_max:
                    return False

            return True

        except Exception as e:
            logger.error(f"Erreur vérification limites: {e}")
            return False

    def _count_unassigned_posts(self, remaining_posts: Dict) -> int:
        """Compte précis des postes non attribués."""
        total = 0
        for post_type, slots in remaining_posts.items():
            unassigned = sum(1 for _, slot in slots if not slot.assignee)
            if unassigned > 0:
                logger.debug(f"Postes {post_type} non attribués: {unassigned}")
            total += unassigned
        return total
        
    def _get_doctor_nanm_intervals(self) -> Dict:
        """
        Récupère les intervalles NAM pour chaque médecin depuis la pré-analyse.
        """
        intervals = {}
        pre_analysis = self.planning.pre_analysis_results
        
        for doctor in self.doctors:
            # Récupérer la distribution idéale du médecin
            doctor_dist = pre_analysis['ideal_distribution'].get(doctor.name, {})
            
            # Récupérer les intervalles de posts et groupes
            weekday_posts = doctor_dist.get('weekday_posts', {})
            weekday_groups = doctor_dist.get('weekday_groups', {})
            
            intervals[doctor.name] = {
                'posts': {
                    post_type: weekday_posts.get(post_type, {'min': 0, 'max': float('inf')})
                    for post_type in ["NA", "NM", "NC"]
                },
                'groups': {
                    'NMC': weekday_groups.get('NMC', {'min': 0, 'max': float('inf')})
                }
            }
            
            logger.debug(f"Intervalles pour {doctor.name}:")
            for post_type, interval in intervals[doctor.name]['posts'].items():
                logger.debug(f"{post_type}: [{interval['min']}-{interval['max']}]")
            logger.debug(f"NMC: [{intervals[doctor.name]['groups']['NMC']['min']}-"
                        f"{intervals[doctor.name]['groups']['NMC']['max']}]")
        
        return intervals

    def _count_unassigned_nanm(self, available_slots: Dict) -> int:
        """
        Compte le nombre total de slots NAM non attribués.
        """
        total_unassigned = 0
        
        # Pour chaque type de garde
        for post_type in ["NA", "NM", "NC"]:
            # Compter les slots non assignés dans tous les slots
            unassigned = sum(
                1 for date, slot in available_slots[post_type]['all']
                if not slot.assignee
            )
            
            if unassigned > 0:
                logger.info(f"Slots {post_type} non attribués: {unassigned}")
            total_unassigned += unassigned
        
        return total_unassigned

    def _initialize_doctor_nanm_counts(self) -> Dict:
        """
        Initialise les compteurs NANM pour chaque médecin.
        """
        doctor_counts = {}
        pre_analysis = self.planning.pre_analysis_results

        for doctor in self.doctors:
            intervals = pre_analysis['ideal_distribution'].get(doctor.name, {})
            weekday_posts = intervals.get('weekday_posts', {})
            
            doctor_counts[doctor.name] = {}
            for post_type in ["NA", "NM", "NC"]:
                doctor_counts[doctor.name][post_type] = {
                    'count': self._count_current_nam(doctor, post_type),
                    'min': weekday_posts.get(post_type, {}).get('min', 0),
                    'max': weekday_posts.get(post_type, {}).get('max', float('inf'))
                }

        return doctor_counts

    def _count_current_nam(self, doctor: Doctor, post_type: str) -> int:
        """
        Compte le nombre de postes NAM déjà attribués à un médecin.
        """
        count = 0
        for day in self.planning.days:
            if not day.is_weekend and not day.is_holiday_or_bridge:
                count += sum(
                    1 for slot in day.slots
                    if slot.assignee == doctor.name and slot.abbreviation == post_type
                )
        return count

    def _try_assign_nam_to_doctor(self, doctor: Doctor, post_type: str,
                            slot_lists: Dict[str, List], slot_stats: Dict) -> bool:
        """
        Tente d'attribuer un slot NAM à un médecin.
        Essaie d'abord les slots critiques, puis les standards.
        """
        # Essayer d'abord les slots critiques
        for category in ['critical', 'standard']:
            available = slot_lists[category]
            if not available:
                continue

            slots_to_try = available.copy()
            random.shuffle(slots_to_try)

            for date, slot in slots_to_try:
                if not slot.assignee and self.constraints.can_assign_to_assignee(
                    doctor, date, slot, self.planning
                ):
                    slot.assignee = doctor.name
                    slot_stats['count'] += 1
                    
                    # Retirer le slot des deux listes
                    slot_lists[category].remove((date, slot))
                    if (date, slot) in slot_lists['all']:
                        slot_lists['all'].remove((date, slot))
                    
                    logger.info(f"{doctor.name}: {post_type} attribué le {date} "
                            f"({category}, count: {slot_stats['count']})")
                    return True

        return False

    def _check_minimum_reached(self, doctor_counts: Dict) -> bool:
        """
        Vérifie si tous les médecins ont atteint leur minimum pour tous les types.
        """
        for doctor_name, counts in doctor_counts.items():
            for post_type, stats in counts.items():
                if stats['count'] < stats['min']:
                    return False
        return True

    def _can_take_additional_nam(self, doctor: Doctor, post_type: str,
                            date: date, slot: TimeSlot,
                            intervals: Dict) -> bool:
        """
        Vérifie si un médecin peut prendre un slot NAM supplémentaire.
        """
        # 1. Vérifier les contraintes de base
        if not self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning):
            return False

        # 2. Vérifier les limites de type de poste
        current = self._count_current_nam(doctor, post_type)
        max_allowed = (intervals.get(doctor.name, {})
                    .get('weekday_posts', {})
                    .get(post_type, {})
                    .get('max', float('inf')))
        
        if current >= max_allowed:
            return False

        # 3. Vérifier les limites de groupe (NMC)
        group = "NMC"  # Groupe pour NA, NM, NC
        current_group = sum(
            1 for day in self.planning.days
            if not day.is_weekend and not day.is_holiday_or_bridge
            for slot in day.slots
            if slot.assignee == doctor.name 
            and slot.abbreviation in ["NA", "NM", "NC"]
        )
        
        group_max = (intervals.get(doctor.name, {})
                    .get('weekday_groups', {})
                    .get(group, {})
                    .get('max', float('inf')))
        
        return current_group < group_max


    def _is_doctor_available_for_weekday(self, doctor: Doctor, date: date) -> bool:
        """
        Vérifie si un médecin est disponible pour une date donnée.
        Prend en compte les desiderata et les contraintes de repos.

        Args:
            doctor: Le médecin à vérifier
            date: La date à vérifier

        Returns:
            bool: True si le médecin est disponible, False sinon
        """
        try:
            # 1. Vérifier les desiderata
            for desiderata in doctor.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    return False

            # 2. Vérifier si le médecin a déjà des postes ce jour
            day = self.planning.get_day(date)
            if day and any(slot.assignee == doctor.name for slot in day.slots):
                return False

            # 3. Vérifier les contraintes de repos
            prev_day = self.planning.get_day(date - timedelta(days=1))
            if prev_day:
                # Pas de poste après une garde de nuit
                night_posts = ["NM", "NC", "NL"]
                if any(slot.assignee == doctor.name and slot.abbreviation in night_posts 
                    for slot in prev_day.slots):
                    return False

            # 4. Vérifier le nombre de jours consécutifs
            consecutive_days = 0
            check_date = date - timedelta(days=1)
            while consecutive_days < 6:  # Limite de 6 jours consécutifs
                day = self.planning.get_day(check_date)
                if not day or not any(slot.assignee == doctor.name for slot in day.slots):
                    break
                consecutive_days += 1
                check_date -= timedelta(days=1)

            if consecutive_days >= 6:
                return False

            return True

        except Exception as e:
            logger.error(f"Erreur lors de la vérification de disponibilité pour {doctor.name}: {e}")
            return False














    def distribute_weekday_combinations(self) -> bool:
        """
        Distribution des combinaisons de semaine avec conservation de la partie CAT
        et nouvelle implémentation pour les médecins.
        Retourne True pour indiquer que le processus s'est déroulé, même si incomplet.
        """
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS SEMAINE")
            logger.info("=" * 80)

            # Phase 1: Distribution aux CAT
            logger.info("\nPHASE 1: DISTRIBUTION AUX CAT")
            if not self._distribute_weekday_cat_combinations():
                logger.warning("Distribution CAT semaine incomplète - continuation")

            # Phase 2: Préparation de la distribution médecins
            logger.info("\nPHASE 2: PRÉPARATION DISTRIBUTION MÉDECINS")
            
            # Initialisation de la matrice de disponibilité
            availability_matrix = AvailabilityMatrix(
                self.planning.start_date,
                self.planning.end_date,
                self.doctors,
                self.cats
            )

            # Récupération des périodes critiques
            critical_periods = sorted(
                availability_matrix.critical_periods,
                key=lambda x: (x[2], -x[3])  # Par indisponibilité décroissante
            )

            # Organisation des dates en critique et normale
            weekdays = self._get_weekdays(self.planning)
            critical_dates = {period[0] for period in critical_periods}
            normal_dates = [d for d in weekdays if d not in critical_dates]
            random.shuffle(normal_dates)  # Mélange aléatoire

            # Récupération des intervalles depuis la pré-analyse
            intervals = self._get_doctor_weekday_intervals()
            if not intervals:
                logger.error("Impossible de récupérer les intervalles - poursuite avec la distribution restante")
                return True

            # Phase 3: Distribution aux médecins
            logger.info("\nPHASE 3: DISTRIBUTION AUX MÉDECINS")
            distribution_result = self._distribute_weekday_combinations_to_doctors(
                critical_dates,
                normal_dates,
                intervals,
                availability_matrix
            )

            if not distribution_result:
                logger.warning("Distribution des combinaisons semaine incomplète")
            else:
                logger.info("Distribution des combinaisons semaine terminée")

            # On continue le processus même si la distribution est incomplète
            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution semaine: {e}", exc_info=True)
            # On retourne True pour continuer le processus malgré l'erreur
            return True


    
    

    def _distribute_weekday_cat_combinations(self) -> bool:
        """
        Distribution des combinaisons de semaine aux CAT avec gestion stricte des quotas.
        Utilise le QuotaTracker pour garantir le respect des limites.
        """
        try:
            logger.info("\nDISTRIBUTION DES COMBINAISONS SEMAINE AUX CAT")
            logger.info("=" * 60)

            # Initialisation du tracker de quotas
            quota_tracker = QuotaTracker(self.planning, self.cats, "weekday")
            
            # Initialisation de la matrice de disponibilité
            availability_matrix = AvailabilityMatrix(
                self.planning.start_date,
                self.planning.end_date,
                self.doctors,
                self.cats
            )
            
            # Organisation des dates par criticité
            weekdays = self._get_weekdays(self.planning)
            dates_by_criticality = self._organize_dates_by_criticality(weekdays, availability_matrix)
            
            # Statistiques de distribution
            distribution_stats = {
                'critical': {'success': 0, 'failed': 0},
                'normal': {'success': 0, 'failed': 0}
            }

            # Distribution par niveau de criticité
            for criticality in ['critical', 'normal']:
                logger.info(f"\nTraitement des périodes {criticality}")
                for current_date in dates_by_criticality[criticality]:
                    self._process_cat_distribution_for_date(
                        current_date,
                        quota_tracker,
                        distribution_stats[criticality],
                        is_critical=(criticality == 'critical')
                    )

            # Log des résultats
            self._log_cat_distribution_results(distribution_stats, quota_tracker)
            return True

        except Exception as e:
            logger.error(f"Erreur distribution CAT semaine: {e}", exc_info=True)
            return False

    def _process_cat_distribution_for_date(self, date: date, quota_tracker: QuotaTracker,
                                        stats: Dict, is_critical: bool) -> None:
        """
        Traite la distribution pour une date donnée.
        Essaie d'attribuer des combinaisons à tous les CAT disponibles.
        """
        try:
            # Traitement des CAT dans un ordre aléatoire
            cats = list(self.cats)
            random.shuffle(cats)
            
            for cat in cats:
                if not self._is_cat_available_for_weekday(cat, date):
                    continue
                
                # Récupérer et filtrer les combinaisons possibles
                combinations = self._get_filtered_combinations(cat, date, quota_tracker)
                if not combinations:
                    continue
                    
                # Tenter l'attribution
                assigned = False
                for combo, weight in combinations:
                    if self._try_assign_cat_combination(cat, combo, date, quota_tracker):
                        assigned = True
                        stats['success'] += 1
                        break
                        
                if not assigned:
                    stats['failed'] += 1

        except Exception as e:
            logger.error(f"Erreur traitement {date}: {e}")

    def _get_filtered_combinations(self, cat: CAT, date: date, 
                            quota_tracker: QuotaTracker) -> List[Tuple[str, float]]:
        """
        Retourne les combinaisons possibles pour un CAT, filtrées et pondérées.
        """
        possible_combinations = []
        
        # Récupérer toutes les combinaisons de base
        all_combinations = self._get_cat_possible_weekday_combinations(cat)
        
        # Filtrer selon les quotas disponibles
        for combo, base_weight in all_combinations:
            if quota_tracker.can_assign_combination(cat, combo, date):
                # Calcul du poids final
                remaining = quota_tracker.get_remaining_quotas(cat)
                weight = self._calculate_combination_weight(combo, remaining, base_weight)
                possible_combinations.append((combo, weight))
        
        # Trier par poids décroissant
        possible_combinations.sort(key=lambda x: x[1], reverse=True)
        return possible_combinations

    def _try_assign_cat_combination(self, cat: CAT, combo: str, date: date,
                                quota_tracker: QuotaTracker) -> bool:
        """
        Tente d'attribuer une combinaison à un CAT en respectant toutes les contraintes.
        """
        try:
            day = self.planning.get_day(date)
            if not day:
                return False

            # Extraire les postes de la combinaison
            first_post, second_post = self._get_posts_from_weekday_combo(combo)
            
            # Vérification finale des quotas
            if not quota_tracker.can_assign_combination(cat, combo, date):
                return False
            
            # Trouver les slots disponibles
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)
            
            if not (first_slot and second_slot):
                return False

            # Vérifier les contraintes
            if not (self.constraints.can_assign_to_assignee(cat, date, first_slot, self.planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, self.planning)):
                return False

            # Attribuer les slots
            first_slot.assignee = cat.name
            second_slot.assignee = cat.name
            
            # Mettre à jour les compteurs
            quota_tracker.update_assignment(cat, first_post, date, combo)
            quota_tracker.update_assignment(cat, second_post, date)
            
            logger.info(f"Attribution {combo} à {cat.name} le {date}")
            logger.debug(f"Quotas restants: {quota_tracker.get_remaining_quotas(cat)}")
            
            return True

        except Exception as e:
            logger.error(f"Erreur attribution {combo} à {cat.name}: {e}")
            return False

    def _calculate_combination_weight(self, combo: str, remaining_quotas: Dict,
                                base_weight: float = 1.0) -> float:
        """
        Calcule le poids d'une combinaison en fonction des quotas restants.
        """
        first_post, second_post = self._get_posts_from_weekday_combo(combo)
        
        # Récupérer les quotas restants pour chaque poste
        first_remaining = remaining_quotas['posts'].get(first_post, 0)
        second_remaining = remaining_quotas['posts'].get(second_post, 0)
        
        # Le poids diminue si on s'approche des limites
        weight = base_weight
        if first_remaining + second_remaining > 0:
            weight *= (first_remaining + second_remaining) / 2
            
        # Facteur aléatoire pour éviter la monotonie
        weight *= 1 + (random.random() * 0.2 - 0.1)  # ±10%
        
        return max(0.1, weight)

    def _log_cat_distribution_results(self, stats: Dict, quota_tracker: QuotaTracker):
        """
        Affiche les résultats détaillés de la distribution.
        """
        logger.info("\nRÉSULTATS DE LA DISTRIBUTION CAT SEMAINE")
        logger.info("=" * 60)
        
        # Statistiques par type de période
        for period_type, period_stats in stats.items():
            logger.info(f"\nPériodes {period_type}:")
            total = period_stats['success'] + period_stats['failed']
            if total > 0:
                success_rate = (period_stats['success'] / total) * 100
                logger.info(f"Succès: {period_stats['success']}")
                logger.info(f"Échecs: {period_stats['failed']}")
                logger.info(f"Taux de réussite: {success_rate:.1f}%")
        
        # État des quotas de manière concise
        logger.info("\nVÉRIFICATION DES QUOTAS:")
        for cat in self.cats:
            remaining = quota_tracker.get_remaining_quotas(cat)
            critical_quotas = {
                post: quota for post, quota in remaining['posts'].items()
                if quota > 0
            }
            if critical_quotas:
                logger.info(f"\n{cat.name} - Quotas restants:")
                for post, quota in critical_quotas.items():
                    logger.info(f"  {post}: {quota}")
            else:
                logger.info(f"\n{cat.name}: Tous les quotas respectés")
    

    def _distribute_critical_periods_to_cats(
        self, critical_periods: List[Tuple], 
        cat_quotas: Dict[str, int],
        cat_stats: Dict[str, Dict]) -> Dict[str, int]:
        """Distribution prioritaire pour les périodes critiques."""
        
        remaining_quotas = cat_quotas.copy()
        cats_list = list(self.cats)

        for date, period, unavailability, _ in critical_periods:
            logger.info(f"\nTraitement période critique: {date} "
                    f"(indisponibilité: {unavailability:.1f}%)")
            
            # Mélanger les CAT pour distribution aléatoire
            random.shuffle(cats_list)
            
            # Filtrer les CAT disponibles
            available_cats = [
                cat for cat in cats_list
                if self._is_cat_available_for_weekday(cat, date)
            ]
            
            if not available_cats:
                logger.info("Aucun CAT disponible pour cette période")
                continue

            # Essayer d'attribuer une combinaison prioritaire
            for cat in available_cats:
                # Filtrer et mélanger les combinaisons disponibles
                available_combos = [
                    combo for combo, quota in remaining_quotas.items()
                    if quota > 0 and combo in WEEKDAY_PRIORITY_GROUPS['high_priority']
                ]
                random.shuffle(available_combos)
                
                for combo in available_combos:
                    if remaining_quotas[combo] > 0:
                        if self._assign_weekday_combo_to_cat(cat, combo, date, cat_stats[cat.name]):
                            remaining_quotas[combo] -= 1
                            logger.info(f"{cat.name}: {combo} attribué le {date} "
                                    f"(période critique)")
                            break

        return remaining_quotas
    def _get_remaining_weekday_slots(self) -> List[Tuple[date, str]]:
        """
        Retourne la liste des slots de semaine non attribués
        """
        remaining = []
        
        for day in self.planning.days:
            # Ignorer les weekends et jours fériés
            if day.is_weekend or day.is_holiday_or_bridge:
                continue
                
            for slot in day.slots:
                if not slot.assignee:
                    remaining.append((day.date, slot.abbreviation))
                    
        return remaining
    def _distribute_remaining_periods_to_cats(
        self, normal_dates: List[date],
        remaining_quotas: Dict[str, int],
        cat_stats: Dict[str, Dict]) -> bool:
        """Distribution des combinaisons restantes sur les périodes normales."""
        
        # Mélanger les dates pour distribution aléatoire
        dates_to_process = normal_dates.copy()
        random.shuffle(dates_to_process)
        
        # Traiter chaque combinaison restante
        for combo, quota in list(remaining_quotas.items()):
            while quota > 0:
                assigned = False
                
                # Mélanger les CAT pour chaque tentative
                cats_list = list(self.cats)
                random.shuffle(cats_list)
                
                for date in dates_to_process:
                    # Essayer chaque CAT disponible
                    for cat in cats_list:
                        if not self._is_cat_available_for_weekday(cat, date):
                            continue
                            
                        if self._assign_weekday_combo_to_cat(cat, combo, date, cat_stats[cat.name]):
                            quota -= 1
                            remaining_quotas[combo] = quota
                            logger.info(f"{cat.name}: {combo} attribué le {date}")
                            assigned = True
                            break
                            
                    if assigned:
                        break
                        
                if not assigned:
                    logger.warning(f"Impossible d'attribuer {combo} (quota restant: {quota})")
                    break  # Éviter une boucle infinie
                    
        return True

    def _verify_cat_distribution(self, cat_stats: Dict, quotas: Dict[str, int]) -> bool:
        """Vérifie la distribution finale des CAT."""
        all_ok = True
        
        logger.info("\nVÉRIFICATION DE LA DISTRIBUTION CAT")
        logger.info("=" * 60)
        
        for cat_name, stats in cat_stats.items():
            logger.info(f"\n{cat_name}:")
            
            # Vérifier les quotas de postes
            for post, count in stats['posts'].items():
                quota = quotas.get(post, 0)
                status = "OK" if count <= quota else "DÉPASSEMENT"
                logger.info(f"{post}: {count}/{quota} ({status})")
                if count > quota:
                    all_ok = False
                    
            # Afficher les combinaisons utilisées
            logger.info("\nCombinaisons attribuées:")
            for combo, count in stats['combinations'].items():
                logger.info(f"{combo}: {count}")
                
        return all_ok
    
    def _verify_cat_post_quotas(self, cat: CAT, first_post: str, second_post: str) -> bool:
        """
        Vérifie strictement que le CAT n'a pas dépassé ses quotas pour les postes individuels.
        
        Args:
            cat: Le CAT à vérifier
            first_post: Premier poste de la combinaison
            second_post: Deuxième poste de la combinaison
            
        Returns:
            bool: True si l'attribution est possible, False sinon
        """
        try:
            # Récupérer les quotas depuis la pré-analyse
            quotas = self.planning.pre_analysis_results["cat_posts"]["weekday"]
            
            # Compter les postes déjà attribués (hors weekend/férié)
            current_counts = defaultdict(int)
            for day in self.planning.days:
                if not (day.is_weekend or day.is_holiday_or_bridge):
                    for slot in day.slots:
                        if slot.assignee == cat.name:
                            current_counts[slot.abbreviation] += 1
            
            # Vérifier les limites pour chaque poste
            for post_type in [first_post, second_post]:
                quota = quotas.get(post_type, 0)
                current = current_counts[post_type]
                
                if current >= quota:
                    logger.warning(f"{cat.name}: Quota atteint pour {post_type} "
                                f"({current}/{quota})")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur vérification quotas {cat.name}: {e}")
            return False

    def _calculate_cat_combination_quotas(self, quotas: Dict[str, int]) -> Dict[str, int]:
        """
        Calcule les quotas de combinaisons pour les CAT en respectant strictement 
        les quotas individuels des postes et les priorités définies.
        
        Args:
            quotas (Dict[str, int]): Quotas par type de poste
            
        Returns:
            Dict[str, int]: Quotas par combinaison respectant les limites individuelles
        """
        combination_quotas = {}
        used_posts = {post: 0 for post in quotas.keys()}
        
        # Log des quotas initiaux
        logger.info("\nQuotas initiaux par poste:")
        for post, quota in quotas.items():
            logger.info(f"{post}: {quota}")
        
        # Traiter les combinaisons par niveau de priorité
        priority_groups = [
            ('high_priority', WEEKDAY_PRIORITY_GROUPS['high_priority']),
            ('medium_priority', WEEKDAY_PRIORITY_GROUPS['medium_priority']),
            ('low_priority', WEEKDAY_PRIORITY_GROUPS['low_priority'])
        ]
        
        for priority_level, combinations in priority_groups:
            logger.info(f"\nTraitement des combinaisons {priority_level}")
            priority_weight = PRIORITY_WEIGHTS[priority_level]
            
            for combo in combinations:
                first_post, second_post = self._get_posts_from_weekday_combo(combo)
                
                # Vérifier si les deux postes ont des quotas définis
                if (first_post not in quotas) or (second_post not in quotas):
                    continue
                    
                # Calculer les quotas restants pour chaque poste
                remaining_first = quotas[first_post] - used_posts[first_post]
                remaining_second = quotas[second_post] - used_posts[second_post]
                
                if remaining_first <= 0 or remaining_second <= 0:
                    continue
                
                # Calculer le quota de base pour cette combinaison
                base_quota = min(remaining_first, remaining_second)
                
                # Appliquer le poids de priorité et les limites
                if priority_level == 'high_priority':
                    # Haute priorité : jusqu'à 60% des quotas restants
                    quota = int(base_quota * 0.6 * priority_weight)
                elif priority_level == 'medium_priority':
                    # Priorité moyenne : jusqu'à 40% des quotas restants
                    quota = int(base_quota * 0.4 * priority_weight)
                else:  # low_priority
                    # Basse priorité : jusqu'à 20% des quotas restants
                    quota = int(base_quota * 0.2 * priority_weight)
                
                # Assurer un minimum de 1 si possible tout en respectant les limites
                quota = min(max(1, quota), base_quota) if base_quota > 0 else 0
                
                if quota > 0:
                    # Vérifier une dernière fois que nous ne dépassons pas les quotas
                    if (used_posts[first_post] + quota <= quotas[first_post] and 
                        used_posts[second_post] + quota <= quotas[second_post]):
                        
                        combination_quotas[combo] = quota
                        used_posts[first_post] += quota
                        used_posts[second_post] += quota
                        
                        logger.info(f"Attribution {combo}: {quota}")
                        logger.info(f"  - {first_post}: {used_posts[first_post]}/{quotas[first_post]}")
                        logger.info(f"  - {second_post}: {used_posts[second_post]}/{quotas[second_post]}")
        
        # Vérification finale des quotas
        quota_violations = False
        logger.info("\nVérification finale des quotas:")
        for post, used in used_posts.items():
            if used > quotas[post]:
                logger.error(f"Dépassement pour {post}: {used}/{quotas[post]}")
                quota_violations = True
            else:
                logger.info(f"{post}: {used}/{quotas[post]} (OK)")
                
        if quota_violations:
            logger.error("Violations de quotas détectées - annulation de la distribution")
            return {}
        
        # Résumé des attributions
        logger.info("\nRésumé des combinaisons attribuées:")
        high_priority_count = sum(1 for combo in WEEKDAY_PRIORITY_GROUPS['high_priority'] 
                                if combo in combination_quotas)
        med_priority_count = sum(1 for combo in WEEKDAY_PRIORITY_GROUPS['medium_priority'] 
                            if combo in combination_quotas)
        low_priority_count = sum(1 for combo in WEEKDAY_PRIORITY_GROUPS['low_priority'] 
                            if combo in combination_quotas)
        
        logger.info(f"Combinaisons haute priorité: {high_priority_count}")
        logger.info(f"Combinaisons priorité moyenne: {med_priority_count}")
        logger.info(f"Combinaisons basse priorité: {low_priority_count}")
        
        return combination_quotas

    def _get_posts_from_weekday_combo(self, combo: str) -> Tuple[str, str]:
        """
        Extrait les deux postes d'une combinaison de semaine.
        Gère les postes personnalisés et standards.
        
        Args:
            combo (str): Code de la combinaison (ex: "MLCA")
            
        Returns:
            Tuple[str, str]: Tuple des deux codes de poste
        """
        # 1. Vérifier les combinaisons de postes personnalisés
        for custom_post in self.custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post
        
        # 2. Combinaison standard (ex: "MLCA" -> ("ML", "CA"))
        return combo[:2], combo[2:]

    

    

    def _get_weekdays(self, planning: Planning) -> List[date]:
        """Récupère les jours de semaine (hors weekend et fériés)."""
        weekdays = []
        current_date = planning.start_date
        
        while current_date <= planning.end_date:
            if (current_date.weekday() < 5 and 
                not self.cal.is_holiday(current_date) and 
                not DayType.is_bridge_day(current_date, self.cal)):  # Utilisation de DayType
                weekdays.append(current_date)
            current_date += timedelta(days=1)
        
        return weekdays


    def _calculate_weekday_availability(self, weekdays: List[date]) -> Dict[date, float]:
        """Calcule le pourcentage de médecins disponibles pour chaque jour."""
        availability = {}
        for current_date in weekdays:
            # Compter les médecins disponibles
            available_doctors = sum(
                1 for doctor in self.doctors
                if not any(
                    desiderata.start_date <= current_date <= desiderata.end_date 
                    for desiderata in doctor.desiderata
                )
            )
            availability[current_date] = (available_doctors / len(self.doctors)) * 100
            
        return availability

    def _try_assign_weekday_combination_to_cat(self, cat: CAT, date: date,
                                            combinations: List[Tuple[str, int]],
                                            used_posts: Dict[str, int],
                                            combo_assignments: Dict[str, int],
                                            availability: float = 100.0) -> bool:
        """Tente d'attribuer une combinaison de semaine à un CAT avec vérification stricte des quotas."""
        quotas = self.planning.pre_analysis_results["cat_posts"]["weekday"]
        
        # 1. Filtrer les combinaisons disponibles en vérifiant les quotas de postes individuels
        available_combinations = []
        for combo, max_count in combinations:
            first_post, second_post = self._get_posts_from_weekday_combo(combo)
            
            # Vérifier les quotas restants pour chaque poste
            first_remaining = quotas.get(first_post, 0) - self._count_cat_post_usage(cat, first_post)
            second_remaining = quotas.get(second_post, 0) - self._count_cat_post_usage(cat, second_post)
            
            if (first_remaining > 0 and second_remaining > 0 and
                combo_assignments[combo] < max_count and
                self._can_assign_weekday_combo_to_cat(cat, combo, date)):
                available_combinations.append((combo, max_count))
        
        if available_combinations:
            # 2. Calculer les poids avec facteurs de priorité et disponibilité
            weighted_combinations = []
            for combo, max_count in available_combinations:
                base_weight = max_count + 1 - combo_assignments[combo]
                availability_factor = 2.0 - (availability / 100)
                random_factor = 1 + (random.random() * 0.4 - 0.2)
                final_weight = int(base_weight * availability_factor * random_factor)
                
                if final_weight > 0:
                    weighted_combinations.extend([combo] * final_weight)
            
            # 3. Sélectionner et attribuer une combinaison
            if weighted_combinations:
                selected_combo = random.choice(weighted_combinations)
                return self._assign_weekday_combo_to_cat(cat, selected_combo, date, used_posts, combo_assignments)
                    
        return False

    def _count_cat_post_usage(self, cat: CAT, post_type: str) -> int:
        """
        Compte l'utilisation actuelle d'un type de poste par un CAT dans le planning de semaine.
        
        Args:
            cat: Le CAT dont on veut compter les postes
            post_type: Le type de poste à compter
            
        Returns:
            int: Nombre d'utilisations du poste par le CAT
        """
        count = 0
        for day in self.planning.days:
            # Ne compter que les jours de semaine
            if not (day.is_weekend or day.is_holiday_or_bridge):
                for slot in day.slots:
                    if slot.assignee == cat.name and slot.abbreviation == post_type:
                        count += 1
        return count

    def _assign_weekday_combo_to_cat(self, cat: CAT, combo: str, date: date, stats: Dict) -> bool:
        """Attribution d'une combinaison à un CAT avec vérification stricte des quotas."""
        try:
            day = self.planning.get_day(date)
            if not day:
                return False

            # 1. Extraire les postes de la combinaison
            first_post, second_post = self._get_posts_from_weekday_combo(combo)
            
            # 2. Vérifier les quotas individuels
            if not self._verify_cat_post_quotas(cat, first_post, second_post):
                return False
            
            # 3. Trouver les slots disponibles
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)
            
            if not (first_slot and second_slot):
                return False

            # 4. Vérifier les contraintes
            if not (self.constraints.can_assign_to_assignee(cat, date, first_slot, self.planning) and
                    self.constraints.can_assign_to_assignee(cat, date, second_slot, self.planning)):
                return False

            # 5. Effectuer l'attribution
            first_slot.assignee = cat.name
            second_slot.assignee = cat.name

            # 6. Mettre à jour les statistiques
            stats['combinations'][combo] = stats['combinations'].get(combo, 0) + 1
            stats['posts'][first_post] = stats['posts'].get(first_post, 0) + 1
            stats['posts'][second_post] = stats['posts'].get(second_post, 0) + 1

            logger.info(f"Attribution {combo} à {cat.name} le {date}")
            return True

        except Exception as e:
            logger.error(f"Erreur lors de l'attribution de {combo} à {cat.name}: {e}")
            return False
    

    def _get_posts_from_weekday_combo(self, combo: str) -> Tuple[str, str]:
        """Extrait les deux postes d'une combinaison de semaine."""
        # Vérifier si c'est une combinaison personnalisée
        for custom_post in self.custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post
        
        # Combinaison standard
        return combo[:2], combo[2:]

    def _can_assign_weekday_combo_to_cat(self, cat: CAT, combo: str, date: date) -> bool:
        """Vérifie si une combinaison de semaine peut être attribuée à un CAT."""
        # 1. Vérifier l'existence du jour
        day = self.planning.get_day(date)
        if not day:
            return False
        
        # 2. Extraire les postes
        first_post, second_post = self._get_posts_from_weekday_combo(combo)
        
        # 3. Vérifier la disponibilité des slots
        first_slot = next((s for s in day.slots 
                        if s.abbreviation == first_post and not s.assignee), None)
        second_slot = next((s for s in day.slots 
                        if s.abbreviation == second_post and not s.assignee), None)
                        
        if not (first_slot and second_slot):
            return False
        
        # 4. Vérifier les contraintes
        return (self.constraints.can_assign_to_assignee(cat, date, first_slot, self.planning) and
                self.constraints.can_assign_to_assignee(cat, date, second_slot, self.planning))
        
    def _get_cat_possible_weekday_combinations(self, cat: CAT) -> List[Tuple[str, int]]:
        """
        Détermine les combinaisons possibles pour un CAT en semaine.
        
        Args:
            cat (CAT): Le CAT pour lequel on cherche les combinaisons
            
        Returns:
            List[Tuple[str, int]]: Liste des tuples (combinaison, nombre_max)
        """
        combinations = []
        quotas = self.planning.pre_analysis_results["cat_posts"]["weekday"]
        
        # Debug des quotas
        logger.debug(f"Quotas semaine disponibles pour {cat.name}:")
        for post_type, quota in quotas.items():
            if quota > 0:
                logger.debug(f"  {post_type}: {quota}")
        
        # 1. Ajout des combinaisons standards de semaine
        for combo in WEEKDAY_COMBINATIONS:
            first_post, second_post = combo[:2], combo[2:]
            
            if quotas.get(first_post, 0) > 0 and quotas.get(second_post, 0) > 0:
                max_count = min(quotas[first_post], quotas[second_post])
                if max_count > 0:
                    combinations.append((combo, max_count))
                    logger.debug(f"  Ajout combinaison standard: {combo} (max={max_count})")
                        
        # 2. Ajout des combinaisons des postes personnalisés
        for post_name, custom_post in self.custom_posts.items():
            # Vérifier si le poste peut être attribué aux CAT
            if (custom_post.assignment_type in ['cats', 'both'] and
                'weekday' in custom_post.day_types):
                
                quota_custom = quotas.get(post_name, 0)
                if quota_custom > 0:
                    # Pour chaque combinaison possible du poste personnalisé
                    for other_post, combo_name in custom_post.possible_combinations.items():
                        quota_other = quotas.get(other_post, 0)
                        if quota_other > 0:
                            max_count = min(quota_custom, quota_other)
                            combinations.append((combo_name, max_count))
                            logger.debug(f"  Ajout combinaison personnalisée: {combo_name} "
                                    f"({post_name}+{other_post}, max={max_count})")
                                
        # Log final des combinaisons disponibles
        if combinations:
            logger.info(f"Combinaisons semaine disponibles pour {cat.name}:")
            for combo, max_count in combinations:
                logger.info(f"  - {combo} (max: {max_count})")
        else:
            logger.warning(f"Aucune combinaison semaine disponible pour {cat.name}")
        
        return combinations
    
    def _is_cat_available_for_weekday(self, cat: CAT, date: date) -> bool:
        """
        Vérifie si un CAT est disponible pour un jour de semaine donné.
        
        Args:
            cat (CAT): Le CAT à vérifier
            date (date): La date du jour à vérifier
            
        Returns:
            bool: True si le CAT est disponible, False sinon
        """
        try:
            # 1. Vérifier les desiderata
            for desiderata in cat.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    logger.debug(f"{cat.name} indisponible le {date} (desiderata)")
                    return False
                    
            # 2. Vérifier si le CAT a déjà des postes ce jour
            day = self.planning.get_day(date)
            if day:
                for slot in day.slots:
                    if slot.assignee == cat.name:
                        logger.debug(f"{cat.name} déjà assigné le {date} ({slot.abbreviation})")
                        return False
            else:
                logger.debug(f"Jour {date} non trouvé dans le planning")
                return False  # Jour non trouvé dans le planning
                
            # CAT disponible
            logger.debug(f"{cat.name} disponible le {date}")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la vérification de disponibilité de {cat.name}: {e}")
            return False

    def _log_weekday_cat_distribution(self, cat: CAT, stats: Dict):
        """Log détaillé des résultats de distribution pour un CAT."""
        logger.info(f"\nRésultats de distribution semaine pour {cat.name}:")

        # Log des combinaisons utilisées
        if stats['combinations']:
            logger.info("\nCombinaisons attribuées:")
            for combo, count in sorted(stats['combinations'].items()):
                logger.info(f"{combo}: {count}")

        # Log des postes individuels
        if stats['posts']:
            logger.info("\nPostes utilisés:")
            for post, count in sorted(stats['posts'].items()):
                logger.info(f"{post}: {count}")
            
            
    
    
    
    
    
    


    def _get_doctor_weekday_intervals(self) -> Dict:
        """
        Récupère les intervalles de postes et groupes des médecins depuis la pré-analyse.
        """
        try:
            pre_analysis = self.planning.pre_analysis_results
            if not pre_analysis or 'ideal_distribution' not in pre_analysis:
                logger.error("Pré-analyse ou distribution idéale manquante")
                return None

            intervals = {}
            for doctor in self.doctors:
                doctor_dist = pre_analysis['ideal_distribution'].get(doctor.name, {})
                
                intervals[doctor.name] = {
                    'posts': doctor_dist.get('weekday_posts', {}),
                    'groups': doctor_dist.get('weekday_groups', {}),
                    'current_counts': {
                        'posts': defaultdict(int),
                        'groups': defaultdict(int)
                    }
                }

            return intervals

        except Exception as e:
            logger.error(f"Erreur récupération intervalles: {e}")
            return None

    def _distribute_weekday_combinations_to_doctors(
        self, critical_dates: Set[date], normal_dates: List[date],
        intervals: Dict, availability_matrix: AvailabilityMatrix) -> bool:
        """
        Distribution principale des combinaisons aux médecins.
        """
        try:
            # Phase 1: Distribution sur périodes critiques
            logger.info("\nDistribution périodes critiques")
            for date in sorted(critical_dates):
                availability = availability_matrix.get_period_availability
                self._distribute_day_combinations(date, intervals, availability, True)

            # Phase 2: Distribution sur périodes normales
            logger.info("\nDistribution périodes normales")
            for date in normal_dates:
                availability = availability_matrix.get_period_availability
                self._distribute_day_combinations(date, intervals, availability, False)

            # Vérification finale
            return self._verify_doctor_distribution(intervals)

        except Exception as e:
            logger.error(f"Erreur distribution médecins: {e}")
            return False
        
        

    def _distribute_day_combinations(self, date: date, intervals: Dict,
                                    availability: float, is_critical: bool) -> None:
        """
        Distribution des combinaisons avec priorité aux médecins ayant une seule indisponibilité.
        """
        try:
            logger.info(f"\nDistribution pour le {date}")

            # 1. Récupérer toutes les combinaisons par priorité
            all_combinations = []
            for priority_level, combinations in WEEKDAY_PRIORITY_GROUPS.items():
                available = self._get_available_combinations_for_priority(
                    date, combinations, priority_level
                )
                if available:
                    all_combinations.extend(available)

            if not all_combinations:
                return

            # 2. Identifier les médecins avec une seule indisponibilité
            single_indispo_doctors = self._get_single_indispo_doctors(date)
            doctors_with_single_indispo = {doc.name: period for doc, period in single_indispo_doctors}

            # 3. Identifier les médecins sous minimum
            doctors_under_min = self._get_doctors_under_minimum(intervals)
            
            # 4. Distribution prioritaire
            remaining_combos = all_combinations.copy()
            
            # Première phase : médecins à la fois sous minimum ET avec une seule indisponibilité
            priority_doctors = []
            for doc, doc_intervals, gap in doctors_under_min:
                if doc.name in doctors_with_single_indispo:
                    priority_doctors.append((
                        doc,
                        doc_intervals,
                        gap,
                        doctors_with_single_indispo[doc.name]
                    ))

            # Phase 1: Traiter les médecins prioritaires
            if priority_doctors:
                logger.info("\nPhase 1: Médecins sous minimum avec une indisponibilité")
                # Trier par gap décroissant pour traiter d'abord les plus en retard
                priority_doctors.sort(key=lambda x: x[2], reverse=True)
                
                for doctor, doctor_intervals, gap, indispo_period in priority_doctors:
                    # Filtrer les combinaisons compatibles avec l'indisponibilité
                    compatible_combos = self._filter_compatible_combinations(
                        doctor, date, remaining_combos, indispo_period
                    )
                    
                    if compatible_combos:
                        for priority_level in ['high_priority', 'medium_priority', 'low_priority']:
                            priority_combos = [
                                c for c in compatible_combos if c['priority'] == priority_level
                            ]
                            
                            if priority_combos:
                                best_combo = self._find_best_combination(
                                    doctor, date, priority_combos, doctor_intervals
                                )
                                
                                if best_combo and self._assign_combination(
                                    doctor, date, best_combo, doctor_intervals
                                ):
                                    remaining_combos.remove(best_combo)
                                    logger.info(f"Attribution prioritaire à {doctor.name}: "
                                            f"{best_combo['combo']} (sous minimum + indispo période {indispo_period})")
                                    break

            # Phase 2: Autres médecins sous minimum
            remaining_under_min = [
                (doc, doc_intervals, gap) for doc, doc_intervals, gap in doctors_under_min
                if doc.name not in doctors_with_single_indispo
            ]
            
            if remaining_under_min:
                logger.info("\nPhase 2: Autres médecins sous minimum")
                remaining_combos = self._distribute_to_doctors_under_minimum(
                    date, remaining_combos, remaining_under_min, intervals
                )

            # Phase 3: Autres médecins avec une seule indisponibilité
            remaining_single_indispo = [
                (doc, period) for doc, period in single_indispo_doctors
                if doc.name not in {d.name for d, _, _ in doctors_under_min}
            ]
            
            if remaining_single_indispo:
                logger.info("\nPhase 3: Autres médecins avec une indisponibilité")
                remaining_combos = self._distribute_to_single_indispo_doctors(
                    date, remaining_combos, remaining_single_indispo, intervals
                )

            # Phase 4: Distribution équilibrée du reste
            if remaining_combos:
                logger.info("\nPhase 4: Distribution équilibrée")
                eligible_doctors = self._get_eligible_doctors(
                    date, remaining_combos, intervals, is_critical
                )
                self._distribute_remaining_combinations(
                    date, remaining_combos, eligible_doctors, intervals
                )

        except Exception as e:
            logger.error(f"Erreur distribution jour {date}: {e}")

    def _get_available_combinations_for_priority(self, date: date, 
                                            combinations: List[str],
                                            priority_level: str) -> List[Dict]:
        """
        Récupère les combinaisons disponibles pour un niveau de priorité donné.
        """
        available_combinations = []
        day = self.planning.get_day(date)
        if not day:
            return []

        # Collecter les slots non assignés
        unassigned_slots = defaultdict(list)
        for slot in day.slots:
            if not slot.assignee:
                unassigned_slots[slot.abbreviation].append(slot)

        # Pour chaque combinaison de ce niveau de priorité
        for combo in combinations:
            # Vérifier si c'est une combinaison personnalisée
            first_post, second_post = self._get_combo_posts(combo)

            if (first_post in unassigned_slots and second_post in unassigned_slots):
                weight = PRIORITY_WEIGHTS.get(priority_level, 1.0)
                available_combinations.append({
                    'combo': combo,
                    'first_post': first_post,
                    'second_post': second_post,
                    'priority': priority_level,
                    'weight': weight
                })

        return available_combinations

    def _get_combo_posts(self, combo: str) -> Tuple[str, str]:
        """Extrait les postes d'une combinaison standard ou personnalisée."""
        for custom_post in self.custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post
        return combo[:2], combo[2:]

    def _get_doctors_under_minimum(self, intervals: Dict) -> List[Tuple[Doctor, Dict, float]]:
        """Version modifiée qui utilise le nom du médecin comme identifiant unique"""
        doctors_under_min = []
        
        for doctor in self.doctors:
            doctor_intervals = intervals[doctor.name]
            min_gaps = []
            
            # Vérifier les minimums de groupe
            for group, interval in doctor_intervals['groups'].items():
                current = doctor_intervals['current_counts']['groups'].get(group, 0)
                min_val = interval.get('min', 0)
                if current < min_val:
                    gap_ratio = (min_val - current) / min_val
                    min_gaps.append(gap_ratio)

            # Vérifier les minimums de poste
            for post, interval in doctor_intervals['posts'].items():
                current = doctor_intervals['current_counts']['posts'].get(post, 0)
                min_val = interval.get('min', 0)
                if current < min_val:
                    gap_ratio = (min_val - current) / min_val
                    min_gaps.append(gap_ratio)

            if min_gaps:
                avg_gap = sum(min_gaps) / len(min_gaps)
                if doctor.half_parts == 2:
                    avg_gap *= 1.2
                doctors_under_min.append((doctor, doctor_intervals, avg_gap))

        return sorted(doctors_under_min, key=lambda x: x[2], reverse=True)

    def _get_single_indispo_doctors(self, date: date) -> List[Tuple[Doctor, int]]:
        """
        Identifie les médecins ayant une seule période d'indisponibilité.
        Retourne une liste de tuples (médecin, période_indisponible).
        """
        try:
            single_indispo_doctors = []

            for doctor in self.doctors:
                # Initialiser les périodes indisponibles
                indispo_periods = {1: False, 2: False, 3: False}  # Matin, AM, Soir
                
                # Vérifier chaque desiderata
                for desiderata in doctor.desiderata:
                    if desiderata.start_date <= date <= desiderata.end_date:
                        # Ne prendre en compte que les desiderata primaires
                        if not hasattr(desiderata, 'priority') or desiderata.priority == "primary":
                            period = desiderata.period
                            if 1 <= period <= 3:  # Vérifier que la période est valide
                                indispo_periods[period] = True

                # Compter le nombre de périodes indisponibles
                total_indispo = sum(1 for indispo in indispo_periods.values() if indispo)
                
                # Si exactement une période indisponible
                if total_indispo == 1:
                    # Trouver la période indisponible
                    indispo_period = next(period for period, is_indispo in indispo_periods.items() if is_indispo)
                    single_indispo_doctors.append((doctor, indispo_period))
                    logger.info(f"Médecin détecté avec une seule indisponibilité: {doctor.name} "
                            f"(période {indispo_period})")

            return single_indispo_doctors

        except Exception as e:
            logger.error(f"Erreur détection médecins indisponibles: {e}")
            return []
    
    def _distribute_to_single_indispo_doctors(self, date: date,
                                        available_combos: List[Dict],
                                        single_indispo_doctors: List[Tuple[Doctor, int]],
                                        intervals: Dict) -> List[Dict]:
        """
        Distribution aux médecins avec une seule indisponibilité.
        """
        try:
            remaining_combos = available_combos.copy()
            if not remaining_combos or not single_indispo_doctors:
                return remaining_combos

            logger.info(f"\nDistribution aux médecins indisponibles pour le {date}")

            # Pour chaque médecin avec une indisponibilité
            for doctor, indispo_period in single_indispo_doctors:
                if not self._is_doctor_available_for_weekday(doctor, date):
                    continue

                doctor_intervals = intervals[doctor.name]
                logger.info(f"\nTraitement {doctor.name} - indispo période {indispo_period}")

                # Trouver les combinaisons compatibles
                compatible_combos = self._filter_compatible_combinations(
                    doctor, date, remaining_combos, indispo_period
                )

                if compatible_combos:
                    # Trier par priorité
                    for priority_level in ['high_priority', 'medium_priority', 'low_priority']:
                        priority_combos = [
                            combo for combo in compatible_combos 
                            if combo['priority'] == priority_level
                        ]

                        if priority_combos:
                            # Trouver la meilleure combinaison
                            best_combo = self._find_best_combination(
                                doctor, date, priority_combos,
                                doctor_intervals
                            )

                            if best_combo and self._can_assign_combination(
                                doctor, date, best_combo, doctor_intervals
                            ):
                                # Attribuer la combinaison
                                if self._assign_combination(
                                    doctor, date, best_combo, doctor_intervals
                                ):
                                    remaining_combos.remove(best_combo)
                                    logger.info(f"Attribution réussie à {doctor.name}: "
                                            f"{best_combo['combo']} (indispo période {indispo_period})")
                                    break

            return remaining_combos

        except Exception as e:
            logger.error(f"Erreur distribution médecins indispo: {e}")
            return available_combos

    def _is_combo_compatible_with_indispo(self, combo: Dict, 
                                    indispo_period: int,
                                    period_mapping: Dict) -> bool:
        """
        Vérifie si une combinaison est compatible avec une période d'indisponibilité.
        """
        try:
            def get_post_period(post_type: str) -> Optional[int]:
                # Posts du matin
                if post_type in ["MM", "CM", "HM", "SM", "RM", "ML"]:
                    return 1
                # Posts de l'après-midi
                elif post_type in ["CA", "HA", "SA", "RA", "AL", "AC"]:
                    return 2
                # Posts du soir
                elif post_type in ["CS", "HS", "SS", "RS", "NA", "NM", "NC"]:
                    return 3
                
                # Poste personnalisé
                if post_type in self.custom_posts:
                    custom_post = self.custom_posts[post_type]
                    start_hour = custom_post.start_time.hour
                    
                    # Déterminer la période selon l'heure de début
                    if 7 <= start_hour < 13:
                        return 1
                    elif 13 <= start_hour < 18:
                        return 2
                    else:
                        return 3
                        
                return None

            first_period = get_post_period(combo['first_post'])
            second_period = get_post_period(combo['second_post'])

            # La combinaison est compatible si aucun des postes n'est dans la période indisponible
            return first_period != indispo_period and second_period != indispo_period

        except Exception as e:
            logger.error(f"Erreur vérification compatibilité: {e}")
            return False

    def _find_best_combination_for_indispo(self, doctor: Doctor, date: date,
                                        combos: List[Dict], doctor_intervals: Dict,
                                        indispo_period: int,
                                        period_mapping: Dict) -> Optional[Dict]:
        """
        Trouve la meilleure combinaison pour un médecin avec une indisponibilité.
        Prend en compte:
        - La compatibilité avec l'indisponibilité
        - La priorité de la combinaison
        - L'écart aux minimums
        - La répartition des périodes
        """
        try:
            best_combo = None
            best_score = float('-inf')

            for combo in combos:
                if not self._is_combo_compatible_with_indispo(
                    combo, indispo_period, period_mapping
                ):
                    continue

                # Calculer un score pour cette combinaison
                score = combo['weight']  # Score de base selon la priorité

                # Bonus si la combinaison aide à atteindre les minimums
                min_bonus = 0
                for post in [combo['first_post'], combo['second_post']]:
                    current = doctor_intervals['current_counts']['posts'].get(post, 0)
                    min_val = doctor_intervals['posts'].get(post, {}).get('min', 0)
                    if min_val > 0 and current < min_val:
                        min_bonus += (min_val - current) / min_val

                score += min_bonus * 0.5  # Bonus modéré pour les minimums

                # Vérifier si la combinaison est possible
                if self._can_assign_combination(doctor, date, combo, doctor_intervals):
                    # Facteur aléatoire (±10%)
                    score *= 1 + (random.random() * 0.2 - 0.1)

                    if score > best_score:
                        best_score = score
                        best_combo = combo

            return best_combo

        except Exception as e:
            logger.error(f"Erreur recherche meilleure combinaison indispo: {e}")
            return None

    def _get_eligible_doctors(self, date: date, available_combos: List[str],
                        intervals: Dict, is_critical: bool) -> List[Tuple[Doctor, float]]:
        """
        Identifie et score les médecins éligibles pour un jour donné.
        """
        try:
            eligible_doctors = []

            for doctor in self.doctors:
                # Vérifier la disponibilité de base
                if not self._is_doctor_available_for_weekday(doctor, date):
                    continue

                # Calculer le score d'éligibilité
                score = self._calculate_eligibility_score(
                    doctor, date, intervals[doctor.name],
                    is_critical
                )

                if score > 0:
                    eligible_doctors.append((doctor, score))

            # Trier par score décroissant
            return sorted(eligible_doctors, key=lambda x: x[1], reverse=True)

        except Exception as e:
            logger.error(f"Erreur calcul éligibilité: {e}")
            return []

    def _calculate_eligibility_score(self, doctor: Doctor, date: date,
                                doctor_intervals: Dict, is_critical: bool) -> float:
        """
        Calcule un score d'éligibilité pour un médecin.
        Prend en compte:
        - Distance aux minimums des groupes
        - Nombre de demi-parts
        - Périodes d'indisponibilité
        - Priorité critique
        """
        try:
            score = 1.0

            # 1. Score basé sur les minimums de groupe non atteints
            min_scores = []
            for group, interval in doctor_intervals['groups'].items():
                current = doctor_intervals['current_counts']['groups'][group]
                min_val = interval.get('min', 0)
                if current < min_val:
                    min_scores.append((min_val - current) / min_val)
            
            if min_scores:
                score *= (1 + sum(min_scores) / len(min_scores))

            # 2. Bonus pour les pleins temps
            if doctor.half_parts == 2:
                score *= 1.2

            # 3. Bonus pour les périodes d'indisponibilité
            indispo_periods = self._count_indispo_periods(doctor, date)
            if indispo_periods == 1:  # Une seule période indispo = plus flexible
                score *= 1.1

            # 4. Bonus pour les périodes critiques
            if is_critical:
                score *= 1.5

            # 5. Facteur aléatoire (±10%)
            score *= 1 + (random.random() * 0.2 - 0.1)

            return max(0.1, score)

        except Exception as e:
            logger.error(f"Erreur calcul score éligibilité: {e}")
            return 0.0

    def _count_indispo_periods(self, doctor: Doctor, date: date) -> int:
        """
        Compte le nombre de périodes d'indisponibilité pour un médecin à une date donnée.
        """
        periods_indispo = 0
        morning_indispo = False
        afternoon_indispo = False
        evening_indispo = False

        for desiderata in doctor.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                if desiderata.period == 1:  # Matin
                    morning_indispo = True
                elif desiderata.period == 2:  # Après-midi
                    afternoon_indispo = True
                elif desiderata.period == 3:  # Soir
                    evening_indispo = True

        return sum([morning_indispo, afternoon_indispo, evening_indispo])

    def _distribute_to_doctors_under_minimum(self, date: date, 
                                        available_combos: List[Dict],
                                        doctors_under_min: List[Tuple[Doctor, Dict, float]],
                                        intervals: Dict) -> List[Dict]:
        """
        Distribution prioritaire aux médecins sous leur minimum.
        Respecte strictement l'ordre de priorité des combinaisons.
        """
        remaining_combos = available_combos.copy()
        
        # Grouper les combinaisons par niveau de priorité
        priority_groups = defaultdict(list)
        for combo in remaining_combos:
            priority_groups[combo['priority']].append(combo)

        # Pour chaque niveau de priorité, dans l'ordre
        for priority_level in ['high_priority', 'medium_priority', 'low_priority']:
            priority_combos = priority_groups[priority_level]
            if not priority_combos:
                continue

            # Pour chaque médecin sous minimum
            for doctor, doctor_intervals, gap in doctors_under_min:
                if not self._is_doctor_available_for_weekday(doctor, date):
                    continue

                # Trouver la meilleure combinaison de ce niveau pour ce médecin
                best_combo = self._find_best_combination(
                    doctor, date, priority_combos, doctor_intervals
                )

                if best_combo and self._assign_combination(
                    doctor, date, best_combo, doctor_intervals
                ):
                    remaining_combos.remove(best_combo)
                    priority_combos.remove(best_combo)
                    logger.info(f"Attribution prioritaire à {doctor.name}: "
                            f"{best_combo['combo']} (sous minimum, gap: {gap:.2f})")

        return remaining_combos

    def _verify_doctor_distribution(self, intervals: Dict) -> bool:
        """
        Vérifie que la distribution finale respecte les contraintes.
        """
        all_ok = True
        logger.info("\nVÉRIFICATION FINALE DISTRIBUTION MÉDECINS")

        for doctor_name, doctor_intervals in intervals.items():
            logger.info(f"\n{doctor_name}:")
            
            # Vérifier les minimums de groupe
            for group, interval in doctor_intervals['groups'].items():
                current = doctor_intervals['current_counts']['groups'][group]
                min_val = interval.get('min', 0)
                max_val = interval.get('max', float('inf'))
                
                status = "OK"
                if current < min_val:
                    status = "SOUS MIN"
                    all_ok = False
                elif current > max_val:
                    status = "SUR MAX"
                    all_ok = False
                    
                logger.info(f"Groupe {group}: {current} [{min_val}-{max_val}] ({status})")

            # Vérifier les postes individuels
            for post, count in doctor_intervals['current_counts']['posts'].items():
                interval = doctor_intervals['posts'].get(post, {})
                min_val = interval.get('min', 0)
                max_val = interval.get('max', float('inf'))
                
                status = "OK"
                if count < min_val:
                    status = "SOUS MIN"
                    all_ok = False
                elif count > max_val:
                    status = "SUR MAX"
                    all_ok = False
                    
                logger.info(f"Poste {post}: {count} [{min_val}-{max_val}] ({status})")

        return all_ok
        
        
        
    def _get_available_combinations(self, date: date) -> List[Dict]:
        """
        Récupère toutes les combinaisons disponibles pour un jour donné.
        Retourne une liste de dictionnaires contenant :
        - combo: code de la combinaison
        - first_post: premier poste
        - second_post: deuxième poste
        - priority: niveau de priorité
        - weight: poids de la combinaison
        """
        try:
            available_combinations = []
            day = self.planning.get_day(date)
            if not day:
                return []

            # Récupérer les slots non assignés
            unassigned_slots = defaultdict(list)
            for slot in day.slots:
                if not slot.assignee:
                    unassigned_slots[slot.abbreviation].append(slot)

            # Pour chaque niveau de priorité
            for priority_level, combinations in WEEKDAY_PRIORITY_GROUPS.items():
                for combo in combinations:
                    # Vérifier si c'est une combinaison personnalisée
                    is_custom = False
                    for custom_post in self.custom_posts.values():
                        if combo in custom_post.possible_combinations.values():
                            is_custom = True
                            for post, combo_name in custom_post.possible_combinations.items():
                                if combo_name == combo:
                                    first_post = custom_post.name
                                    second_post = post
                                    break
                            break

                    # Si ce n'est pas personnalisé, extraire les postes standard
                    if not is_custom:
                        first_post, second_post = combo[:2], combo[2:]

                    # Vérifier la disponibilité des deux slots
                    if (first_post in unassigned_slots and second_post in unassigned_slots):
                        # Calculer le poids selon la priorité
                        weight = PRIORITY_WEIGHTS.get(priority_level, 1.0)
                        
                        available_combinations.append({
                            'combo': combo,
                            'first_post': first_post,
                            'second_post': second_post,
                            'priority': priority_level,
                            'weight': weight
                        })

            return available_combinations

        except Exception as e:
            logger.error(f"Erreur récupération combinaisons disponibles: {e}")
            return []

    def _find_best_combination(self, doctor: Doctor, date: date,
                            available_combos: List[Dict],
                            doctor_intervals: Dict) -> Optional[Dict]:
        """
        Trouve la meilleure combinaison pour un médecin donné.
        Prend en compte:
        - Les contraintes de groupe
        - Les contraintes individuelles de poste
        - La priorité de la combinaison
        - Les indisponibilités du médecin
        """
        try:
            best_combo = None
            best_score = -float('inf')

            for combo_info in available_combos:
                # Vérifier les contraintes de base
                if not self._can_assign_combination(doctor, date, combo_info, doctor_intervals):
                    continue

                # Calculer le score pour cette combinaison
                score = self._calculate_combination_score(
                    doctor, combo_info, doctor_intervals
                )

                # Mettre à jour si meilleur score
                if score > best_score:
                    best_score = score
                    best_combo = combo_info

            return best_combo

        except Exception as e:
            logger.error(f"Erreur recherche meilleure combinaison: {e}")
            return None

    def _can_assign_combination(self, doctor: Doctor, date: date,
                            combo_info: Dict, doctor_intervals: Dict) -> bool:
        """
        Vérifie si une combinaison peut être attribuée à un médecin.
        """
        try:
            day = self.planning.get_day(date)
            if not day:
                return False

            first_post = combo_info['first_post']
            second_post = combo_info['second_post']

            # 1. Vérifier les limites de groupe
            affected_groups = set()
            for post in [first_post, second_post]:
                group = self._get_post_group(post, date)
                if group:
                    affected_groups.add(group)
                    current = doctor_intervals['current_counts']['groups'].get(group, 0)
                    max_allowed = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                    if current >= max_allowed:
                        return False

            # 2. Vérifier les limites individuelles de poste
            for post in [first_post, second_post]:
                current = doctor_intervals['current_counts']['posts'].get(post, 0)
                max_allowed = doctor_intervals['posts'].get(post, {}).get('max', float('inf'))
                if current >= max_allowed:
                    return False

            # 3. Vérifier les contraintes globales via le système de contraintes
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)

            if not (first_slot and second_slot):
                return False

            return (self.constraints.can_assign_to_assignee(doctor, date, first_slot, self.planning) and
                    self.constraints.can_assign_to_assignee(doctor, date, second_slot, self.planning))

        except Exception as e:
            logger.error(f"Erreur vérification possibilité attribution: {e}")
            return False

    def _calculate_combination_score(self, doctor: Doctor,
                                combo_info: Dict,
                                doctor_intervals: Dict) -> float:
        """
        Calcule un score pour une combinaison.
        """
        try:
            score = combo_info['weight']  # Score de base selon la priorité

            # 1. Bonus pour les postes sous minimum
            for post in [combo_info['first_post'], combo_info['second_post']]:
                current = doctor_intervals['current_counts']['posts'].get(post, 0)
                min_required = doctor_intervals['posts'].get(post, {}).get('min', 0)
                if current < min_required:
                    score *= 1.2  # +20% si sous minimum

            # 2. Bonus pour les groupes sous minimum
            affected_groups = set()
            for post in [combo_info['first_post'], combo_info['second_post']]:
                group = self._get_post_group(post, datetime.now().date())
                if group:
                    affected_groups.add(group)

            for group in affected_groups:
                current = doctor_intervals['current_counts']['groups'].get(group, 0)
                min_required = doctor_intervals['groups'].get(group, {}).get('min', 0)
                if current < min_required:
                    score *= 1.3  # +30% si groupe sous minimum

            # 3. Malus si proche du maximum
            for post in [combo_info['first_post'], combo_info['second_post']]:
                current = doctor_intervals['current_counts']['posts'].get(post, 0)
                max_allowed = doctor_intervals['posts'].get(post, {}).get('max', float('inf'))
                if max_allowed < float('inf'):  # Si un maximum est défini
                    ratio = current / max_allowed
                    if ratio > 0.8:  # À plus de 80% du maximum
                        score *= (1 - (ratio - 0.8))  # Réduction progressive

            # 4. Facteur aléatoire (±10%)
            score *= 1 + (random.random() * 0.2 - 0.1)

            return max(0.1, score)

        except Exception as e:
            logger.error(f"Erreur calcul score combinaison: {e}")
            return 0.0

    def _assign_combination(self, doctor: Doctor, date: date,
                        combo_info: Dict, doctor_intervals: Dict) -> bool:
        """
        Attribue une combinaison à un médecin et met à jour les compteurs.
        """
        try:
            day = self.planning.get_day(date)
            if not day:
                return False

            first_post = combo_info['first_post']
            second_post = combo_info['second_post']

            # Trouver les slots correspondants
            first_slot = next((s for s in day.slots 
                            if s.abbreviation == first_post and not s.assignee), None)
            second_slot = next((s for s in day.slots 
                            if s.abbreviation == second_post and not s.assignee), None)

            if not (first_slot and second_slot):
                return False

            # Effectuer l'attribution
            first_slot.assignee = doctor.name
            second_slot.assignee = doctor.name

            # Mettre à jour les compteurs de postes
            doctor_intervals['current_counts']['posts'][first_post] += 1
            doctor_intervals['current_counts']['posts'][second_post] += 1

            # Mettre à jour les compteurs de groupe
            for post in [first_post, second_post]:
                group = self._get_post_group(post, date)
                if group:
                    doctor_intervals['current_counts']['groups'][group] += 1

            logger.info(f"Attribution à {doctor.name}: {combo_info['combo']} le {date}")
            return True

        except Exception as e:
            logger.error(f"Erreur attribution combinaison: {e}")
            return False

    def _get_post_group(self, post_type: str, date: date) -> Optional[str]:
        """
        Détermine le groupe de semaine d'un poste.
        """
        # Si c'est un poste personnalisé
        if post_type in self.custom_posts:
            return self.custom_posts[post_type].statistic_group

        # Groupes de consultation en fonction de l'heure
        if post_type in ["CM", "HM", "SM", "RM"]:
            return "XM"  # Consultation matin à partir de 9h
        elif post_type in ["MM"]:
            return "XmM"  # Consultation matin à partir de 7h
        elif post_type in ["CA", "HA", "SA", "RA"]:
            return "XA"  # Consultation après-midi
        elif post_type in ["CS", "HS", "SS", "RS"]:
            return "XS"  # Consultation soir

        # Groupes de visites
        elif post_type in ["ML"]:
            return "Vm"  # Visites matin
        elif post_type in ["AL", "AC"]:
            return "Va"  # Visites après-midi

        # Groupe nuit
        elif post_type in ["NM", "NC", "NA"]:
            return "NMC"  # Groupe nuit

        return None
        
        
        
    def _distribute_remaining_combinations(self, date: date,
                                        remaining_combos: List[Dict],
                                        eligible_doctors: List[Tuple[Doctor, float]],
                                        intervals: Dict) -> None:
        """
        Distribution équilibrée des combinaisons restantes.
        """
        try:
            if not remaining_combos or not eligible_doctors:
                return

            # Trier les médecins par score d'éligibilité
            sorted_doctors = sorted(eligible_doctors, key=lambda x: x[1], reverse=True)

            # Distribution équilibrée
            max_iterations = 3
            progress_made = True

            while remaining_combos and progress_made and max_iterations > 0:
                progress_made = False
                random.shuffle(sorted_doctors)  # Mélanger pour plus d'équité

                for doctor, base_score in sorted_doctors:
                    if self._has_assignment_for_day(doctor, date):
                        continue

                    adjusted_score = self._calculate_current_need_score(
                        doctor, intervals[doctor.name], remaining_combos
                    )

                    if adjusted_score > 0:
                        # Filtrer les combinaisons compatibles en vérifiant toutes les indisponibilités
                        compatible_combos = self._filter_compatible_combinations(
                            doctor, date, remaining_combos
                        )

                        if compatible_combos:
                            best_combo = self._find_best_combination(
                                doctor, date, compatible_combos, intervals[doctor.name]
                            )

                            if best_combo and self._assign_combination(
                                doctor, date, best_combo, intervals[doctor.name]
                            ):
                                remaining_combos.remove(best_combo)
                                progress_made = True
                                break  

                max_iterations -= 1

            if remaining_combos:
                logger.warning(f"Combinaisons non attribuées pour {date}: "
                            f"{[c['combo'] for c in remaining_combos]}")

        except Exception as e:
            logger.error(f"Erreur distribution restante: {e}")

    def _filter_compatible_combinations(self, doctor: Doctor, date: date,
                                    available_combos: List[Dict],
                                    indispo_period: Optional[int] = None) -> List[Dict]:
        """
        Filtre les combinaisons compatibles avec les indisponibilités d'un médecin.
        Si indispo_period est fourni, ne vérifie que cette période spécifique.
        Sinon, vérifie toutes les indisponibilités du médecin.
        """
        try:
            # Mapping des postes par période
            post_periods = {
                # Période 1 : Matin (7h-12h59)
                1: ["MM", "CM", "HM", "SM", "RM", "ML"],
                # Période 2 : Après-midi (13h-17h59)
                2: ["CA", "HA", "SA", "RA", "AL", "AC"],
                # Période 3 : Soir (18h-7h)
                3: ["CS", "HS", "SS", "RS", "NA", "NM", "NC"]
            }

            def get_post_period(post: str) -> Optional[int]:
                # Vérifier d'abord si c'est un poste personnalisé
                if post in self.custom_posts:
                    custom_post = self.custom_posts[post]
                    start_hour = custom_post.start_time.hour
                    if 7 <= start_hour < 13:
                        return 1
                    elif 13 <= start_hour < 18:
                        return 2
                    else:
                        return 3
                
                # Sinon chercher dans les postes standards
                for period, posts in post_periods.items():
                    if post in posts:
                        return period
                return None

            # Si une période spécifique est fournie, utiliser uniquement celle-ci
            if indispo_period is not None:
                indispo_periods = {indispo_period}
            else:
                # Sinon, détecter toutes les périodes indisponibles
                indispo_periods = set()
                for desiderata in doctor.desiderata:
                    if desiderata.start_date <= date <= desiderata.end_date:
                        if not hasattr(desiderata, 'priority') or desiderata.priority == "primary":
                            if 1 <= desiderata.period <= 3:
                                indispo_periods.add(desiderata.period)

            # Filtrer les combinaisons
            compatible_combos = []
            for combo in available_combos:
                first_post = combo['first_post']
                second_post = combo['second_post']
                
                first_period = get_post_period(first_post)
                second_period = get_post_period(second_post)
                
                if first_period is None or second_period is None:
                    continue
                    
                # Une combinaison est compatible si aucun de ses postes
                # n'est dans une période indisponible
                if not any(period in indispo_periods 
                        for period in [first_period, second_period]):
                    compatible_combos.append(combo)
                    if indispo_period is not None:
                        logger.debug(f"Combinaison compatible trouvée: {combo['combo']} "
                                f"pour {doctor.name} avec indispo période {indispo_period}")

            return compatible_combos

        except Exception as e:
            logger.error(f"Erreur filtrage combinaisons: {e}")
            return []
    def _has_assignment_for_day(self, doctor: Doctor, date: date) -> bool:
        """
        Vérifie si un médecin a déjà une attribution pour ce jour.
        """
        day = self.planning.get_day(date)
        if not day:
            return False

        return any(slot.assignee == doctor.name for slot in day.slots)

    def _calculate_current_need_score(self, doctor: Doctor, doctor_intervals: Dict,
                                    remaining_combos: List[Dict]) -> float:
        """
        Calcule un score de besoin actuel pour un médecin.
        Prend en compte:
        - Distance aux minimums non atteints
        - Nombre de demi-parts
        - Équilibre entre les différents types de poste
        """
        try:
            score = 1.0

            # 1. Score basé sur les minimums non atteints
            group_min_scores = []
            for group, interval in doctor_intervals['groups'].items():
                current = doctor_intervals['current_counts']['groups'].get(group, 0)
                min_val = interval.get('min', 0)
                if min_val > 0:
                    ratio = current / min_val
                    if ratio < 1:
                        group_min_scores.append(1 - ratio)

            if group_min_scores:
                score *= (1 + sum(group_min_scores) / len(group_min_scores))

            # 2. Bonus pour les pleins temps sous-utilisés
            if doctor.half_parts == 2:
                total_assignments = sum(
                    doctor_intervals['current_counts']['groups'].get(group, 0)
                    for group in doctor_intervals['groups']
                )
                if total_assignments < len(doctor_intervals['groups']):
                    score *= 1.2

            # 3. Malus si proche des maximums
            max_ratios = []
            for group, interval in doctor_intervals['groups'].items():
                current = doctor_intervals['current_counts']['groups'].get(group, 0)
                max_val = interval.get('max', float('inf'))
                if max_val < float('inf'):
                    ratio = current / max_val
                    if ratio > 0.8:  # À plus de 80% du maximum
                        max_ratios.append(ratio)

            if max_ratios:
                avg_max_ratio = sum(max_ratios) / len(max_ratios)
                score *= (1 - (avg_max_ratio - 0.8))

            # 4. Facteur aléatoire (±10%)
            score *= 1 + (random.random() * 0.2 - 0.1)

            return max(0.1, score)

        except Exception as e:
            logger.error(f"Erreur calcul score besoin: {e}")
            return 0.0
        
        
        
        
        
        
        
        
        
        
        
    def distribute_remaining_weekday_posts(self) -> bool:
        """
        Distribution des postes restants de semaine après la distribution des combinaisons.
        Processus en deux phases principales :
        1. Distribution aux CAT avec respect strict des quotas
        2. Distribution aux médecins avec gestion des minimums et équilibrage
        
        Returns:
            bool: True pour indiquer que le processus s'est déroulé (même si distribution incomplète)
        """
        try:
            logger.info("\nDISTRIBUTION DES POSTES RESTANTS SEMAINE")
            logger.info("=" * 80)

            # 1. Collecter et analyser les postes restants
            # ---------------------------------------------
            # Récupération de tous les postes non attribués (hors NLv)
            remaining_posts = self._collect_remaining_weekday_posts()
            if not remaining_posts:
                logger.info("Aucun poste restant à distribuer")
                return True

            # Log des postes à distribuer
            total_slots = sum(len(slots) for slots in remaining_posts.values())
            logger.info(f"Postes restants à distribuer: {total_slots}")
            for post_type, slots in remaining_posts.items():
                if slots:
                    logger.info(f"  {post_type}: {len(slots)} slots")

            # 2. Préparation de la matrice de disponibilité
            # --------------------------------------------
            # Initialisation de la matrice pour l'analyse des périodes critiques
            availability_matrix = AvailabilityMatrix(
                self.planning.start_date,
                self.planning.end_date,
                self.doctors,
                self.cats
            )

            # 3. Organisation et tri des dates
            # ------------------------------
            # Récupération des jours de semaine hors weekend/fériés
            weekdays = self._get_weekdays(self.planning)
            
            # Organisation des dates selon leur criticité (<40% disponibilité)
            dates_by_criticality = self._organize_dates_by_criticality(
                weekdays, 
                availability_matrix
            )

            # 4. Phase 1 - Distribution aux CAT
            # --------------------------------
            logger.info("\nPHASE 1: DISTRIBUTION AUX CAT")
            self._distribute_remaining_to_cats(
                remaining_posts,
                dates_by_criticality
            )

            # Vérification des postes restants après CAT
            remaining_after_cat = sum(
                len(slots) for slots in remaining_posts.values()
            )
            logger.info(f"\nPostes restants après distribution CAT: {remaining_after_cat}")

            # Si plus aucun poste à distribuer, terminer
            if remaining_after_cat == 0:
                logger.info("Distribution terminée - tous les postes attribués aux CAT")
                return True

            # 5. Préparation distribution médecins
            # ----------------------------------
            # Récupération des intervalles depuis la pré-analyse
            intervals = self._get_doctor_weekday_intervals()
            if not intervals:
                logger.error("Impossible de récupérer les intervalles - arrêt distribution")
                return True

            # 6. Phase 2 - Distribution aux médecins
            # ------------------------------------
            logger.info("\nPHASE 2: DISTRIBUTION AUX MÉDECINS")
            
            # Initialisation du tracker de quotas pour les médecins
            quota_tracker = QuotaTracker(self.planning, self.doctors, "weekday")
            
            # Distribution en trois passes
            # 6.1 - Distribution des minimums
            logger.info("\nPasse 1: Distribution pour atteindre les minimums")
            remaining_posts = self._distribute_doctor_minimums(
                remaining_posts,
                dates_by_criticality,
                quota_tracker,
                intervals
            )

            # 6.2 - Distribution équilibrée
            if any(posts for posts in remaining_posts.values()):
                logger.info("\nPasse 2: Distribution équilibrée")
                remaining_posts = self._distribute_remaining_balanced(
                    remaining_posts,
                    dates_by_criticality,
                    quota_tracker,
                    intervals
                )

            # 6.3 - Distribution avec assouplissement
            if any(posts for posts in remaining_posts.values()):
                logger.info("\nPasse 3: Distribution avec assouplissement")
                self._distribute_with_relaxed_constraints(
                    remaining_posts,
                    dates_by_criticality,
                    quota_tracker,
                    intervals
                )

            # 7. Vérification finale et logging
            # -------------------------------
            unassigned = sum(
                len([slot for date, slot in slots if not slot.assignee])
                for slots in remaining_posts.values()
            )

            # Log du résultat final
            if unassigned > 0:
                logger.warning(f"\nDistribution incomplète: {unassigned} postes non attribués")
                # Détail des postes non attribués
                for post_type, slots in remaining_posts.items():
                    unassigned_slots = [slot for date, slot in slots if not slot.assignee]
                    if unassigned_slots:
                        logger.warning(f"  {post_type}: {len(unassigned_slots)} slots")
            else:
                logger.info("\nDistribution complète - tous les postes ont été attribués")

            # Retourner True même si distribution incomplète
            return True

        except Exception as e:
            logger.error(f"Erreur dans la distribution des postes restants: {e}", 
                        exc_info=True)
            return True

    def _collect_remaining_weekday_posts(self) -> Dict[str, List[Tuple[date, TimeSlot]]]:
        """Collecte tous les postes non attribués de la semaine, en excluant NLv."""
        remaining = defaultdict(list)

        for day in self.planning.days:
            if (day.is_weekend or day.is_holiday_or_bridge or 
                day.date.weekday() == 4):  # Exclure les vendredis (NLv)
                continue

            for slot in day.slots:
                if not slot.assignee and slot.abbreviation != "NLv":
                    remaining[slot.abbreviation].append((day.date, slot))

        # Log des postes restants
        logger.info("\nPostes restants à distribuer:")
        total_slots = 0
        for post_type, slots in remaining.items():
            if slots:
                logger.info(f"{post_type}: {len(slots)} slots")
                total_slots += len(slots)
        logger.info(f"Total: {total_slots} slots")

        return remaining

    def _organize_dates_by_criticality(self, weekdays: List[date],
                                    availability_matrix: AvailabilityMatrix) -> Dict:
        """
        Organise les dates de semaine par niveau de criticité basé sur la disponibilité du personnel.
        
        Args:
            weekdays: Liste des dates de semaine à organiser
            availability_matrix: Matrice de disponibilité pour l'analyse
        
        Returns:
            Dict avec deux clés 'critical' et 'normal' contenant les listes de dates
        """
        organized_dates = {
            'critical': [],
            'normal': []
        }
        
        for date in weekdays:
            # Calculer la disponibilité pour cette date
            available_count = sum(
                1 for person in self.doctors + self.cats
                if availability_matrix.get_period_availability(person.name, date, "morning")
            )
            total_personnel = len(self.doctors) + len(self.cats)
            
            if total_personnel == 0:
                continue
                
            availability = (available_count / total_personnel) * 100
            
            # Classifier la date selon la disponibilité
            if availability < 40:  # Période critique si moins de 40% de disponibilité
                organized_dates['critical'].append(date)
            else:
                organized_dates['normal'].append(date)
                
        # Mélanger les dates dans chaque catégorie pour plus d'équité
        random.shuffle(organized_dates['critical'])
        random.shuffle(organized_dates['normal'])
        
        # Log de la répartition
        logger.info("\nRépartition des dates de semaine:")
        logger.info(f"Périodes critiques: {len(organized_dates['critical'])} dates")
        logger.info(f"Périodes normales: {len(organized_dates['normal'])} dates")
        
        return organized_dates

    def _distribute_remaining_to_cats(self, remaining_posts: Dict, 
                                dates_by_criticality: Dict) -> None:
        """
        Distribution des postes restants aux CAT avec gestion stricte des quotas.
        
        Args:
            remaining_posts: Dictionnaire des postes restants à attribuer
            dates_by_criticality: Dates organisées par niveau de criticité
        """
        try:
            logger.info("\nDISTRIBUTION DES POSTES RESTANTS AUX CAT")
            
            # Initialisation du tracker de quotas
            quota_tracker = QuotaTracker(self.planning, self.cats, "weekday")
            
            # Pour chaque niveau de criticité (critique puis standard)
            for criticality in ['critical', 'normal']:
                logger.info(f"\nTraitement des périodes {criticality}")
                dates = dates_by_criticality[criticality]
                
                if not dates:
                    continue
                    
                # Pour chaque date du niveau actuel
                for current_date in dates:
                    # Récupérer les postes disponibles pour cette date
                    available_posts = self._get_available_posts_for_date(
                        current_date, remaining_posts
                    )
                    
                    if not available_posts:
                        continue
                        
                    # Traiter chaque CAT dans un ordre aléatoire
                    cats = list(self.cats)
                    random.shuffle(cats)
                    
                    for cat in cats:
                        if not self._is_cat_available_for_weekday(cat, current_date):
                            continue
                            
                        # Récupérer les quotas restants pour ce CAT
                        remaining_quotas = quota_tracker.get_remaining_quotas(cat)
                        
                        # Pour chaque type de poste disponible
                        for post_type, slots in available_posts.items():
                            # Vérifier si le CAT a encore un quota pour ce type
                            if remaining_quotas['posts'].get(post_type, 0) <= 0:
                                continue
                                
                            for day, slot in slots[:]:  # Copie pour itération sûre
                                if slot.assignee:  # Déjà attribué
                                    continue
                                    
                                # Vérifier les contraintes et quotas
                                if quota_tracker.can_assign_post(cat, post_type):
                                    if self.constraints.can_assign_to_assignee(
                                        cat, current_date, slot, self.planning
                                    ):
                                        # Attribution
                                        slot.assignee = cat.name
                                        quota_tracker.update_assignment(
                                            cat, post_type, current_date
                                        )
                                        logger.info(f"Attribution {post_type} à {cat.name} "
                                                f"le {current_date}")
                                        break  # Passer au type de poste suivant
            
            # Log des quotas finaux
            logger.info("\nQuotas et attributions CAT:")
            for cat in self.cats:
                logger.info(f"\n{cat.name}:")
                remaining = quota_tracker.get_remaining_quotas(cat)
                
                for post_type in sorted(ALL_POST_TYPES):
                    total = self.post_configuration.weekday.get(post_type, 0)
                    assigned = total - remaining['posts'].get(post_type, 0)
                    remaining_count = remaining['posts'].get(post_type, 0)
                    
                    logger.info(f"{post_type}: {assigned} attribués / {total} total "
                            f"({remaining_count} restants)")

        except Exception as e:
            logger.error(f"Erreur distribution CAT: {e}")
            
    def _get_available_posts_for_date(self, date: date, 
                                    remaining_posts: Dict) -> Dict[str, List[Tuple[date, TimeSlot]]]:
        """
        Récupère les postes disponibles pour une date donnée.
        
        Args:
            date: Date à vérifier
            remaining_posts: Dictionnaire des postes restants
            
        Returns:
            Dict des postes disponibles avec leurs slots pour cette date
        """
        available = {}
        
        # Pour chaque type de poste
        for post_type, post_slots in remaining_posts.items():
            # Filtrer les slots pour cette date
            date_slots = [(d, s) for d, s in post_slots if d == date and not s.assignee]
            if date_slots:
                available[post_type] = date_slots
                
        return available

    def _calculate_remaining_need(self, cat_quotas: Dict) -> int:
        """
        Calcule le nombre total de postes restant à attribuer.
        """
        total_remaining = 0
        for cat_quotas in cat_quotas.values():
            for quota in cat_quotas.values():
                if quota > 0:  # Ne compter que les quotas positifs
                    total_remaining += quota
        return total_remaining

    def _get_cat_quotas(self) -> Dict[str, Dict[str, int]]:
        """
        Récupère les quotas restants pour chaque CAT en tenant compte
        de toutes les attributions précédentes.
        """
        total_quotas = self.planning.pre_analysis_results["cat_posts"]["weekday"]

        # Compter tous les postes déjà attribués (hors weekend/férié/vendredi)
        current_assignments = defaultdict(lambda: defaultdict(int))
        for day in self.planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge or day.date.weekday() == 4):
                for slot in day.slots:
                    if slot.assignee:
                        for cat in self.cats:
                            if slot.assignee == cat.name:
                                current_assignments[cat.name][slot.abbreviation] += 1

        # Calculer les quotas restants
        remaining_quotas = defaultdict(lambda: defaultdict(int))
        for cat in self.cats:
            for post_type, total in total_quotas.items():
                if post_type == "NLv":  # Ignorer les NLv
                    continue

                # Vérifier si le quota est déjà dépassé
                assigned = current_assignments[cat.name].get(post_type, 0)
                if assigned > total:
                    logger.error(f"ALERTE: {cat.name} a dépassé son quota de {post_type} "
                            f"({assigned}/{total})")
                    continue

                # Calculer le quota restant
                remaining = total - assigned
                if remaining > 0:
                    remaining_quotas[cat.name][post_type] = remaining

        # Log des quotas et postes attribués
        logger.info("\nQuotas et attributions CAT:")
        for cat_name in remaining_quotas:
            logger.info(f"\n{cat_name}:")
            for post_type in sorted(total_quotas.keys()):
                if post_type != "NLv":
                    total = total_quotas[post_type]
                    assigned = current_assignments[cat_name].get(post_type, 0)
                    remaining = remaining_quotas[cat_name].get(post_type, 0)
                    logger.info(f"{post_type}: {assigned} attribués / {total} total "
                            f"({remaining} restants)")

        return remaining_quotas
    def _calculate_remaining_cat_quotas(self, cat_quotas: Dict) -> Dict:
        """Calcule les quotas restants pour chaque CAT."""
        remaining_quotas = defaultdict(lambda: defaultdict(int))

        # D'abord, compter ce qui est déjà attribué à chaque CAT
        current_assignments = defaultdict(lambda: defaultdict(int))
        for day in self.planning.days:
            if not (day.is_weekend or day.is_holiday_or_bridge or day.date.weekday() == 4):
                for slot in day.slots:
                    if slot.assignee:
                        for cat in self.cats:
                            if slot.assignee == cat.name:
                                current_assignments[cat.name][slot.abbreviation] += 1

        # Pour chaque type de poste
        for post_type, total_quota in cat_quotas.items():
            if post_type == "NLv":
                continue

            # Quota théorique par CAT
            quota_per_cat = total_quota  # Pas de division, on prend le quota total

            # Pour chaque CAT
            for cat in self.cats:
                current = current_assignments[cat.name].get(post_type, 0)
                remaining = max(0, quota_per_cat - current)
                
                if remaining > 0:
                    remaining_quotas[cat.name][post_type] = remaining
                    logger.info(f"{cat.name}: {remaining} {post_type} restants "
                            f"(quota: {quota_per_cat}, actuel: {current})")

        return remaining_quotas
    def _can_assign_to_cat(self, cat: CAT, post_type: str, date: date,
                        slot: TimeSlot, remaining_quotas: Dict,
                        respect_secondary: bool = True) -> bool:
        """
        Vérifie si l'attribution est possible en respectant strictement les quotas.
        """
        # 1. Vérifier le quota restant
        if remaining_quotas[cat.name].get(post_type, 0) <= 0:
            return False

        # 2. Vérifier les contraintes de base
        if not self.constraints.can_assign_to_assignee(
            cat, date, slot, self.planning, respect_secondary=respect_secondary
        ):
            return False

        return True

    def _distribute_cat_posts_for_date(self, date: date, remaining_posts: Dict,
                                    cat_quotas: Dict, is_critical: bool,
                                    respect_secondary: bool) -> None:
        """
        Distribution des postes pour une date donnée.
        Respecte strictement les quotas et gère l'assouplissement des desiderata.
        """
        try:
            # 1. Collecter les slots disponibles pour cette date
            slots_by_type = defaultdict(list)
            for post_type, slots in remaining_posts.items():
                slots_by_type[post_type] = [
                    (d, s) for d, s in slots 
                    if d == date and not s.assignee
                ]

            if not slots_by_type:
                return

            # 2. Trier les types de poste par priorité
            priority_posts = self._prioritize_posts(slots_by_type, cat_quotas)

            # 3. Pour chaque type de poste prioritaire
            for post_type in priority_posts:
                if not slots_by_type[post_type]:
                    continue

                # Trier les CAT par quota restant décroissant
                eligible_cats = [
                    (cat, cat_quotas[cat.name][post_type])
                    for cat in self.cats
                    if cat_quotas[cat.name].get(post_type, 0) > 0
                ]
                eligible_cats.sort(key=lambda x: x[1], reverse=True)

                # Pour chaque CAT éligible
                for cat, remaining_quota in eligible_cats:
                    if remaining_quota <= 0:
                        continue

                    # Vérifier les desiderata
                    if not self._is_cat_available(cat, date, respect_secondary):
                        continue

                    # Pour chaque slot disponible
                    for d, slot in list(slots_by_type[post_type]):
                        # Double vérification des contraintes
                        if self.constraints.can_assign_to_assignee(
                            cat, date, slot, self.planning,
                            respect_secondary=respect_secondary
                        ):
                            # Attribution du slot
                            slot.assignee = cat.name
                            cat_quotas[cat.name][post_type] -= 1
                            
                            # Retirer le slot des disponibles
                            slots_by_type[post_type].remove((d, slot))
                            remaining_posts[post_type].remove((d, slot))

                            mode = "critique" if is_critical else "standard"
                            constraints = "" if respect_secondary else " (assoupli)"
                            logger.info(f"{cat.name}: {post_type} attribué le {date}"
                                    f" [{mode}{constraints}] - "
                                    f"restant: {cat_quotas[cat.name][post_type]}")
                            break

        except Exception as e:
            logger.error(f"Erreur lors de la distribution pour {date}: {e}")

    def _is_cat_available(self, cat: CAT, date: date, respect_secondary: bool) -> bool:
        """
        Vérifie si un CAT est disponible pour une date, avec gestion des desiderata.
        """
        for desiderata in cat.desiderata:
            if desiderata.start_date <= date <= desiderata.end_date:
                # Toujours respecter les desiderata primaires
                if not hasattr(desiderata, 'priority') or desiderata.priority == "primary":
                    return False
                # Desiderata secondaires selon le mode
                if respect_secondary and desiderata.priority == "secondary":
                    return False
        return True

    def _prioritize_posts(self, slots_by_type: Dict, cat_quotas: Dict) -> List[str]:
        """
        Priorise les types de poste basé sur le besoin total et la disponibilité.
        """
        post_scores = {}
        for post_type, slots in slots_by_type.items():
            if not slots:
                continue

            # Calculer le besoin total pour ce type
            total_need = sum(
                quotas.get(post_type, 0)
                for quotas in cat_quotas.values()
            )

            if total_need <= 0:
                continue

            # Score basé sur le ratio besoin/disponibilité
            availability = len(slots)
            urgency_score = total_need / availability
            
            # Ajouter un facteur aléatoire (±10%)
            random_factor = 1 + (random.random() * 0.2 - 0.1)
            post_scores[post_type] = urgency_score * random_factor

        # Retourner les types triés par score décroissant
        return sorted(post_scores.keys(), key=lambda p: post_scores[p], reverse=True)

    
    def _log_final_distribution_results(self, initial_quotas: Dict, final_quotas: Dict) -> None:
        """
        Log détaillé des résultats de la distribution.
        """
        logger.info("\nRÉSULTATS FINAUX DE LA DISTRIBUTION CAT:")
        logger.info("=" * 60)
        
        for cat_name in initial_quotas:
            logger.info(f"\n{cat_name}:")
            
            # Comparer chaque type de poste
            for post_type in initial_quotas[cat_name]:
                initial = initial_quotas[cat_name][post_type]
                final = final_quotas[cat_name].get(post_type, 0)
                attributed = initial - final
                
                if initial > 0:  # Ne log que les postes pertinents
                    status = "OK" if final == 0 else f"INCOMPLET ({final} restants)"
                    logger.info(f"{post_type}: {attributed}/{initial} attribués - {status}")
                    
    def _verify_cat_quotas(self, cat_quotas: Dict) -> None:
        """Vérifie les quotas restants et l'impossibilité de distribution."""
        logger.info("\nVérification finale des quotas CAT:")
        
        for cat_name, quotas in cat_quotas.items():
            logger.info(f"\n{cat_name}:")
            for post_type, remaining in quotas.items():
                if remaining > 0:
                    logger.warning(f"{post_type}: {remaining} non attribués")
                    
                    
                    
    
    
    def _initialize_doctor_intervals(self, intervals: Dict) -> Dict:
        """Initialise les compteurs avec les postes déjà attribués."""
        for doctor_name, doctor_intervals in intervals.items():
            # Initialiser les compteurs à zéro
            doctor_intervals['current_counts'] = {
                'posts': defaultdict(int),
                'groups': defaultdict(int)
            }
            
            # Compter les postes existants (hors weekend/fériés)
            for day in self.planning.days:
                if day.is_weekend or day.is_holiday_or_bridge:
                    continue
                    
                for slot in day.slots:
                    if slot.assignee == doctor_name:
                        post_type = slot.abbreviation
                        doctor_intervals['current_counts']['posts'][post_type] += 1
                        
                        # Compter aussi pour le groupe
                        group = self._get_post_group(post_type, day.date)
                        if group:
                            doctor_intervals['current_counts']['groups'][group] += 1

            # Log des compteurs initiaux
            logger.debug(f"\nCompteurs initiaux pour {doctor_name}:")
            for post_type, count in doctor_intervals['current_counts']['posts'].items():
                if count > 0:
                    logger.debug(f"  {post_type}: {count}")
            for group, count in doctor_intervals['current_counts']['groups'].items():
                if count > 0:
                    logger.debug(f"  Groupe {group}: {count}")

        return intervals
    
    
    def _distribute_remaining_to_doctors(self, remaining_posts: Dict, 
                                        dates_by_criticality: Dict,
                                        intervals: Dict) -> None:
        """
        Distribution des postes restants de semaine aux médecins.
        Processus en plusieurs passes pour garantir les minimums et l'équité.
        """
        try:
            logger.info("\nDISTRIBUTION DES POSTES RESTANTS AUX MÉDECINS")
            logger.info("=" * 80)
            
            # Initialiser les intervalles avec les postes existants
            intervals = self._initialize_doctor_intervals(intervals)
            # Initialisation du tracker de quotas pour les médecins
            quota_tracker = QuotaTracker(self.planning, self.doctors, "weekday")

            # Phase 1: Distribution pour atteindre les minimums
            logger.info("\nPhase 1: Distribution des minimums")
            remaining_posts = self._distribute_doctor_minimums(
                remaining_posts,
                dates_by_criticality,
                quota_tracker,
                intervals
            )

            # Phase 2: Distribution équilibrée des postes restants
            if any(posts for posts in remaining_posts.values()):
                logger.info("\nPhase 2: Distribution équilibrée")
                remaining_posts = self._distribute_remaining_balanced(
                    remaining_posts,
                    dates_by_criticality,
                    quota_tracker,
                    intervals
                )

            # Phase 3: Distribution avec assouplissement des desiderata secondaires
            if any(posts for posts in remaining_posts.values()):
                logger.info("\nPhase 3: Distribution avec assouplissement")
                self._distribute_with_relaxed_constraints(
                    remaining_posts,
                    dates_by_criticality,
                    quota_tracker,
                    intervals
                )

        except Exception as e:
            logger.error(f"Erreur distribution médecins: {e}", exc_info=True)

    def _distribute_doctor_minimums(self, remaining_posts: Dict,
                                dates_by_criticality: Dict,
                                quota_tracker: QuotaTracker,
                                intervals: Dict) -> Dict:
        """
        Distribution prioritaire pour atteindre les minimums requis.
        Priorité aux médecins avec le plus grand écart.
        """
        try:
            remaining = remaining_posts.copy()

            while True:
                # Identifier les médecins sous leur minimum
                doctors_under_min = self._get_doctors_under_minimum(intervals)
                if not doctors_under_min:
                    break

                # Trier par écart décroissant
                doctors_under_min.sort(key=lambda x: x[2], reverse=True)
                progress_made = False

                # Pour chaque type de criticité
                for criticality in ['critical', 'normal']:
                    if not progress_made:
                        dates = dates_by_criticality[criticality]
                        random.shuffle(dates)  # Ordre aléatoire

                        for date in dates:
                            if self._try_minimum_distribution(
                                date, remaining, doctors_under_min,
                                quota_tracker, intervals
                            ):
                                progress_made = True
                                break

                if not progress_made:
                    break  # Aucune attribution possible

            return remaining

        except Exception as e:
            logger.error(f"Erreur distribution minimums: {e}")
            return remaining_posts

    def _try_minimum_distribution(self, date: date, remaining_posts: Dict,
                                doctors_under_min: List[Tuple],
                                quota_tracker: QuotaTracker,
                                intervals: Dict) -> bool:
        """Tente d'attribuer des postes aux médecins sous leur minimum."""
        try:
            # Postes disponibles pour cette date
            available = self._get_available_posts_for_date(date, remaining_posts)
            if not available:
                return False

            # Pour chaque médecin sous minimum
            for doctor, doctor_intervals, gap in doctors_under_min:
                if not self._is_doctor_available_for_weekday(doctor, date):
                    continue

                # Trouver le meilleur poste pour ce médecin
                best_post = self._find_best_post_for_minimum(
                    doctor, available, doctor_intervals
                )

                if best_post:
                    post_type, slot = best_post
                    if self._assign_post_to_doctor(
                        doctor, date, post_type, slot,
                        intervals[doctor.name], quota_tracker
                    ):
                        # Mettre à jour les listes disponibles
                        slots = remaining_posts[post_type]
                        slots.remove((date, slot))
                        if not slots:
                            del remaining_posts[post_type]
                        return True

            return False

        except Exception as e:
            logger.error(f"Erreur distribution minimum: {e}")
            return False

    def _find_best_post_for_minimum(self, doctor: Doctor,
                                available_posts: Dict,
                                doctor_intervals: Dict) -> Optional[Tuple]:
        """Trouve le meilleur poste pour atteindre le minimum."""
        best_score = -float('inf')
        best_post = None

        for post_type, slots in available_posts.items():
            # Vérifier l'écart au minimum
            current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
            min_required = doctor_intervals['posts'].get(post_type, {}).get('min', 0)

            if current >= min_required:
                continue

            score = (min_required - current) / min_required if min_required > 0 else 0
            
            # Bonus pour les pleins temps
            if doctor.half_parts == 2:
                score *= 1.2

            # Facteur aléatoire
            score *= 1 + (random.random() * 0.2 - 0.1)

            if score > best_score:
                for date, slot in slots:
                    if self.constraints.can_assign_to_assignee(
                        doctor, date, slot, self.planning
                    ):
                        best_score = score
                        best_post = (post_type, slot)
                        break

        return best_post

    def _distribute_remaining_balanced(self, remaining_posts: Dict,
                                    dates_by_criticality: Dict,
                                    quota_tracker: QuotaTracker,
                                    intervals: Dict) -> Dict:
        """Distribution équilibrée avec suivi strict des progrès."""
        try:
            remaining = remaining_posts.copy()
            total_before = self._count_unassigned_posts(remaining)
            logger.info(f"Début distribution équilibrée: {total_before} postes à attribuer")
            
            max_attempts = 3
            current_attempt = 0

            while current_attempt < max_attempts:
                doctor_scores = self._calculate_equity_scores()
                posts_attributed = 0

                for criticality in ['critical', 'normal']:
                    dates = dates_by_criticality[criticality]
                    random.shuffle(dates)

                    for date in dates:
                        if self._try_balanced_distribution(
                            date, remaining, doctor_scores,
                            quota_tracker, intervals
                        ):
                            posts_attributed += 1

                total_after = self._count_unassigned_posts(remaining)
                if posts_attributed == 0 or total_after >= total_before:
                    logger.info(f"Arrêt distribution équilibrée: plus de progrès possible")
                    break

                logger.info(f"Passe {current_attempt + 1}: {posts_attributed} postes attribués")
                total_before = total_after
                current_attempt += 1

            return remaining

        except Exception as e:
            logger.error(f"Erreur distribution équilibrée: {e}")
            return remaining_posts

    def _calculate_equity_scores(self) -> Dict[str, float]:
        """
        Calcule un score d'équité pour chaque médecin basé sur
        le nombre total de postes (weekend + semaine).
        """
        scores = {}
        
        for doctor in self.doctors:
            # Compter tous les postes attribués
            total_posts = 0
            for day in self.planning.days:
                total_posts += sum(
                    1 for slot in day.slots
                    if slot.assignee == doctor.name
                )
            
            # Score inversement proportionnel au nombre de postes
            base_score = 1.0 / (total_posts + 1)  # Éviter division par zéro
            
            # Ajustement selon le nombre de demi-parts
            if doctor.half_parts == 2:
                base_score *= 1.2
                
            # Facteur aléatoire
            scores[doctor.name] = base_score * (1 + random.random() * 0.2 - 0.1)
            
        return scores

    def _distribute_with_relaxed_constraints(self, remaining_posts: Dict,
                                        dates_by_criticality: Dict,
                                        quota_tracker: QuotaTracker,
                                        intervals: Dict) -> None:
        try:
            # Comptage précis des postes restants avant distribution
            initial_unassigned = self._count_unassigned_posts(remaining_posts)
            logger.info(f"Postes non attribués avant assouplissement: {initial_unassigned}")

            # 1. Identifier les médecins sous minimum (posts ET groupes)
            doctors_under_min = []
            for doctor in self.doctors:
                doctor_intervals = intervals[doctor.name]
                is_under_min = False
                
                # Vérifier minimums de posts
                for post_type, interval in doctor_intervals['posts'].items():
                    current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
                    if current < interval.get('min', 0):
                        is_under_min = True
                        break
                        
                # Vérifier minimums de groupes
                for group, interval in doctor_intervals['groups'].items():
                    current = doctor_intervals['current_counts']['groups'].get(group, 0)
                    if current < interval.get('min', 0):
                        is_under_min = True
                        break
                        
                if is_under_min:
                    doctors_under_min.append(doctor)

            # Attribution prioritaire aux médecins sous minimum
            for doctor in doctors_under_min:
                self._try_relaxed_distribution(
                    doctor, remaining_posts, dates_by_criticality,
                    quota_tracker, intervals[doctor.name], True
                )

            # Distribution du reste avec assouplissement
            other_doctors = [d for d in self.doctors if d not in doctors_under_min]
            for doctor in other_doctors:
                if self._verify_doctor_has_space(doctor, intervals[doctor.name]):
                    self._try_relaxed_distribution(
                        doctor, remaining_posts, dates_by_criticality,
                        quota_tracker, intervals[doctor.name], False
                    )

            # Comptage final
            final_unassigned = self._count_unassigned_posts(remaining_posts)
            logger.info(f"Postes restants après assouplissement: {final_unassigned}")

        except Exception as e:
            logger.error(f"Erreur distribution assouplie: {e}")
    
    def _find_best_post_for_minimum(self, doctor: Doctor,
                                available_posts: Dict,
                                doctor_intervals: Dict) -> Optional[Tuple]:
        best_score = -float('inf')
        best_post = None

        for post_type, slots in available_posts.items():
            current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
            min_required = doctor_intervals['posts'].get(post_type, {}).get('min', 0)
            max_allowed = doctor_intervals['posts'].get(post_type, {}).get('max', float('inf'))

            # Vérifier le groupe
            group = self._get_post_group(post_type, datetime.now().date())
            if group:
                group_current = doctor_intervals['current_counts']['groups'].get(group, 0)
                group_max = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                group_min = doctor_intervals['groups'].get(group, {}).get('min', 0)
                
                # Ignorer si max groupe déjà atteint
                if group_current >= group_max:
                    continue
                
                # Bonus si groupe sous minimum
                if group_current < group_min:
                    score = (min_required - current) / min_required if min_required > 0 else 0
                    score *= 1.5 # Bonus pour groupe sous minimum

            if current >= max_allowed:
                continue

            score = (min_required - current) / min_required if min_required > 0 else 0
            
            if doctor.half_parts == 2:
                score *= 1.2

            if score > best_score:
                for date, slot in slots:
                    if self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning):
                        best_score = score
                        best_post = (post_type, slot)
                        break

        return best_post
            
            
            
            

    def _assign_post_to_doctor(self, doctor: Doctor, date: date, 
                                post_type: str, slot: TimeSlot,
                                doctor_intervals: Dict, quota_tracker: QuotaTracker) -> bool:
        """
        Attribution d'un poste à un médecin avec mise à jour des compteurs.
        """
        try:
            # Vérifier les contraintes de base
            if not self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning):
                return False

            # Vérifier les limites de groupe
            group = self._get_post_group(post_type, date)
            if group:
                current_group = doctor_intervals['current_counts']['groups'].get(group, 0)
                max_allowed = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                if current_group >= max_allowed:
                    return False

            # Attribution du poste
            slot.assignee = doctor.name

            # Mise à jour des compteurs
            doctor_intervals['current_counts']['posts'][post_type] = doctor_intervals['current_counts']['posts'].get(post_type, 0) + 1
            if group:
                doctor_intervals['current_counts']['groups'][group] += 1

            # Mise à jour du quota tracker
            quota_tracker.update_assignment(doctor, post_type, date)

            logger.info(f"{doctor.name}: {post_type} attribué le {date}")
            return True

        except Exception as e:
            logger.error(f"Erreur attribution {post_type} à {doctor.name}: {e}")
            return False

    def _try_balanced_distribution(self, date: date, remaining_posts: Dict,
                                doctor_scores: Dict[str, float],
                                quota_tracker: QuotaTracker,
                                intervals: Dict) -> bool:
        """Distribution équilibrée avec vérification stricte des maximums."""
        try:
            available = self._get_available_posts_for_date(date, remaining_posts)
            if not available:
                return False

            attributed = False
            sorted_doctors = sorted(
                [(doc, doctor_scores[doc.name]) for doc in self.doctors],
                key=lambda x: x[1],
                reverse=True
            )

            for doctor, score in sorted_doctors:
                if not self._is_doctor_available_for_weekday(doctor, date):
                    continue

                for post_type, slots in available.items():
                    # Vérifier le maximum avant toute tentative
                    if not self._verify_post_limits(doctor, post_type, intervals[doctor.name]):
                        continue

                    for slot_idx, (_, slot) in enumerate(slots):
                        if not slot.assignee and self._assign_post_to_doctor(
                            doctor, date, post_type, slot,
                            intervals[doctor.name], quota_tracker
                        ):
                            # Mettre à jour les listes disponibles
                            slots.pop(slot_idx)
                            if not slots:
                                del remaining_posts[post_type]
                            attributed = True
                            break

                    if attributed:
                        break

                if attributed:
                    break

            return attributed

        except Exception as e:
            logger.error(f"Erreur distribution équilibrée: {e}")
            return False

    def _find_balanced_post(self, doctor: Doctor, available_posts: Dict,
                        doctor_intervals: Dict, quota_tracker: QuotaTracker) -> Optional[Tuple]:
        """Trouve le meilleur poste pour une distribution équilibrée."""
        best_score = -float('inf')
        best_post = None

        for post_type, slots in available_posts.items():
            # Vérifier si on peut encore attribuer ce type de poste
            if not quota_tracker.can_assign_post(doctor, post_type):
                continue

            # Vérifier le groupe
            group = self._get_post_group(post_type, datetime.now().date())
            if group:
                current_group = doctor_intervals['current_counts']['groups'].get(group, 0)
                max_allowed = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                if current_group >= max_allowed:
                    continue

            # Calculer un score pour ce type de poste
            score = self._calculate_balanced_post_score(
                doctor, post_type, doctor_intervals
            )

            if score > best_score:
                for date, slot in slots:
                    if self.constraints.can_assign_to_assignee(doctor, date, slot, self.planning):
                        best_score = score
                        best_post = (post_type, slot)
                        break

        return best_post

    def _calculate_balanced_post_score(self, doctor: Doctor, post_type: str,
                                    doctor_intervals: Dict) -> float:
        """Calcule un score pour un poste dans le contexte d'une distribution équilibrée."""
        score = 1.0

        # 1. Prise en compte de l'historique des posts
        current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
        total_posts = sum(doctor_intervals['current_counts']['posts'].values())
        if total_posts > 0:
            usage_ratio = current / total_posts
            score *= (1 - usage_ratio)  # Favoriser les types peu utilisés

        # 2. Bonus pour les pleins temps
        if doctor.half_parts == 2:
            score *= 1.2

        # 3. Prise en compte des groupes
        group = self._get_post_group(post_type, datetime.now().date())
        if group:
            group_current = doctor_intervals['current_counts']['groups'].get(group, 0)
            group_max = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
            if group_max < float('inf'):
                group_ratio = group_current / group_max
                score *= (1 - group_ratio)

        # 4. Facteur aléatoire pour éviter la monotonie
        score *= 1 + (random.random() * 0.2 - 0.1)

        return max(0.1, score)

    def _try_relaxed_distribution(self, doctor: Doctor, remaining_posts: Dict,
                            dates_by_criticality: Dict,
                            quota_tracker: QuotaTracker,
                            doctor_intervals: Dict,
                            is_under_minimum: bool) -> None:
        try:
            for criticality in ['critical', 'normal']:
                for date in dates_by_criticality[criticality]:
                    available = self._get_available_posts_for_date(date, remaining_posts)
                    if not available:
                        continue

                    # Vérifier uniquement les desiderata primaires
                    if not self._check_primary_desiderata(doctor, date):
                        continue

                    # Priorité aux postes manquants si sous minimum
                    post_types = list(available.keys())
                    if is_under_minimum:
                        post_types.sort(key=lambda post: (
                            doctor_intervals['current_counts']['posts'].get(post, 0) -
                            doctor_intervals['posts'].get(post, {}).get('min', 0)
                        ))

                    for post_type in post_types:
                        slots = available[post_type]
                        # Vérification stricte des maximums
                        current = doctor_intervals['current_counts']['posts'].get(post_type, 0)
                        max_allowed = doctor_intervals['posts'].get(post_type, {}).get('max', float('inf'))
                        if current >= max_allowed:
                            continue

                        # Vérification des maximums de groupe
                        group = self._get_post_group(post_type, date)
                        if group:
                            group_current = doctor_intervals['current_counts']['groups'].get(group, 0)
                            group_max = doctor_intervals['groups'].get(group, {}).get('max', float('inf'))
                            if group_current >= group_max:
                                continue

                        # Attribution avec vérification des contraintes de base
                        for slot_idx, (_, slot) in enumerate(slots[:]):
                            if not slot.assignee and self._assign_post_to_doctor(
                                doctor, date, post_type, slot,
                                doctor_intervals, quota_tracker
                            ):
                                slots.pop(slot_idx)
                                if not slots:
                                    del remaining_posts[post_type]
                                break

        except Exception as e:
            logger.error(f"Erreur distribution assouplie pour {doctor.name}: {e}")

    def _check_primary_desiderata(self, doctor: Doctor, date: date) -> bool:
        """Vérifie uniquement les desiderata primaires."""
        for desiderata in doctor.desiderata:
            if (desiderata.start_date <= date <= desiderata.end_date and
                (not hasattr(desiderata, 'priority') or desiderata.priority == "primary")):
                return False
        return True

# core/Constantes/data_persistence.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/data_persistence.py
import logging
import datetime
import pickle
import os
from core.Constantes.models import Doctor, CAT, DailyPostConfiguration, PostConfig, create_default_post_configuration, Desiderata, SpecificPostConfig
from core.Constantes.custom_post import CustomPost

logger = logging.getLogger(__name__)

class DataPersistence:
    def __init__(self, filename='app_data.pkl'):
        self.filename = filename
        self.custom_posts_filename = 'custom_posts.pkl'
        

    def save_data(self, doctors, cats, post_configuration):
        logger.info("Starting save_data process")
        data = {
            'version': 1,
            'doctors': [{
                'name': d.name,
                'half_parts': d.half_parts,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period,
                    'priority': getattr(des, 'priority', 'primary')  # Sauvegarde de la priorité
                } for des in d.desiderata]
            } for d in doctors],
            'cats': [{
                'name': c.name,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period,
                    'priority': getattr(des, 'priority', 'primary')  # Sauvegarde de la priorité
                } for des in c.desiderata]
            } for c in cats],
            'post_configuration': self.serialize_post_configuration(post_configuration)
        }
        
        with open(self.filename, 'wb') as file:
            pickle.dump(data, file)
        logger.info("Data saved successfully")

    def save_custom_posts(self, custom_posts_data):
        """Sauvegarde les postes personnalisés dans un fichier séparé"""
        try:
            with open(self.custom_posts_filename, 'wb') as file:
                pickle.dump(custom_posts_data, file)
            logger.info("Custom posts saved successfully")
        except Exception as e:
            logger.error(f"Error saving custom posts: {e}")

    def load_custom_posts(self):
        """Charge les postes personnalisés"""
        try:
            if os.path.exists(self.custom_posts_filename):
                with open(self.custom_posts_filename, 'rb') as file:
                    custom_posts_data = pickle.load(file)
                    # Conversion explicite en objets CustomPost
                    custom_posts = {}
                    for name, data in custom_posts_data.items():
                        try:
                            if isinstance(data, dict):
                                # Si c'est un dictionnaire, convertir en CustomPost
                                custom_posts[name] = CustomPost.from_dict(data)
                            else:
                                # Si c'est déjà un CustomPost, l'utiliser tel quel
                                custom_posts[name] = data
                            logger.info(f"Poste personnalisé chargé: {name}")
                        except Exception as e:
                            logger.error(f"Erreur lors de la conversion du poste {name}: {e}")
                            continue
                    return custom_posts
            return {}
        except Exception as e:
            logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")
            return {}

    def load_data(self):
        logger.info("Starting load_data process")
        if os.path.exists(self.filename):
            try:
                with open(self.filename, 'rb') as file:
                    data = pickle.load(file)
                
                logger.debug(f"Raw loaded data: {data}")
                data = self.migrate_data(data)
                
                # Chargement des médecins
                doctors = [Doctor(d['name'], d['half_parts'], [
                    Desiderata(
                        datetime.date.fromisoformat(des['start_date']),
                        datetime.date.fromisoformat(des['end_date']),
                        des['type'],
                        des['period'],
                        des.get('priority', 'primary')  # Ajout de la gestion de la priorité
                    )
                    for des in d.get('desiderata', [])
                ]) for d in data.get('doctors', [])]
                
                # Chargement des CATs
                cats = [CAT(
                    c['name'],
                    desiderata=[
                        Desiderata(
                            datetime.date.fromisoformat(des['start_date']),
                            datetime.date.fromisoformat(des['end_date']),
                            des['type'],
                            des['period'],
                            des.get('priority', 'primary')  # Ajout de la gestion de la priorité
                        )
                        for des in c.get('desiderata', [])
                    ]
                ) for c in data.get('cats', [])]
                
                # Chargement de la configuration des postes
                post_config_data = data.get('post_configuration', {})
                post_configuration = DailyPostConfiguration()
                
                if isinstance(post_config_data, dict):
                    post_configuration.weekday = self._deserialize_post_config(post_config_data.get('weekday', {}))
                    post_configuration.saturday = self._deserialize_post_config(post_config_data.get('saturday', {}))
                    post_configuration.sunday_holiday = self._deserialize_post_config(post_config_data.get('sunday_holiday', {}))
                    post_configuration.cat_weekday = self._deserialize_post_config(post_config_data.get('cat_weekday', {}))
                    post_configuration.cat_saturday = self._deserialize_post_config(post_config_data.get('cat_saturday', {}))
                    post_configuration.cat_sunday_holiday = self._deserialize_post_config(post_config_data.get('cat_sunday_holiday', {}))

                    # Chargement des configurations spécifiques
                    specific_configs = []
                    for config in post_config_data.get('specific_configs', []):
                        try:
                            start_date = datetime.date.fromisoformat(config['start_date'])
                            end_date = datetime.date.fromisoformat(config['end_date'])
                            
                            # Vérification et correction des dates
                            if end_date < start_date:
                                start_date, end_date = end_date, start_date
                                logger.warning(f"Dates inversées corrigées : {start_date} - {end_date}")
                            
                            specific_configs.append(
                                SpecificPostConfig(
                                    start_date=start_date,
                                    end_date=end_date,
                                    apply_to=config.get('apply_to', config.get('day_type')),
                                    post_counts=config['post_counts']
                                )
                            )
                        except ValueError as e:
                            logger.error(f"Erreur lors du chargement d'une configuration spécifique : {e}")
                            logger.error(f"Configuration ignorée : {config}")
                            continue

                    post_configuration.specific_configs = specific_configs

                logger.info("Data loaded successfully")
                return doctors, cats, post_configuration

            except Exception as e:
                logger.error(f"Erreur lors du chargement des données : {e}")
                logger.warning("Création d'une nouvelle configuration par défaut")
                return [], [], create_default_post_configuration()

        logger.warning("No data file found, returning default values")
        return [], [], create_default_post_configuration()

    def parse_date(self, date_input):
        if isinstance(date_input, datetime.date):
            return date_input
        elif isinstance(date_input, str):
            try:
                return datetime.date.fromisoformat(date_input)
            except ValueError:
                try:
                    return datetime.date.fromtimestamp(float(date_input))
                except ValueError:
                    print(f"Impossible de parser la date: {date_input}. Utilisation de la date actuelle.")
                    return datetime.date.today()
        else:
            print(f"Type de date inattendu: {type(date_input)}. Utilisation de la date actuelle.")
            return datetime.date.today()
            
    def migrate_data(self, data):
        version = data.get('version', 0)
        if version < 1:
            # Migration vers la version 1
            for doctor in data.get('doctors', []):
                for des in doctor.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            for cat in data.get('cats', []):
                for des in cat.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            data['version'] = 1
            
            # Ajout de la structure pour les postes personnalisés si elle n'existe pas
            if 'custom_posts' not in data:
                data['custom_posts'] = {}
                
        return data
    
    def serialize_post_configuration(self, post_configuration):
        """Sérialise la configuration des postes"""
        config_data = {
            'weekday': self._serialize_post_config(post_configuration.weekday),
            'saturday': self._serialize_post_config(post_configuration.saturday),
            'sunday_holiday': self._serialize_post_config(post_configuration.sunday_holiday),
            'cat_weekday': self._serialize_post_config(post_configuration.cat_weekday),
            'cat_saturday': self._serialize_post_config(post_configuration.cat_saturday),
            'cat_sunday_holiday': self._serialize_post_config(post_configuration.cat_sunday_holiday),
            'specific_configs': []
        }

        # Sérialisation des configurations spécifiques
        if hasattr(post_configuration, 'specific_configs'):
            config_data['specific_configs'] = [{
                'start_date': config.start_date.isoformat(),
                'end_date': config.end_date.isoformat(),
                'apply_to': config.apply_to,
                'post_counts': config.post_counts
            } for config in post_configuration.specific_configs]

        return config_data

    def deserialize_post_configuration(self, config_data):
        """Désérialise la configuration des postes"""
        post_configuration = DailyPostConfiguration()
        
        if isinstance(config_data, dict):
            # Configuration standard
            post_configuration.weekday = self._deserialize_post_config(config_data.get('weekday', {}))
            post_configuration.saturday = self._deserialize_post_config(config_data.get('saturday', {}))
            post_configuration.sunday_holiday = self._deserialize_post_config(config_data.get('sunday_holiday', {}))
            post_configuration.cat_weekday = self._deserialize_post_config(config_data.get('cat_weekday', {}))
            post_configuration.cat_saturday = self._deserialize_post_config(config_data.get('cat_saturday', {}))
            post_configuration.cat_sunday_holiday = self._deserialize_post_config(config_data.get('cat_sunday_holiday', {}))
            
            # Désérialisation des configurations spécifiques
            post_configuration.specific_configs = []
            for config in config_data.get('specific_configs', []):
                try:
                    specific_config = SpecificPostConfig(
                        start_date=datetime.date.fromisoformat(config['start_date']),
                        end_date=datetime.date.fromisoformat(config['end_date']),
                        apply_to=config['apply_to'],
                        post_counts=config['post_counts']
                    )
                    post_configuration.specific_configs.append(specific_config)
                except (ValueError, KeyError) as e:
                    self.logger.error(f"Erreur lors de la désérialisation d'une configuration spécifique : {e}")
                    self.logger.error(f"Configuration ignorée : {config}")
                    continue

        return post_configuration

    def _serialize_post_config(self, config):
        """Sérialise une configuration de poste simple"""
        return {post_type: post_config.total for post_type, post_config in config.items()}

    def _deserialize_post_config(self, data):
        """Désérialise une configuration de poste simple"""
        return {post_type: PostConfig(total=total) for post_type, total in data.items()}

    def debug_dates(self, doctors, cats):
        print("Debugging dates:")
        for doctor in doctors:
            for des in doctor.desiderata:
                print(f"{doctor.name}: {des}")
        for cat in cats:
            for des in cat.desiderata:
                print(f"{cat.name}: {des}")

# core/Constantes/custom_post.py

# core/Constantes/custom Custom_Post.py


from dataclasses import dataclass, field
from datetime import time
from typing import List, Set, Dict, Optional
from PyQt6.QtGui import QColor

@dataclass
class CustomPost:
    name: str
    start_time: time
    end_time: time
    day_types: Set[str]  # "weekday", "saturday", "sunday_holiday"
    assignment_type: str  # "doctors", "cats", "both"
    possible_combinations: Dict[str, str]  # {post_code: resulting_combination}
    statistic_group: Optional[str]
    color: QColor = field(default_factory=lambda: QColor("#E6F3FF"))

    def __post_init__(self):
        self.validate()

    def validate(self):
        if not 2 <= len(self.name) <= 4:
            raise ValueError("Le nom du poste doit contenir entre 2 et 4 caractères")
        
        if not self.name.replace("_", "").isalnum():
            raise ValueError("Le nom ne peut contenir que des lettres, des chiffres et des underscores")
        
        if not self.day_types:
            raise ValueError("Au moins un type de jour doit être sélectionné")
        
        if self.start_time >= self.end_time:
            raise ValueError("L'heure de début doit être antérieure à l'heure de fin")

    def overlaps_with(self, other_post) -> bool:
        """Vérifie si les horaires se chevauchent avec un autre poste"""
        return not (self.end_time < other_post.start_time or 
                   self.start_time > other_post.end_time)

    def can_combine_with(self, other_post) -> bool:
        """Vérifie si le poste peut être combiné avec un autre poste"""
        if isinstance(other_post, str):
            # Si c'est un poste standard, vérifier dans la configuration standard
            # Vous devrez implémenter cette logique selon vos besoins
            return True
        else:
            # Vérifie que les horaires ne se chevauchent pas
            return not (self.start_time < other_post.end_time and
                    self.end_time > other_post.start_time)

    def to_dict(self) -> dict:
        """Convertit le poste en dictionnaire pour la sauvegarde"""
        return {
            'name': self.name,
            'start_time': self.start_time.strftime('%H:%M'),
            'end_time': self.end_time.strftime('%H:%M'),
            'day_types': list(self.day_types),
            'assignment_type': self.assignment_type,
            'possible_combinations': self.possible_combinations,
            'statistic_group': self.statistic_group,
            'color': self.color.name()
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'CustomPost':
        """Crée un poste à partir d'un dictionnaire"""
        return cls(
            name=data['name'],
            start_time=time.fromisoformat(data['start_time']),
            end_time=time.fromisoformat(data['end_time']),
            day_types=set(data['day_types']),
            assignment_type=data['assignment_type'],
            possible_combinations=data['possible_combinations'],
            statistic_group=data['statistic_group'],
            color=QColor(data['color'])
        )

# core/Constantes/models.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/models.py
from dataclasses import dataclass, field
from datetime import date, datetime, time
from enum import Enum
from typing import List, Dict, Optional, TYPE_CHECKING, Union
import logging
import datetime

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from .models import TimeSlot

ALL_POST_TYPES = [
    "ML","MC", "MM", "CM", "HM", "RM", "SM", "CA", "HA", "RA", "SA", "CS", "HS", "RS", "SS","AL", "AC",
    "NC", "NA", "NM", "NL", "CT"
]
WEEKEND_COMBINATIONS = [
    "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA", "MLAC"
    "CMCA", "MMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS",
    "CMAC", "MMAC", "CMAL", "MMAL", "HMAL", "HMAC", "RMAL", "RMAC", "SMAL", "SMAC", 
    "MCAL", "CMRS", "CMSS", "CMHS",
    "MLCS", "MLRS", "MLSS", "MLHS", "MMCS",
    "MCCS", "MCRS", "MCSS", 'MCHS'
]

WEEKDAY_COMBINATIONS = [
    "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA", "MLAC"
    "CMCA", "MMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS",
    "CMAC", "MMAC", "CMAL", "MMAL", "HMAL", "HMAC", "RMAL", "RMAC", "SMAL", "SMAC", 
    "MCAL", "CMRS", "CMSS", "CMHS", "CMNC", "SMCS", "SMHS",
    "MLCS", "MLRS", "MLSS", "MLHS", "MMCS",
    "MCCS", "MCRS", "MCSS", 'MCHS'
]

WEEKDAY_PRIORITY_GROUPS = {
    'high_priority': [
        "MLCA", "MLHA", "MLCT", "MCCA", "MCHA",
        "MMCA", "CMCA", "CACS",
        "HMHA", "HAHS", "RMRA", "RARS", "SMSA", "SASS"
    ],
    'medium_priority': [
        "MLSA", "MLRA", "MCRA", "MCSA", "MLAC",
        "CMAC", "MMAC", "CMAL", "MMAL", "HMAL", "HMAC", 
        "RMAL", "RMAC", "SMAL", "SMAC", "MCAL", "CMCS",
        "CMHS", "CMNC", "MLCS", "MLRS", "MLSS", "MLHS", "MMCS"
    ],
    'low_priority': [
        "CMRS", "CMSS", "SMCS", "SMHS", "SMRS",
        "MCCS", "MCRS", "MCSS", "MCHS"
    ]
}

# Facteurs de priorité pour le calcul du score
PRIORITY_WEIGHTS = {
    'high_priority': 1.5,    # Bonus de 50% pour haute priorité
    'medium_priority': 1.0,  # Score normal pour priorité moyenne
    'low_priority': 0.7      # Pénalité de 30% pour basse priorité
}

ALL_COMBINATIONS = WEEKEND_COMBINATIONS + [combo for combo in WEEKDAY_COMBINATIONS if combo not in WEEKEND_COMBINATIONS]

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

class DesiderataPeriod(Enum):
    MORNING = 1
    AFTERNOON = 2
    NIGHT = 3



class Desiderata:
    def __init__(self, start_date, end_date, type: str, period: int, priority: str = "primary"):
        self.start_date = self._ensure_date(start_date)
        self.end_date = self._ensure_date(end_date)
        self.type = type
        self.period = period
        self.priority = priority  # "primary" ou "secondary"


    @staticmethod
    def _ensure_date(date_input):
        if isinstance(date_input, datetime.date):
            return date_input
        elif isinstance(date_input, str):
            try:
                return datetime.date.fromisoformat(date_input)
            except ValueError:
                try:
                    return datetime.datetime.strptime(date_input, "%Y-%m-%d").date()
                except ValueError:
                    return datetime.date.today()
        return datetime.date.today()

    def __repr__(self):
        return f"Desiderata(start_date={self.start_date}, end_date={self.end_date}, type='{self.type}', period={self.period})"

    def overlaps_with_slot(self, slot: 'TimeSlot') -> bool:
        if self.start_date <= slot.start_time.date() <= self.end_date:
            if slot.abbreviation == "CT":
                # Pour CT, vérifier si le desiderata couvre soit le matin soit l'après-midi
                return self.period in [1, 2]  # 1 pour matin, 2 pour après-midi
            else:
                slot_period = self.get_slot_period(slot)
                return self.period == slot_period
        return False

    @staticmethod
    def get_slot_period(slot: 'TimeSlot') -> int:
        if slot.abbreviation == "CT":
            return 4  # Période spéciale pour CT
        start_hour = slot.start_time.hour
        if 7 <= start_hour < 13:
            return 1  # Matin
        elif 13 <= start_hour < 18:
            return 2  # Après-midi
        else:
            return 3  # Soir/Nuit
        
@dataclass
class Doctor:
    name: str
    half_parts: int
    desiderata: List[Desiderata] = field(default_factory=list)
    
    
    # Gardes de nuit pour le weekend
    weekend_night_shifts: Dict[str, int] = field(default_factory=lambda: {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0})
    min_nlw: int = 0
    max_nlw: int = 0
    nam_shifts: Dict[str, int] = field(default_factory=lambda: {'NMs': 0, 'NMd': 0, 'NAs': 0, 'NAd': 0, 'total': 0})

    # Pour NLw
    nl_subtypes_counts: Dict[str, int] = field(default_factory=lambda: {
        'NLv': 0,  # Vendredi
        'NLs': 0,  # Samedi
        'NLd': 0   # Dimanche/Férié
    })
    
    # Pour NAMw
    nam_subtypes_counts: Dict[str, int] = field(default_factory=lambda: {
        'NA': 0,  # Nuit courte
        'NM': 0   # Nuit moyenne
    })
    
    # Gardes de nuit pour la semaine
    weekday_night_shifts: Dict[str, int] = field(default_factory=lambda: {'NL': 0, 'total': 0})
    min_nlw_weekday: int = 0
    max_nlw_weekday: int = 0
    
    # Gardes NM pour le weekend
    nam_shifts: Dict[str, int] = field(default_factory=lambda: {'NMs': 0, 'NMd': 0, 'NAs': 0, 'NAd': 0, 'total': 0})
    min_nam: int = 0
    max_nam: int = 0
    
    # Combinaisons pour le weekend
    combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS})
    min_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS})
    max_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: float('inf') for combo in WEEKEND_COMBINATIONS})
    # Ajout de l'attribut manquant pour les combinaisons weekend
    weekend_combo_counts: Dict[str, int] = field(
        default_factory=lambda: {combo: 0 for combo in WEEKEND_COMBINATIONS}
    )
    # Combinaisons pour la semaine
    weekday_combo_counts: Dict[str, int] = field(default_factory=lambda: {combo: 0 for combo in WEEKDAY_COMBINATIONS})
    min_weekday_combos: Dict[str, int] = field(default_factory=dict)
    max_weekday_combos: Dict[str, int] = field(default_factory=dict)
    
    # Groupes pour le weekend
    group_counts: Dict[str, Union[int, Dict[str, int]]] = field(default_factory=lambda: {
        "CsSD": {"CS": 0, "HS": 0, "RS": 0, "SS": 0, "total": 0},
        "VmS": 0, "VmD": 0, "VaSD": 0, "CmS": 0, "CmD": 0, "CaSD": 0, "NAMw": 0, "NLw": 0
    })
    
    # Groupes pour la semaine
    weekday_group_counts: Dict[str, int] = field(default_factory=lambda: {
    group: 0 for group in ["XM", "XA", "XS", "MM", "NM", "NC", "ML"]  # Vérifions ici
    })
    
    # Nouveaux attributs pour les postes de semaine
    weekday_post_counts: Dict[str, int] = field(default_factory=lambda: {post_type: 0 for post_type in ALL_POST_TYPES})
    min_weekday_posts: Dict[str, int] = field(default_factory=lambda: {post_type: 0 for post_type in ALL_POST_TYPES})
    max_weekday_posts: Dict[str, int] = field(default_factory=lambda: {post_type: float('inf') for post_type in ALL_POST_TYPES})
    
    cs_count: int = 0
    post_type_counts: Dict[str, int] = field(default_factory=dict)
    min_combos: Dict[str, int] = field(default_factory=dict)
    max_combos: Dict[str, int] = field(default_factory=dict)
    min_weekday_combos: Dict[str, int] = field(default_factory=dict)
    max_weekday_combos: Dict[str, int] = field(default_factory=dict)

    def __post_init__(self):
        """Initialisation post-création"""
        # S'assurer que toutes les combinaisons possibles sont initialisées
        for combo in WEEKEND_COMBINATIONS:
            if combo not in self.combo_counts:
                self.combo_counts[combo] = 0
            if combo not in self.min_combo_counts:
                self.min_combo_counts[combo] = 0
            if combo not in self.max_combo_counts:
                self.max_combo_counts[combo] = float('inf')
        
        for combo in WEEKDAY_COMBINATIONS:
            if combo not in self.weekday_combo_counts:
                self.weekday_combo_counts[combo] = 0
            if combo not in self.min_weekday_combos:
                self.min_weekday_combos[combo] = 0
            if combo not in self.max_weekday_combos:
                self.max_weekday_combos[combo] = float('inf')
            
    def can_work_shift(self, date: date, shift: 'TimeSlot') -> bool:
        if shift.abbreviation == "CT":
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.period in [1, 2]:  # Matin ou après-midi
                        return False
            return True
        else:
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.overlaps_with_slot(shift):
                        return False
            return True

    def update_shift_count(self, shift_type: str, is_weekend: bool):
        if is_weekend:
            if shift_type.startswith('NL'):
                self.weekend_night_shifts[shift_type] += 1
                self.weekend_night_shifts['total'] += 1
            elif shift_type.startswith('NM'):
                self.nm_shifts[shift_type] += 1
                self.nm_shifts['total'] += 1
        else:
            if shift_type == 'NL':
                self.weekday_night_shifts['NL'] += 1
                self.weekday_night_shifts['total'] += 1
            elif shift_type == 'NM':
                self.weekday_nm_shifts['NM'] += 1
                self.weekday_nm_shifts['total'] += 1

        self.post_type_counts[shift_type] = self.post_type_counts.get(shift_type, 0) + 1

    def update_combo_count(self, combo: str, is_weekend: bool):
        if is_weekend:
            self.combo_counts[combo] = self.combo_counts.get(combo, 0) + 1
        else:
            self.weekday_combo_counts[combo] = self.weekday_combo_counts.get(combo, 0) + 1

    def update_group_count(self, group: str, is_weekend: bool):
        if is_weekend:
            self.group_counts[group] = self.group_counts.get(group, 0) + 1
        else:
            self.weekday_group_counts[group] = self.weekday_group_counts.get(group, 0) + 1
    
@dataclass
class CAT:
    def __init__(self, name, desiderata=None):
        self.name = name
        self.posts = {}
        self.weekday_posts = {}  # Ajoutez cette ligne
        self.desiderata = desiderata if desiderata is not None else []

class SlotType(Enum):
    CONSULTATION = "Consultation"
    VISITE = "Visite"

class Site(Enum):
    CENON = "Cenon"
    BEYCHAC_ET_CAILLAU = "Beychac et Caillau"
    ST_ANDRE_DE_CUBZAC = "St André de Cubzac"
    CREON = "Créon"
    VISITES = "Visites"

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

@dataclass
class DayPlanning:
    date: date
    slots: List[TimeSlot] = field(default_factory=list)
    is_weekend: bool = False
    is_holiday_or_bridge: bool = False
    planning: Optional['Planning'] = None  # Ajout de la référence au planning parent



@dataclass
class Planning:
    def __init__(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.days: List[DayPlanning] = []
        self.pre_analysis_results = None

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def get_day(self, date: date) -> Optional[DayPlanning]:
        return next((day for day in self.days if day.date == date), None)
    

@dataclass
class CATPostConfiguration:
    weekday: Dict[str, int] = field(default_factory=dict)
    saturday: Dict[str, int] = field(default_factory=dict)
    sunday_holiday: Dict[str, int] = field(default_factory=dict)

@dataclass
class PostConfig:
    total: int = 0

@dataclass
class SpecificPostConfig:
    start_date: date
    end_date: date
    apply_to: str
    post_counts: Dict[str, int]

    # Mapping des types de jours
    DAY_TYPE_MAPPING = {
        "weekday": "Semaine",
        "Semaine": "Semaine",
        "saturday": "Samedi",
        "Samedi": "Samedi",
        "sunday_holiday": "Dimanche/Férié",
        "Dimanche/Férié": "Dimanche/Férié"
    }

    def __post_init__(self):
        """Validation et normalisation après l'initialisation"""
        # Normaliser le type de jour
        normalized_type = self.DAY_TYPE_MAPPING.get(self.apply_to)
        if normalized_type is None:
            raise ValueError(f"Type de jour invalide : {self.apply_to}")
        self.apply_to = normalized_type

        # Vérifier les dates
        if self.start_date.year < 2024:
            if 1900 <= self.start_date.year < 2000:
                self.start_date = self.start_date.replace(year=self.start_date.year + 100)

        if self.end_date.year < 2024:
            if 1900 <= self.end_date.year < 2000:
                self.end_date = self.end_date.replace(year=self.end_date.year + 100)

        # Si les dates sont inversées, les échanger
        if self.end_date < self.start_date:
            self.start_date, self.end_date = self.end_date, self.start_date
            logger.warning(f"Dates inversées automatiquement corrigées pour la période {self.start_date} - {self.end_date}")

    def to_dict(self):
        """Convertit l'objet en dictionnaire"""
        return {
            'start_date': self.start_date.isoformat(),
            'end_date': self.end_date.isoformat(),
            'apply_to': self.apply_to,
            'post_counts': self.post_counts
        }
    @classmethod
    def normalize_day_type(cls, day_type: str) -> str:
        """Normalise le type de jour"""
        normalized = cls.DAY_TYPE_MAPPING.get(day_type)
        if normalized is None:
            raise ValueError(f"Type de jour invalide : {day_type}")
        return normalized

   

    @classmethod
    def from_dict(cls, data):
        """Crée une instance à partir d'un dictionnaire"""
        return cls(
            start_date=datetime.date.fromisoformat(data['start_date']),
            end_date=datetime.date.fromisoformat(data['end_date']),
            apply_to=data['apply_to'],
            post_counts=data['post_counts']
        )

@dataclass
class DailyPostConfiguration:
    weekday: Dict[str, PostConfig] = field(default_factory=dict)
    saturday: Dict[str, PostConfig] = field(default_factory=dict)
    sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_weekday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_saturday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)
    specific_configs: List[SpecificPostConfig] = field(default_factory=list)

    def get_config_for_day_type(self, day_type: str) -> Dict[str, PostConfig]:
        if day_type == "weekday":
            return self.weekday
        elif day_type == "saturday":
            return self.saturday
        elif day_type == "sunday_holiday":
            return self.sunday_holiday
        else:
            raise ValueError(f"Invalid day type: {day_type}")

    def add_specific_config(self, specific_config: SpecificPostConfig):
        self.specific_configs.append(specific_config)
        print(f"Configuration ajoutée : {specific_config}")  # Pour le débogage

    def remove_specific_config(self, specific_config: SpecificPostConfig):
        self.specific_configs.remove(specific_config)

    def get_post_count(self, date: date, day_type: str, post_type: str) -> int:
        # Priorité à la configuration spécifique, si elle existe pour cette date et type de jour
        for config in self.specific_configs:
            if (config.start_date <= date <= config.end_date and
                config.apply_to == day_type and
                post_type in config.post_counts):
                return config.post_counts[post_type]

        # Utilisation de la configuration générale si aucune configuration spécifique n'est trouvée
        if day_type == "weekday":
            return self.weekday.get(post_type, PostConfig()).total
        elif day_type == "saturday":
            return self.saturday.get(post_type, PostConfig()).total
        elif day_type == "sunday_holiday":
            return self.sunday_holiday.get(post_type, PostConfig()).total
        else:
            raise ValueError(f"Invalid day type: {day_type}")


        
    def get_cat_post_count(self, date: date, day_type: str, post_type: str) -> int:
        # Chercher d'abord une configuration spécifique
        for config in self.specific_configs:
            if (config.start_date <= date <= config.end_date and
                config.day_type == day_type and
                config.post_type == post_type):
                return config.count

        # Si aucune configuration spécifique n'est trouvée, utiliser la configuration standard pour les CAT
        if day_type == "weekday":
            return self.cat_weekday.get(post_type, PostConfig()).total
        elif day_type == "saturday":
            return self.cat_saturday.get(post_type, PostConfig()).total
        elif day_type == "sunday_holiday":
            return self.cat_sunday_holiday.get(post_type, PostConfig()).total
        else:
            raise ValueError(f"Invalid day type: {day_type}")
        
def create_default_post_configuration():
    weekday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=0),
        "NC": PostConfig(total=1),
        "AC": PostConfig(total=0),
        "AL": PostConfig(total=0),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=0),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CT": PostConfig(total=0),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=0),
        "SA": PostConfig(total=0),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=0),
        "RA": PostConfig(total=0),
        "RS": PostConfig(total=1)      
    }

    saturday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=1),
        "NC": PostConfig(total=0),
        "AC": PostConfig(total=1),
        "AL": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=0),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=0),
        "SA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=0),
        "RA": PostConfig(total=1),
        "RS": PostConfig(total=1) 
    }

    sunday_holiday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "NA": PostConfig(total=1),
        "NC": PostConfig(total=0),
        "AC": PostConfig(total=1),
        "AL": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "MC": PostConfig(total=1),
        "MM": PostConfig(total=0),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=1),
        "SA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RM": PostConfig(total=1),
        "RA": PostConfig(total=1),
        "RS": PostConfig(total=1) 
    }

    # Configuration par défaut pour les CAT
    cat_weekday_config = {
        "NL": PostConfig(total=1),
        "NLv": PostConfig(total=1),  # Ajout de la configuration NLv
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NC": PostConfig(total=1)
    }

    cat_saturday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    cat_sunday_holiday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    return DailyPostConfiguration(
        weekday=weekday_config,
        saturday=saturday_config,
        sunday_holiday=sunday_holiday_config,
        cat_weekday=cat_weekday_config,
        cat_saturday=cat_saturday_config,
        cat_sunday_holiday=cat_sunday_holiday_config
    )



class PostManager:
    """Classe pour gérer les différents types de postes et leurs horaires en fonction du jour de la semaine."""
    
    def __init__(self):
        # Dictionnaire contenant les types de poste pour la semaine
        self.weekday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CT": {"start_time": time(10, 0), "end_time": time(15, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Créon"},
        }

        # Dictionnaire pour les postes du samedi
        self.saturday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

        # Dictionnaire pour les postes du dimanche et jours fériés
        self.sunday_holiday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

    def get_post_details(self, post_type, day_type):
        """Retourne les détails d'un poste spécifique en fonction du jour (weekday, samedi, dimanche)."""
        if day_type == "weekday":
            return self.weekday_posts.get(post_type, None)
        elif day_type == "saturday":
            return self.saturday_posts.get(post_type, None)
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts.get(post_type, None)

    def get_posts_for_day(self, day_type):
        """Retourne tous les postes disponibles pour un jour donné (semaine, samedi, ou dimanche/jour férié)."""
        if day_type == "weekday":
            return self.weekday_posts
        elif day_type == "saturday":
            return self.saturday_posts
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts


# core/Constantes/day_type.py

#core/Constantes//day_type.py

from datetime import date
from workalendar.europe import France
from typing import List
import logging

logger = logging.getLogger(__name__)

class DayType:
    @staticmethod
    def get_day_type(date: date, cal: France) -> str:
        """
        Détermine le type de jour de manière cohérente.
        Ordre de priorité : pont > férié > dimanche > samedi > semaine
        """
        if DayType.is_bridge_day(date, cal):
            logger.debug(f"{date} est un jour de pont")
            return "sunday_holiday"
        elif cal.is_holiday(date):
            logger.debug(f"{date} est un jour férié")
            return "sunday_holiday"
        elif date.weekday() == 6:  # Dimanche
            return "sunday_holiday"
        elif date.weekday() == 5:  # Samedi
            return "saturday"
        else:
            return "weekday"

    @staticmethod
    def is_bridge_day(day: date, cal: France) -> bool:
        """Détermine si une date est un jour de pont"""
        from datetime import timedelta
        
        # 1) Lundi avant un mardi férié
        if day.weekday() == 0 and cal.is_holiday(day + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if day.weekday() in [4, 5] and cal.is_holiday(day - timedelta(days=1 if day.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if day.weekday() == 5 and cal.is_holiday(day - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= day.weekday() <= 4:
            if (cal.is_holiday(day - timedelta(days=1)) and 
                cal.is_holiday(day + timedelta(days=1))):
                return True
        
        return False

# core/Constantes/QuotasTracking.py

# © 2024 HILAL Arkane. Tous droits réservés.
# core/constantes/QuotaTracking.py

from typing import Dict, List, Optional, Union, Tuple
from datetime import date, time
from collections import defaultdict
from core.Constantes.data_persistence import DataPersistence
import logging
from .models import Doctor, CAT, Planning, TimeSlot
from .day_type import DayType
from workalendar.europe import France

logger = logging.getLogger(__name__)

class QuotaCounter:
    """Composant pour le suivi des compteurs de quotas par personne."""
    def __init__(self, person_name: str):
        self.person_name = person_name
        self.posts = defaultdict(int)      # Compteurs par type de poste
        self.groups = defaultdict(int)     # Compteurs par groupe
        self.combinations = defaultdict(int)  # Compteurs par combinaison

    def increment_post(self, post_type: str):
        """Incrémente le compteur d'un type de poste."""
        self.posts[post_type] += 1
        
    def increment_group(self, group: str):
        """Incrémente le compteur d'un groupe."""
        if group:
            self.groups[group] += 1
            
    def increment_combination(self, combo: str):
        """Incrémente le compteur d'une combinaison."""
        self.combinations[combo] += 1

    def get_post_count(self, post_type: str) -> int:
        """Retourne le nombre d'utilisations d'un type de poste."""
        return self.posts.get(post_type, 0)
        
    def get_group_count(self, group: str) -> int:
        """Retourne le nombre d'utilisations d'un groupe."""
        return self.groups.get(group, 0)
        
    def get_combination_count(self, combo: str) -> int:
        """Retourne le nombre d'utilisations d'une combinaison."""
        return self.combinations.get(combo, 0)

class QuotaTracker:
    """
    Gestionnaire principal pour le suivi des quotas.
    Maintient l'état des compteurs et vérifie les limites pour tous les types de distribution.
    """
    def __init__(self, planning: Planning, persons: List[Union[Doctor, CAT]], day_type: str):
        """
        Initialise le gestionnaire de quotas.
        
        Args:
            planning: Planning en cours
            persons: Liste des médecins ou CAT
            day_type: Type de jour ('weekday', 'saturday', 'sunday_holiday')
        """
        self.planning = planning
        self.persons = persons
        self.day_type = day_type
        self.cal = France()
        
        # Détecter le type de personnes (CAT ou médecins)
        self.person_type = 'cats' if hasattr(persons[0], 'posts') else 'doctors'
        
        # Initialiser les quotas depuis la pré-analyse
        self.pre_analysis = planning.pre_analysis_results
        if self.person_type == 'cats':
            self.quotas = self.pre_analysis["cat_posts"][day_type]
        else:
            self.quotas = self.pre_analysis["adjusted_posts"][day_type]
            
        # Initialiser les compteurs pour chaque personne
        self.counters = {
            person.name: QuotaCounter(person.name)
            for person in persons
        }
        
        # Charger l'état actuel du planning
        self._load_current_state()
        
    def _load_current_state(self):
        """Charge l'état actuel des compteurs depuis le planning."""
        for day in self.planning.days:
            # Vérifier si le jour correspond au type demandé
            if not self._is_matching_day_type(day.date):
                continue
                
            # Parcourir les slots de la journée
            for slot in day.slots:
                if any(person.name == slot.assignee for person in self.persons):
                    counter = self.counters[slot.assignee]
                    
                    # Incrémenter les compteurs appropriés
                    counter.increment_post(slot.abbreviation)
                    
                    group = self._get_post_group(slot.abbreviation, day.date)
                    if group:
                        counter.increment_group(group)

    def _is_matching_day_type(self, check_date: date) -> bool:
        """Vérifie si une date correspond au type de jour géré."""
        day_type = DayType.get_day_type(check_date, self.cal)
        
        if self.day_type == 'weekday':
            return day_type == 'weekday'
        elif self.day_type == 'saturday':
            return day_type == 'saturday'
        else:  # sunday_holiday
            return day_type == 'sunday_holiday'

    def can_assign_post(self, person: Union[Doctor, CAT], post_type: str) -> bool:
        """Vérifie si un poste peut être attribué sans dépasser le quota."""
        counter = self.counters[person.name]
        current = counter.get_post_count(post_type)
        quota = self.quotas.get(post_type, 0)
        
        if current >= quota:
            logger.debug(f"{person.name}: Quota atteint pour {post_type} "
                      f"({current}/{quota})")
            return False
        return True

    def can_assign_combination(self, person: Union[Doctor, CAT], combo: str, date: date) -> bool:
        """
        Vérifie si une combinaison peut être attribuée en respectant tous les quotas.
        
        Args:
            person: Médecin ou CAT à vérifier
            combo: Code de la combinaison
            date: Date de l'attribution
            
        Returns:
            bool: True si l'attribution est possible, False sinon
        """
        try:
            # Extraire les postes de la combinaison
            first_post, second_post = self._get_posts_from_combo(combo)
            
            # Vérifier les quotas de poste
            if not (self.can_assign_post(person, first_post) and 
                   self.can_assign_post(person, second_post)):
                logger.debug(f"{person.name}: Quota dépassé pour {first_post} ou {second_post}")
                return False
            
            # Pour les médecins, vérifier aussi les groupes
            if self.person_type == 'doctors':
                first_group = self._get_post_group(first_post, date)
                second_group = self._get_post_group(second_post, date)
                
                if not (self._check_group_limit(person, first_group) and
                       self._check_group_limit(person, second_group)):
                    logger.debug(f"{person.name}: Limite de groupe atteinte")
                    return False
            
            return True
            
        except ValueError as e:
            # Combinaison invalide
            logger.warning(f"Combinaison invalide pour {person.name}: {e}")
            return False
        except Exception as e:
            # Autre erreur inattendue
            logger.error(f"Erreur vérification combinaison pour {person.name}: {e}")
            return False

    def update_assignment(self, person: Union[Doctor, CAT], post_type: str, 
                         date: date, combo: Optional[str] = None):
        """Met à jour les compteurs après une attribution."""
        counter = self.counters[person.name]
        
        # Incrémenter le compteur de poste
        counter.increment_post(post_type)
        
        # Incrémenter le compteur de groupe si applicable
        group = self._get_post_group(post_type, date)
        if group:
            counter.increment_group(group)
            
        # Incrémenter le compteur de combinaison si fournie
        if combo:
            counter.increment_combination(combo)

    def get_remaining_quotas(self, person: Union[Doctor, CAT]) -> Dict:
        """Retourne les quotas restants pour une personne."""
        result = {
            'posts': {},
            'groups': {},
            'combinations': {}
        }
        
        counter = self.counters[person.name]
        
        # Quotas de postes
        for post_type, quota in self.quotas.items():
            current = counter.get_post_count(post_type)
            result['posts'][post_type] = max(0, quota - current)
            
        # Pour les médecins, ajouter les groupes
        if self.person_type == 'doctors':
            group_limits = (self.pre_analysis.get('ideal_distribution', {})
                          .get(person.name, {})
                          .get('groups', {}))
            
            for group, limits in group_limits.items():
                current = counter.get_group_count(group)
                max_allowed = limits.get('max', float('inf'))
                if max_allowed < float('inf'):
                    result['groups'][group] = max(0, max_allowed - current)
        
        return result

    def _get_posts_from_combo(self, combo: str) -> Tuple[str, str]:
        """
        Extrait les deux postes d'une combinaison.
        Gère à la fois les combinaisons personnalisées et standards.
        
        Args:
            combo: Code de la combinaison à analyser
            
        Returns:
            Tuple[str, str]: Les deux codes de poste qui composent la combinaison
            
        Raises:
            ValueError: Si la combinaison n'est pas valide ou reconnue
        """
        # 1. Vérifier les combinaisons de postes personnalisés
        data_persistence = DataPersistence()
        custom_posts = data_persistence.load_custom_posts()
        
        for custom_post in custom_posts.values():
            if combo in custom_post.possible_combinations.values():
                for post, combo_name in custom_post.possible_combinations.items():
                    if combo_name == combo:
                        return custom_post.name, post

        # 2. Si ce n'est pas une combinaison personnalisée, extraire les postes standards
        if len(combo) >= 4:  # Une combinaison standard fait 4 caractères (ex: MLCA)
            return combo[:2], combo[2:]
            
        # 3. Si on arrive ici, la combinaison n'est pas valide
        raise ValueError(f"Combinaison invalide: {combo}")

    def _get_post_group(self, post_type: str, date: date) -> Optional[str]:
        """Détermine le groupe d'un poste selon le type de jour."""
        # Accès aux postes personnalisés via DataPersistence
        data_persistence = DataPersistence()
        custom_posts = data_persistence.load_custom_posts()
        
        if post_type in custom_posts:
            return custom_posts[post_type].statistic_group

    def _get_weekday_group(self, post_type: str) -> Optional[str]:
        """Retourne le groupe de semaine d'un poste."""
        weekday_groups = {
            "XM": ["CM", "HM", "SM", "RM"],
            "XmM": ["MM"],
            "XA": ["CA", "HA", "SA", "RA"],
            "XS": ["CS", "HS", "SS", "RS"],
            "Vm": ["ML"],
            "Va": ["AL", "AC"],
            "NMC": ["NM", "NC", "NA"]
        }
        
        for group, posts in weekday_groups.items():
            if post_type in posts:
                return group
        return None

    def _get_weekend_group(self, post_type: str, date: date) -> Optional[str]:
        """Retourne le groupe de weekend d'un poste."""
        is_saturday = self.day_type == 'saturday'
        
        weekend_groups = {
            "CmS" if is_saturday else "CmD": ["MM", "CM", "HM", "SM", "RM"],
            "CaSD": ["CA", "HA", "SA", "RA"],
            "CsSD": ["CS", "HS", "SS", "RS"],
            "VmS" if is_saturday else "VmD": ["ML", "MC"],
            "VaSD": ["AL", "AC"],
            "NAMw": ["NM", "NA"],
            "NLw": ["NL"]
        }
        
        for group, posts in weekend_groups.items():
            if post_type in posts:
                return group
        return None

    def _check_group_limit(self, person: Union[Doctor, CAT], group: str) -> bool:
        """Vérifie les limites de groupe pour les médecins."""
        if not group or self.person_type == 'cats':
            return True
            
        # Récupérer la limite depuis la distribution idéale
        group_limits = (self.pre_analysis.get('ideal_distribution', {})
                      .get(person.name, {})
                      .get('groups', {})
                      .get(group, {}))
                      
        max_allowed = group_limits.get('max', float('inf'))
        current = self.counters[person.name].get_group_count(group)
        
        return current < max_allowed

    def log_status(self):
        """Affiche l'état détaillé des quotas et compteurs."""
        logger.info(f"\nÉTAT DES QUOTAS ({self.person_type.upper()}):")
        
        for person in self.persons:
            logger.info(f"\n{person.name}:")
            counter = self.counters[person.name]
            
            # Postes
            logger.info("Postes:")
            for post_type, quota in self.quotas.items():
                current = counter.get_post_count(post_type)
                status = "OK" if current <= quota else "DÉPASSÉ"
                logger.info(f"  {post_type}: {current}/{quota} ({status})")
            
            # Groupes (médecins seulement)
            if self.person_type == 'doctors':
                group_limits = (self.pre_analysis.get('ideal_distribution', {})
                              .get(person.name, {})
                              .get('groups', {}))
                
                if group_limits:
                    logger.info("\nGroupes:")
                    for group, limits in group_limits.items():
                        current = counter.get_group_count(group)
                        max_allowed = limits.get('max', float('inf'))
                        if max_allowed < float('inf'):
                            status = "OK" if current <= max_allowed else "DÉPASSÉ"
                            logger.info(f"  {group}: {current}/{max_allowed} ({status})")

# core/Constantes/constraints.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/Constantes/Constaints.py
from datetime import datetime, timedelta, date,time
from typing import Union
from core.Constantes.models import Doctor, CAT, TimeSlot, DayPlanning, Planning

class PlanningConstraints:
    def __init__(self):
        pass

    def can_assign_to_assignee(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, 
                                planning: Planning, respect_secondary: bool = True) -> bool:
        """
        Vérifie si une assignation est possible en respectant toutes les contraintes.
        
        Args:
            assignee: Médecin ou CAT à vérifier
            date: Date du slot
            slot: Slot à vérifier
            planning: Planning en cours
            respect_secondary: Si False, ignore les desideratas secondaires
            
        Returns:
            bool: True si l'attribution est possible
        """
        return all([
            self.check_nl_constraint(assignee, date, slot, planning),
            self.check_nm_constraint(assignee, date, slot, planning),
            self.check_nm_na_constraint(assignee, date, slot, planning),
            self.check_time_overlap(assignee, date, slot, planning),
            self.check_max_posts_per_day(assignee, date, slot, planning),
            self.check_desiderata_constraint(assignee, date, slot, planning),
            self.check_no_morning_consult_after_late(assignee, date, slot, planning),  # Nouvelle contrainte
            self.check_consecutive_night_shifts(assignee, date, slot, planning),
            self.check_consecutive_working_days(assignee, date, slot, planning)
        ])


    def check_nl_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        # Vérifier si l'assigné a un NL le jour même ou la veille
        today = planning.get_day(date)
        yesterday = planning.get_day(date - timedelta(days=1))
        tomorrow = planning.get_day(date + timedelta(days=1))

        if today:
            if any(s.assignee == assignee.name and s.abbreviation == "NL" for s in today.slots):
                return False
        if yesterday:
            if any(s.assignee == assignee.name and s.abbreviation == "NL" for s in yesterday.slots):
                return False
        if tomorrow and slot.abbreviation == "NL":
            if any(s.assignee == assignee.name for s in tomorrow.slots):
                return False
        return True
    
    def check_nm_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        today = planning.get_day(date)
        tomorrow = planning.get_day(date + timedelta(days=1))
        
        if today:
            for other_slot in today.slots:
                if other_slot.assignee == assignee.name:
                    if (slot.abbreviation == 'NM' or other_slot.abbreviation == 'NM') and \
                    (slot.start_time < other_slot.end_time and slot.end_time > other_slot.start_time):
                        return False
        
        if tomorrow and slot.abbreviation == 'NM':
            for other_slot in tomorrow.slots:
                if other_slot.assignee == assignee.name:
                    if slot.end_time > other_slot.start_time:
                        return False
        
        return True
    
    def check_nm_na_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            # Si le nouveau poste est NM, vérifier qu'aucun autre poste n'est assigné ce jour-là
            if slot.abbreviation == 'NM':
                return not any(s.assignee == assignee.name for s in day.slots)
            
            # Si un NM est déjà assigné ce jour-là, aucun autre poste ne peut être ajouté
            if any(s.abbreviation == 'NM' and s.assignee == assignee.name for s in day.slots):
                return False
        
        return True

    def check_no_morning_consult_after_nm(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        yesterday = planning.get_day(date - timedelta(days=1))
        tomorrow = planning.get_day(date + timedelta(days=1))
        morning_consults = ['ML', 'MC', 'MM', 'CM', 'HM', 'SM', 'RM']

        # Vérifier si un NM était attribué la veille
        if yesterday and any(s.assignee == assignee.name and s.abbreviation == 'NM' for s in yesterday.slots):
            if slot.abbreviation in morning_consults:
                return False

        # Si on attribue un NM, vérifier qu'il n'y a pas de poste du matin le lendemain
        if slot.abbreviation == 'NM' and tomorrow:
            if any(s.assignee == assignee.name and s.abbreviation in morning_consults for s in tomorrow.slots):
                return False

        return True
    
    def check_consecutive_night_shifts(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        """
        Vérifie si l'attribution d'un poste de soir ou de nuit respecte la limite de 4 jours consécutifs.
        
        Args:
            assignee: Le médecin ou CAT à qui on veut attribuer le poste
            date: La date du poste
            slot: Le poste à attribuer
            planning: Le planning en cours
            
        Returns:
            bool: True si l'attribution est possible, False sinon
        """
        # Liste des postes considérés comme soir ou nuit
        evening_night_posts = ['CS', 'HS', 'RS', 'SS', 'NC', 'NM', 'NL', 'NA']
        
        # Vérifier si le poste actuel est un poste de soir ou nuit
        if slot.abbreviation in evening_night_posts:
            count = 0
            # Vérifier les 4 jours précédents
            for i in range(1, 5):
                prev_day = planning.get_day(date - timedelta(days=i))
                if prev_day:
                    # Vérifier si le médecin avait un poste de soir/nuit
                    has_evening_night = any(
                        s.assignee == assignee.name and s.abbreviation in evening_night_posts 
                        for s in prev_day.slots
                    )
                    if has_evening_night:
                        count += 1
                    else:
                        break  # On s'arrête dès qu'on trouve un jour sans poste soir/nuit
                        
            # Si on a déjà 4 jours consécutifs, on refuse le nouveau poste
            return count < 4
            
        return True  # On autorise si ce n'est pas un poste de soir/nuit

    def check_consecutive_working_days(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        count = 0
        for i in range(6):  # Vérifier les 6 jours précédents
            prev_day = planning.get_day(date - timedelta(days=i))
            if prev_day:
                if any(s.assignee == assignee.name for s in prev_day.slots):
                    count += 1
                else:
                    break
        return count < 6

    def check_time_overlap(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            for existing_slot in day.slots:
                if existing_slot.assignee == assignee.name:
                    # Traitement spécial pour CT 
                    if slot.abbreviation == "CT" or existing_slot.abbreviation == "CT":
                        # Utilisation des horaires exacts de CT (10h-15h59)
                        start_time = time(10, 0) if slot.abbreviation == "CT" else slot.start_time
                        end_time = time(15, 59) if slot.abbreviation == "CT" else slot.end_time
                        existing_start = time(10, 0) if existing_slot.abbreviation == "CT" else existing_slot.start_time
                        existing_end = time(15, 59) if existing_slot.abbreviation == "CT" else existing_slot.end_time
                        
                        if (start_time < existing_end and end_time > existing_start):
                            return False
                    else:
                        if (slot.start_time < existing_slot.end_time and 
                            slot.end_time > existing_slot.start_time):
                            return False
        return True

    def check_max_posts_per_day(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            assigned_posts = sum(1 for s in day.slots if s.assignee == assignee.name)
            # On vérifie si le nombre de postes déjà assignés plus le nouveau poste dépasse 2
            return assigned_posts + 1 <= 2
        return True

    def check_desiderata_constraint(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, 
                                    planning: Planning, respect_secondary: bool = True) -> bool:
        """
        Vérifie les contraintes de desiderata.
        Args:
            assignee: Médecin ou CAT à vérifier
            date: Date du slot
            slot: Slot à vérifier
            planning: Planning en cours
            respect_secondary: Si False, ignore les desideratas secondaires
        Returns:
            bool: True si l'attribution est possible
        """
        # Vérification des desideratas primaires (toujours stricts)
        for desiderata in assignee.desiderata:
            if not hasattr(desiderata, 'priority'):  # Rétrocompatibilité
                priority = "primary"
            else:
                priority = desiderata.priority

            if priority == "primary":
                if (desiderata.start_date <= date <= desiderata.end_date and 
                    desiderata.overlaps_with_slot(slot)):
                    return False

        # Si respect_secondary est False, on ignore les desideratas secondaires
        if not respect_secondary:
            return True

        # Vérification des desideratas secondaires
        for desiderata in assignee.desiderata:
            if (getattr(desiderata, 'priority', 'primary') == "secondary" and
                desiderata.start_date <= date <= desiderata.end_date and 
                desiderata.overlaps_with_slot(slot)):
                return False

        return True
    
    def check_no_morning_consult_after_late(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        """
        Vérifie la compatibilité entre postes tardifs et postes tôt le matin.
        Empêche :
        - L'attribution d'un ML/MM après un poste tardif
        - L'attribution d'un poste tardif avant un ML/MM
        
        Args:
            assignee: Le médecin ou CAT à qui on veut attribuer le poste
            date: La date du poste
            slot: Le poste à attribuer
            planning: Le planning en cours
            
        Returns:
            bool: True si l'attribution est possible, False sinon
        """
        # Définition des types de postes
        early_morning_posts = ['ML', 'MM']
        late_posts = ['SS', 'RS','HS','NC', 'NM', 'NL']

        # CAS 1: On veut attribuer un poste tôt le matin
        if slot.abbreviation in early_morning_posts:
            # Vérifier la veille
            yesterday = planning.get_day(date - timedelta(days=1))
            if yesterday:
                for prev_slot in yesterday.slots:
                    # Vérifier si le médecin avait un poste tardif la veille
                    if (prev_slot.assignee == assignee.name and 
                        (prev_slot.abbreviation in late_posts or 
                        prev_slot.end_time.time().hour >= 23)):
                        return False

        # CAS 2: On veut attribuer un poste tardif
        elif slot.abbreviation in late_posts or slot.end_time.time().hour >= 23:
            # Vérifier le lendemain
            tomorrow = planning.get_day(date + timedelta(days=1))
            if tomorrow:
                # Vérifier si le médecin a déjà un ML ou MM le lendemain
                for next_slot in tomorrow.slots:
                    if (next_slot.assignee == assignee.name and 
                        next_slot.abbreviation in early_morning_posts):
                        return False

        # Si aucune contrainte n'est violée, on autorise
        return True

# core/Analyzer/pre_analyzer.py

# core/Analyzer/pre_analyzer.py

# © 2024 HILAL Arkane. Tous droits réservés.
# # core/pre_analyzer.py

from datetime import date, timedelta, time
from typing import List, Dict, Tuple
from core.Constantes.models import Doctor, CAT, DailyPostConfiguration, Desiderata, PostManager, WEEKEND_COMBINATIONS, WEEKDAY_COMBINATIONS, ALL_COMBINATIONS, ALL_POST_TYPES, PostConfig
from workalendar.europe import France
from core.Constantes.custom_post import CustomPost
from core.Constantes.day_type import DayType
from core.Analyzer.combinations_analyzer import CombinationsAnalyzer
from core.Analyzer.availability_matrix import AvailabilityMatrix


import logging
import math
from core.Constantes.data_persistence import DataPersistence
logger = logging.getLogger(__name__)

class PlanningPreAnalyzer:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration: DailyPostConfiguration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.start_date = None
        self.end_date = None 
        self.total_days = 0
        self.cal = France()
        self.logger = logging.getLogger(__name__)
        self.post_manager = PostManager()
        self.custom_posts = self.load_custom_posts()
        self.clean_invalid_custom_posts()
        self.combinations_cache = {"weekday": {}, "weekend": {}}
        # Nouveau : calculer le total des demi-parts
        self.total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        self.full_time_doctors = len([d for d in self.doctors if d.half_parts == 2])
        self.half_time_doctors = len([d for d in self.doctors if d.half_parts == 1])
        self.availability_matrix = None  # Ajout de l'attribut

    
    def clean_invalid_custom_posts(self):
        """Nettoie les postes personnalisés invalides"""
        if not self.custom_posts:
            return

        self.logger.info("Nettoyage des postes personnalisés")
        invalid_posts = []
        valid_config = set()

        # Collecter tous les postes valides depuis la configuration
        for config in [
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday,
            self.post_configuration.cat_weekday,
            self.post_configuration.cat_saturday,
            self.post_configuration.cat_sunday_holiday
        ]:
            valid_config.update(config.keys())

        # Ajouter les postes standard
        valid_config.update(ALL_POST_TYPES)

        # Identifier les postes invalides
        for name in self.custom_posts.keys():
            if name not in valid_config:
                invalid_posts.append(name)
                self.logger.debug(f"Poste personnalisé invalide trouvé: {name}")

        # Supprimer les postes invalides
        for name in invalid_posts:
            del self.custom_posts[name]
            self.logger.info(f"Suppression du poste personnalisé invalide: {name}")

        # Sauvegarder les modifications
        data_persistence = DataPersistence()
        custom_posts_data = {
            name: post.to_dict() 
            for name, post in self.custom_posts.items()
        }
        data_persistence.save_custom_posts(custom_posts_data)
        self.logger.info(f"Postes personnalisés nettoyés. {len(invalid_posts)} postes supprimés")

    def load_custom_posts(self):
        """Charge la configuration des postes personnalisés"""
        data_persistence = DataPersistence()
        custom_posts_data = data_persistence.load_custom_posts()
        
        # Convertir les données en objets CustomPost si ce n'est pas déjà fait
        if custom_posts_data and isinstance(next(iter(custom_posts_data.values())), dict):
            from core.Constantes.custom_post import CustomPost
            return {
                name: CustomPost.from_dict(data) 
                for name, data in custom_posts_data.items()
            }
        return custom_posts_data
    
    def calculate_total_days(self):
        if self.start_date and self.end_date:
            return (self.end_date - self.start_date).days + 1
        return 0

    def set_date_range(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.total_days = self.calculate_total_days()
        # Initialiser la matrice de disponibilités
        self.availability_matrix = AvailabilityMatrix(
            start_date=self.start_date,
            end_date=self.end_date,
            doctors=self.doctors,
            cats=self.cats
        )

    def analyze(self) -> Dict:
        if not self.start_date or not self.end_date or self.start_date > self.end_date:
            raise ValueError("Invalid date range. Please set valid start and end dates.")

        self.logger.info("=" * 100)
        self.logger.info(f"ANALYSE DU PLANNING: {self.start_date.strftime('%d/%m/%Y')} - {self.end_date.strftime('%d/%m/%Y')}")
        self.logger.info("=" * 100)

        # 1. Distribution des jours
        self._log_days_distribution()
        
        # 2. Vérification des configurations spécifiques
        config_errors = self.validate_specific_configs()
        if config_errors:
            self.logger.warning("\nAttention : Des configurations spécifiques se chevauchent !")
            for error in config_errors:
                self.logger.warning(error)

        # 3. Calcul du total des postes
        self.logger.info("\nÉTAPE 1: Calcul du nombre total de postes")
        total_posts = self.analyze_posts()
        self._log_total_posts_distribution(total_posts)

        # 4. Analyse des postes CAT
        self.logger.info("\nÉTAPE 2: Analyse des postes réservés aux CAT")
        cat_posts = self.analyze_cat_posts()
        self._log_cat_posts_distribution(cat_posts)

        # 5. Ajustement des postes après soustraction CAT
        self.logger.info("\nÉTAPE 3: Ajustement des postes pour les médecins")
        adjusted_posts = self.adjust_posts_for_cats(total_posts, cat_posts)
        self._log_adjusted_posts_distribution(adjusted_posts)

        # 6. Analyse du personnel et calcul de la distribution idéale
        personnel_analysis = self.analyze_personnel()
        ideal_distribution = self.analyze_ideal_distribution(adjusted_posts)
        self._log_ideal_distribution(adjusted_posts)

        # 7. Analyse des indisponibilités
        unavailability = self.analyze_unavailability()

        # 8. Distribution des jours
        days_distribution = self._collect_days_distribution()
        
        self._log_analysis_summary(total_posts, cat_posts, adjusted_posts)


        # 9. Analyse des combinaisons - après avoir calculé ideal_distribution
        self.logger.info("\nÉTAPE 4: ANALYSE DES COMBINAISONS")
        combinations_analyzer = CombinationsAnalyzer(
            self.doctors,
            self.cats,
            self.availability_matrix,
            {
                "ideal_distribution": ideal_distribution,
                "weekend_posts": adjusted_posts["saturday"],
                "weekday_posts": adjusted_posts["weekday"],
                "weekend_groups": adjusted_posts["weekend_groups"],
                "weekday_groups": adjusted_posts["weekday_groups"]
            }
        )
        combinations_analysis = combinations_analyzer.analyze()

        return {
            "personnel": personnel_analysis,
            "total_posts": total_posts,
            "cat_posts": cat_posts,
            "adjusted_posts": adjusted_posts,
            "ideal_distribution": ideal_distribution,
            "unavailability": unavailability,
            "days_distribution": days_distribution,
            "combinations_analysis": combinations_analysis
        }

    def _collect_days_distribution(self) -> Dict:
        """Collecte les informations sur la distribution des jours."""
        distribution = {
            'weekdays': [],
            'saturdays': [],
            'sundays': [],
            'holidays': [],
            'bridges': [],
            'specific_dates': {}
        }

        current_date = self.start_date
        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date, self.cal)
            
            if day_type == "sunday_holiday":
                if current_date.weekday() == 6:
                    distribution['sundays'].append(current_date)
                elif self.cal.is_holiday(current_date):
                    distribution['holidays'].append(current_date)
                else:  # C'est un pont
                    distribution['bridges'].append(current_date)
            elif day_type == "saturday":
                distribution['saturdays'].append(current_date)
            else:
                distribution['weekdays'].append(current_date)

            # Ajouter les configurations spécifiques
            if hasattr(self.post_configuration, 'specific_configs'):
                for config in self.post_configuration.specific_configs:
                    if config.start_date <= current_date <= config.end_date:
                        if current_date not in distribution['specific_dates']:
                            distribution['specific_dates'][current_date] = []
                        distribution['specific_dates'][current_date].append({
                            'apply_to': config.apply_to,
                            'post_counts': config.post_counts
                        })

            current_date += timedelta(days=1)

        return distribution
    
    def validate_specific_configs(self) -> List[str]:
        """Vérifie la cohérence des configurations spécifiques"""
        errors = []
        
        # Définir le mapping de normalisation des types de jours
        day_type_mapping = {
            "weekday": "Semaine",
            "Semaine": "Semaine",
            "saturday": "Samedi",
            "Samedi": "Samedi",
            "sunday_holiday": "Dimanche/Férié",
            "Dimanche/Férié": "Dimanche/Férié"
        }
        
        grouped_configs = {
            "Semaine": [],
            "Samedi": [],
            "Dimanche/Férié": []
        }

        # Grouper les configurations par type de jour avec normalisation
        for config in self.post_configuration.specific_configs:
            normalized_type = day_type_mapping.get(config.apply_to)
            if normalized_type is None:
                errors.append(f"Type de jour invalide détecté : {config.apply_to}")
                continue
            grouped_configs[normalized_type].append(config)

        # Vérifier les chevauchements dans chaque groupe
        for day_type, configs in grouped_configs.items():
            sorted_configs = sorted(configs, key=lambda x: x.start_date)
            for i in range(len(sorted_configs) - 1):
                current = sorted_configs[i]
                next_config = sorted_configs[i + 1]
                if current.end_date >= next_config.start_date:
                    errors.append(
                        f"Chevauchement détecté pour {day_type} entre : \n"
                        f"  - {current.start_date.strftime('%d/%m/%Y')} → {current.end_date.strftime('%d/%m/%Y')}\n"
                        f"  - {next_config.start_date.strftime('%d/%m/%Y')} → {next_config.end_date.strftime('%d/%m/%Y')}"
                    )

        # Log des erreurs si présentes
        if errors:
            self.logger.error("\nERREURS DE CONFIGURATION SPÉCIFIQUE:")
            for error in errors:
                self.logger.error(error)

        return errors
    def calculate_total_posts(self) -> Dict:
        """Calculate the total number of posts for the entire period based on the configuration."""
        self.logger.info("Calculating total posts to distribute.")
        total_posts = {"weekday": {}, "saturday": {}, "sunday_holiday": {}}
        current_date = self.start_date

        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date)
            config = self.post_configuration.get_config_for_day_type(day_type)

            for post_type, post_config in config.items():
                if post_type not in total_posts[day_type]:
                    total_posts[day_type][post_type] = 0
                total_posts[day_type][post_type] += post_config.total

            current_date += timedelta(days=1)

        self.logger.info(f"Total posts calculated: {total_posts}")
        return total_posts
    
    def analyze_cat_posts(self) -> Dict:
        """Calculate the total number of posts reserved for CATs."""
        self.logger.info("Analyzing CAT posts.")
        cat_posts = {"weekday": {}, "saturday": {}, "sunday_holiday": {}}

        for day_type in ["weekday", "saturday", "sunday_holiday"]:
            config = getattr(self.post_configuration, f"cat_{day_type}")
            for post_type, post_config in config.items():
                if post_type not in cat_posts[day_type]:
                    cat_posts[day_type][post_type] = 0
                cat_posts[day_type][post_type] += post_config.total

        self.logger.info(f"CAT posts calculated: {cat_posts}")
        return cat_posts

    

    def analyze_reserved_posts_distribution(self, cat_posts: Dict) -> Dict:
        """Analyse la distribution optimale des postes réservés"""
        total_days = (self.end_date - self.start_date).days + 1
        
        # Calculer le nombre total de postes réservés
        total_reserved = sum(sum(posts.values()) for posts in cat_posts.values())
        
        # Calculer l'espacement optimal
        optimal_spacing = max(1, total_days // total_reserved) if total_reserved > 0 else 1
        
        
        
        return {
            "total_reserved": total_reserved,
            "optimal_spacing": optimal_spacing,
           
        }

    



    def analyze_personnel(self) -> Dict:
        total_doctors = len(self.doctors)
        doctors_one_half_part = sum(1 for doctor in self.doctors if doctor.half_parts == 1)
        doctors_two_half_parts = sum(1 for doctor in self.doctors if doctor.half_parts == 2)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        total_cats = len(self.cats)

        self.logger.info("EFFECTIFS:")
        self.logger.info(f"Médecins plein temps: {doctors_two_half_parts:2d}")
        self.logger.info(f"Médecins mi-temps  : {doctors_one_half_part:2d}")
        self.logger.info(f"Total parts        : {total_half_parts:2d}")
        self.logger.info("=" * 100)

        return {
            "total_doctors": total_doctors,
            "doctors_one_half_part": doctors_one_half_part,
            "doctors_two_half_parts": doctors_two_half_parts,
            "total_half_parts": total_half_parts,
            "total_cats": total_cats
        }
 
    def analyze_posts(self) -> Dict:
        """Analyse complète des postes sur la période donnée"""
        self.logger.info("\n" + "="*100)
        self.logger.info(f"ANALYSE DES POSTES: {self.start_date.strftime('%d/%m/%Y')} - {self.end_date.strftime('%d/%m/%Y')}")
        self.logger.info("="*100)

        # Initialisation des compteurs
        all_possible_posts = set(ALL_POST_TYPES)
        if hasattr(self, 'custom_posts'):
            all_possible_posts.update(self.custom_posts.keys())
            self.logger.debug(f"Postes personnalisés ajoutés à l'analyse: {[p for p in self.custom_posts.keys()]}")
        
        posts_analysis = {
            "weekday": {post_type: 0 for post_type in all_possible_posts},
            "saturday": {post_type: 0 for post_type in all_possible_posts},
            "sunday_holiday": {post_type: 0 for post_type in all_possible_posts},
            "weekend_groups": {
                "CmS": 0, "CmD": 0, "CaSD": 0, "CsSD": 0,
                "VmS": 0, "VmD": 0, "VaSD": 0, "NAMw": 0, "NLw": 0
            },
            "weekday_groups": {
                "XmM": 0, "XM": 0, "XA": 0, "XS": 0,
                "NMC": 0, "Vm": 0, "NL": 0, "NLv": 0
            }
        }

        current_date = self.start_date
        while current_date <= self.end_date:
            day_type = DayType.get_day_type(current_date, self.cal)
            
            normalized_day_type = {
                "weekday": "Semaine",
                "saturday": "Samedi",
                "sunday_holiday": "Dimanche/Férié"
            }.get(day_type)
            
            # Recherche de configuration spécifique
            specific_config = next(
                (sc for sc in self.post_configuration.specific_configs 
                if sc.start_date <= current_date <= sc.end_date 
                and sc.apply_to == normalized_day_type),
                None
            )

            for post_type in all_possible_posts:
                # Déterminer le nombre de postes
                if specific_config and post_type in specific_config.post_counts:
                    post_count = specific_config.post_counts[post_type]
                else:
                    config = getattr(self.post_configuration, day_type)
                    post_count = config.get(post_type, PostConfig()).total

                # Traitement spécial des NL
                if post_type == "NL" and day_type == "weekday":
                    if current_date.weekday() == 4:  # Vendredi
                        posts_analysis["weekday_groups"]["NLv"] += post_count
                        posts_analysis["weekend_groups"]["NLw"] += post_count
                    else:
                        posts_analysis["weekday_groups"]["NL"] += post_count
                    posts_analysis["weekday"][post_type] += post_count
                    
                else:
                    posts_analysis[day_type][post_type] += post_count
                    
                    # Mise à jour des groupes selon le type de poste
                    if post_type in self.custom_posts:
                        custom_post = self.custom_posts[post_type]
                        if custom_post.statistic_group:
                            group = custom_post.statistic_group.strip()
                            if day_type == "weekday" and group in posts_analysis["weekday_groups"]:
                                posts_analysis["weekday_groups"][group] += post_count
                            elif day_type in ["saturday", "sunday_holiday"] and group in posts_analysis["weekend_groups"]:
                                posts_analysis["weekend_groups"][group] += post_count
                                self.logger.debug(f"Groupe {group} mis à jour pour {post_type}: +{post_count}")
                    else:
                        # Postes standards
                        if day_type == "weekday":
                            self._update_weekday_group_counts(posts_analysis["weekday_groups"], post_type, post_count)
                        else:
                            self._update_weekend_group_counts(posts_analysis["weekend_groups"], post_type, post_count, day_type, current_date)

            current_date += timedelta(days=1)

        # Log des résultats
        self.logger.info("\nTOTAL DES POSTES PAR TYPE:")
        self.logger.info("\nWEEKDAY:")
        nl_count = posts_analysis["weekday_groups"]["NL"]
        nlv_count = posts_analysis["weekday_groups"]["NLv"]
        self.logger.info(f"NL (lundi-jeudi) : {nl_count:3d}")
        self.logger.info(f"NLv (vendredi)   : {nlv_count:3d}")
        self.logger.info(f"Total NL semaine : {nl_count + nlv_count:3d}")

        # Log des postes de semaine
        for post_type, count in sorted(posts_analysis["weekday"].items()):
            if count > 0 and post_type != "NL":
                if post_type in self.custom_posts:
                    self.logger.info(f"{post_type:4}: {count:3d} (Personnalisé)")
                else:
                    self.logger.info(f"{post_type:4}: {count:3d}")

        # Log des postes de weekend
        if any(posts_analysis["saturday"].values()) or any(posts_analysis["sunday_holiday"].values()):
            self.logger.info("\nPOSTES WEEKEND:")
            for post_type in all_possible_posts:
                total = posts_analysis["saturday"].get(post_type, 0) + posts_analysis["sunday_holiday"].get(post_type, 0)
                if total > 0:
                    if post_type in self.custom_posts:
                        self.logger.info(f"{post_type:4}: {total:3d} (Personnalisé)")
                    else:
                        self.logger.info(f"{post_type:4}: {total:3d}")

        self.logger.info("\nGROUPES WEEKEND:")
        for group, count in posts_analysis["weekend_groups"].items():
            if count > 0:
                self.logger.info(f"{group:6}: {count:3d}")

        self.logger.info("\nGROUPES SEMAINE:")
        for group, count in posts_analysis["weekday_groups"].items():
            if count > 0:
                self.logger.info(f"{group:6}: {count:3d}")

        return posts_analysis
    def calculate_cat_group_count(self, group: str, cat_posts: Dict) -> int:
        """Calcule le nombre de postes CAT pour un groupe donné"""
        total = 0
        
        # Définition des mappings de postes pour chaque groupe
        group_mappings = {
            # Groupes Weekend (uniquement samedi et dimanche/férié)
            "CmS": ["CM", "HM","SM", "RM", "MM"],  # Uniquement samedi
            "CmD": ["CM", "HM", "SM", "RM"],  # Uniquement dimanche
            "CaSD": ["CA", "HA", "SA", "RA"],  # Samedi + Dimanche
            "CsSD": ["CS", "HS", "SS", "RS"],  # Samedi + Dimanche
            "VmS": ["ML","MC"],  # Uniquement samedi
            "VmD": ["ML", "MC"],  # Uniquement dimanche
            "VaSD": ["AL", "AC"],  # Samedi + Dimanche
            "NAMw": ["NM", "NA", "NC"],  # Samedi + Dimanche
            "NLw": ["NL"],  # NLw = NLs + NLd + NLv
            
            # Groupes Semaine (uniquement weekday)
            "XmM": ["MM", "SM"],
            "XM": ["CM", "HM", "RM"],
            "XA": ["CA", "HA", "SA","RA"],
            "XS": ["CS", "HS", "SS", "RS"],
            "NMC": ["NM", "NC","NA"],
            "Vm": ["ML", "MC"],
            "NL": ["NL"],
            "NLv": ["NL"]
        }
        
        if group in group_mappings:
            if group == "NLw":
                # NLs + NLd + NLv
                total = (
                    cat_posts["saturday"].get("NL", 0) +          # NLs
                    cat_posts["sunday_holiday"].get("NL", 0) +    # NLd
                    cat_posts["weekday"].get("NLv", 0)           # NLv
                )
            elif group in ["CmS", "VmS"]:
                # Groupes uniquement samedi
                for post_type in group_mappings[group]:
                    total += cat_posts["saturday"].get(post_type, 0)
            elif group in ["CmD", "VmD"]:
                # Groupes uniquement dimanche
                for post_type in group_mappings[group]:
                    total += cat_posts["sunday_holiday"].get(post_type, 0)
            elif group in ["CaSD", "CsSD", "VaSD", "NAMw"]:
                # Groupes samedi + dimanche
                for post_type in group_mappings[group]:
                    total += (cat_posts["saturday"].get(post_type, 0) +
                            cat_posts["sunday_holiday"].get(post_type, 0))
            else:
                # Groupes semaine (uniquement weekday)
                for post_type in group_mappings[group]:
                    total += cat_posts["weekday"].get(post_type, 0)
        
        return total
    def _update_weekend_group_counts(self, groups: Dict, post_type: str, count: int, day_type: str, current_date: date):
        """
        Met à jour les compteurs de groupes pour le weekend.
        Les jours de pont sont traités comme des fériés, même les samedis.
        """
        is_bridge = self.is_bridge_day(current_date)
        is_holiday = self.cal.is_holiday(current_date)
        is_sunday = current_date.weekday() == 6
        
        # Un samedi qui est un jour de pont est traité comme un férié
        is_saturday = day_type == "saturday" and not (is_bridge or is_holiday)
        is_sunday_or_holiday = (day_type == "sunday_holiday" or is_bridge or is_holiday or is_sunday)

        # Gestion des postes personnalisés
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            if custom_post.statistic_group:
                if custom_post.statistic_group in ["CmS", "VmS"] and is_saturday:
                    groups[custom_post.statistic_group] += count
                elif custom_post.statistic_group in ["CmD", "VmD"] and is_sunday_or_holiday:
                    groups[custom_post.statistic_group] += count
                elif custom_post.statistic_group in ["CaSD", "CsSD", "VaSD", "NAMw", "NLw"]:
                    groups[custom_post.statistic_group] += count
            return

        # Gestion des postes standards
        if post_type in ["MM", "CM", "HM", "SM", "RM"]:
            if is_saturday:
                groups["CmS"] += count
            elif is_sunday_or_holiday:
                groups["CmD"] += count
        elif post_type in ["CA", "HA", "SA", "RA"]:
            groups["CaSD"] += count
        elif post_type in ["CS", "HS", "SS", "RS"]:
            groups["CsSD"] += count
        elif post_type == "ML":
            if is_saturday:
                groups["VmS"] += count
            elif is_sunday_or_holiday:
                groups["VmD"] += count
        elif post_type == "MC":
            if is_sunday_or_holiday:
                groups["VmD"] += count
        elif post_type in ["AL", "AC"]:
            groups["VaSD"] += count
        elif post_type in ["NM", "NA"]:
            groups["NAMw"] += count
        elif post_type == "NL":  # NLw inclut maintenant NLv + NLs + NLd
            groups["NLw"] += count

    def _update_weekday_group_counts(self, groups: Dict, post_type: str, count: int):
        """Met à jour les compteurs de groupes pour la semaine"""
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            period = self.get_post_period(custom_post.start_time, custom_post.end_time)
            
            statistic_group = custom_post.statistic_group
            
            if statistic_group:
                if period == 0:  # Matin
                    if statistic_group == "XmM":
                        groups["XmM"] += count
                    elif statistic_group == "XM":
                        groups["XM"] += count
                    elif statistic_group == "Vm":
                        groups["Vm"] += count
                elif period == 1:  # Après-midi
                    if statistic_group == "XA":
                        groups["XA"] += count
                elif period == 2:  # Soir
                    if statistic_group == "XS":
                        groups["XS"] += count
                    elif statistic_group == "NMC":
                        groups["NMC"] += count
            return

        # Gestion des postes standards
        else:
            period = self.get_post_period_static(post_type)
        if post_type == "MM":
            groups["XmM"] += count
        elif post_type in ["CM", "HM", "SM", "RM"]:
            groups["XM"] += count
        elif post_type in ["CA", "HA", "SA", "RA"]:
            groups["XA"] += count
        elif post_type in ["CS", "HS", "SS", "RS"]:
            groups["XS"] += count
        elif post_type in ["ML", "MC"]:
            groups["Vm"] += count
        elif post_type in ["NM", "NC", "NA"]:
            groups["NMC"] += count

    def _update_cat_groups(self, cat_posts: Dict):
        """Met à jour les groupes pour les postes CAT"""
        # Groupes de semaine
        cat_posts["weekday_groups"]["XmM"] = cat_posts["weekday"]["MM"]
        cat_posts["weekday_groups"]["XM"] = cat_posts["weekday"]["CM"] + cat_posts["weekday"]["HM"]
        cat_posts["weekday_groups"]["XA"] = cat_posts["weekday"]["CA"] + cat_posts["weekday"]["HA"]
        cat_posts["weekday_groups"]["XS"] = cat_posts["weekday"]["CS"] + cat_posts["weekday"]["HS"]
        cat_posts["weekday_groups"]["NMC"] = cat_posts["weekday"]["NM"] + cat_posts["weekday"]["NC"]
        cat_posts["weekday_groups"]["Vm"] = cat_posts["weekday"]["ML"] + cat_posts["weekday"]["MC"]

        # Groupes de weekend
        weekend_nl = cat_posts["saturday"]["NL"] + cat_posts["sunday_holiday"]["NL"]
        cat_posts["weekend_groups"]["NLw"] = weekend_nl

        cat_posts["weekend_groups"]["CmS"] = cat_posts["saturday"]["CM"] + cat_posts["saturday"]["HM"] + cat_posts["saturday"]["MM"]
        cat_posts["weekend_groups"]["CmD"] = (cat_posts["sunday_holiday"]["CM"] + 
                                            cat_posts["sunday_holiday"]["HM"] + 
                                            cat_posts["sunday_holiday"]["SM"] + 
                                            cat_posts["sunday_holiday"]["RM"])

        weekend_ca = (cat_posts["saturday"]["CA"] + cat_posts["saturday"]["HA"] +
                    cat_posts["sunday_holiday"]["CA"] + cat_posts["sunday_holiday"]["HA"])
        cat_posts["weekend_groups"]["CaSD"] = weekend_ca

        weekend_cs = (cat_posts["saturday"]["CS"] + cat_posts["saturday"]["HS"] +
                    cat_posts["sunday_holiday"]["CS"] + cat_posts["sunday_holiday"]["HS"])
        cat_posts["weekend_groups"]["CsSD"] = weekend_cs

        cat_posts["weekend_groups"]["VmS"] = cat_posts["saturday"]["ML"]
        cat_posts["weekend_groups"]["VmD"] = cat_posts["sunday_holiday"]["ML"] + cat_posts["sunday_holiday"]["MC"]
        
        weekend_va = (cat_posts["saturday"]["AL"] + cat_posts["saturday"]["AC"] +
                    cat_posts["sunday_holiday"]["AL"] + cat_posts["sunday_holiday"]["AC"])
        cat_posts["weekend_groups"]["VaSD"] = weekend_va

        weekend_nam = (cat_posts["saturday"]["NA"] + cat_posts["saturday"]["NM"] +
                    cat_posts["sunday_holiday"]["NA"] + cat_posts["sunday_holiday"]["NM"])
        cat_posts["weekend_groups"]["NAMw"] = weekend_nam

    
    
    
    def _log_days_distribution(self):
        """Log la répartition des jours sur la période"""
        details = {
            'weekdays': [],
            'saturdays': [],
            'sundays': [],
            'holidays': [],
            'bridges': [],
            'sunday_holiday_total': [],  # Pour compter tous les jours traités comme dimanche/férié
            'saturday_bridges': [],  # Samedis de pont spécifiquement
            'specific_configs': []
        }

        # Analyser d'abord les configurations spécifiques
        if hasattr(self.post_configuration, 'specific_configs'):
            for config in self.post_configuration.specific_configs:
                start = max(config.start_date, self.start_date)
                end = min(config.end_date, self.end_date)
                
                # Compter les jours spécifiques
                matching_days = 0
                current_date = start
                while current_date <= end:
                    counts_as_match = False
                    
                    if config.apply_to == "Semaine":
                        if current_date.weekday() < 5 and not self.cal.is_holiday(current_date) and not self.is_bridge_day(current_date):
                            counts_as_match = True
                    elif config.apply_to == "Samedi":
                        if current_date.weekday() == 5 and not self.cal.is_holiday(current_date) and not self.is_bridge_day(current_date):
                            counts_as_match = True
                    elif config.apply_to == "Dimanche/Férié":
                        if current_date.weekday() == 6 or self.cal.is_holiday(current_date) or self.is_bridge_day(current_date):
                            counts_as_match = True
                    
                    if counts_as_match:
                        matching_days += 1
                    current_date += timedelta(days=1)

                details['specific_configs'].append({
                    'start_date': config.start_date,
                    'end_date': config.end_date,
                    'apply_to': config.apply_to,
                    'posts': config.post_counts,
                    'matching_days': matching_days
                })

        # Collecte des jours normaux
        current_date = self.start_date
        while current_date <= self.end_date:
            if DayType.is_bridge_day(current_date, self.cal):
                details['bridges'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
                if current_date.weekday() == 5:
                    details['saturday_bridges'].append(current_date)
            elif self.cal.is_holiday(current_date):
                details['holidays'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
            elif current_date.weekday() == 6:  # Dimanche
                details['sundays'].append(current_date)
                details['sunday_holiday_total'].append(current_date)
            elif current_date.weekday() == 5 and not self.is_bridge_day(current_date):  # Samedi normal
                details['saturdays'].append(current_date)
            else:
                details['weekdays'].append(current_date)

            current_date += timedelta(days=1)

        # Affichage standard
        self.logger.info("\nDÉTAIL DES JOURS")
        self.logger.info("="*80)
        self.logger.info(f"Jours de semaine      : {len(details['weekdays']):3d}")
        self.logger.info(f"Samedis normaux       : {len(details['saturdays']):3d}")
        self.logger.info("\nJOURS TRAITÉS COMME DIMANCHE/FÉRIÉ:")
        self.logger.info(f"Dimanches             : {len(details['sundays']):3d}")
        self.logger.info(f"Jours fériés          : {len(details['holidays']):3d}")
        self.logger.info(f"Jours de pont         : {len(details['bridges']):3d}")
        self.logger.info(f"   dont samedis       : {len(details['saturday_bridges']):3d}")
        self.logger.info(f"TOTAL Dim/Férié/Pont  : {len(details['sunday_holiday_total']):3d}")

        # Affichage des configurations spécifiques
        if details['specific_configs']:
            self.logger.info("\nCONFIGURATIONS SPÉCIFIQUES:")
            self.logger.info("-"*80)
            for config in details['specific_configs']:
                # Formatage des postes prévus
                posts_detail = ", ".join([f"{count}{post}" for post, count in config['posts'].items()])
                
                self.logger.info(
                    f"* du {config['start_date'].strftime('%d/%m/%Y')} "
                    f"au {config['end_date'].strftime('%d/%m/%Y')} "
                    f"- {config['apply_to']} : {len(config['posts'])} postes "
                    f"({posts_detail})"
                )
                self.logger.info(f"  → {config['matching_days']} jours concernés")

        self.logger.info("-"*80)
        self.logger.info(f"Total jours période   : {self.total_days:3d}")

        self.logger.info("="*80)
        
    def _log_total_posts_distribution(self, total_posts: Dict):
        self.logger.info("\nDISTRIBUTION TOTALE DES POSTES")
        self.logger.info("=" * 80)
        # Affichage détaillé des postes par type de jour
    
    def _log_cat_posts_distribution(self, cat_posts: Dict):
        self.logger.info("\nDISTRIBUTION DES POSTES CAT")
        self.logger.info("=" * 80)
        # Affichage des postes réservés aux CAT

    def _log_adjusted_posts_distribution(self, adjusted_posts: Dict):
        """Affiche les détails de la distribution ajustée pour les médecins"""
        self.logger.info("\nDISTRIBUTION AJUSTÉE POUR LES MÉDECINS")
        self.logger.info("=" * 80)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)

        # Postes de semaine
        self.logger.info("\nWEEKDAY:")
        self.logger.info("-" * 60)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<25} {'Mi-temps (min-max)':<25}"
        self.logger.info(header)
        
        for post_type, count in sorted(adjusted_posts["weekday"].items()):
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{post_type:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

        # Postes de samedi et dimanche séparément
        for day_type in ["saturday", "sunday_holiday"]:
            day_name = "SATURDAY:" if day_type == "saturday" else "SUNDAY/HOLIDAY:"
            self.logger.info(f"\n{day_name}")
            self.logger.info("-" * 60)
            self.logger.info(header)
            
            for post_type, count in sorted(adjusted_posts[day_type].items()):
                if count > 0:
                    full_time_range = self.round_ideal(count, 2)
                    half_time_range = self.round_ideal(count, 1)
                    self.logger.info(
                        f"{post_type:<6} {count:>8} "
                        f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                        f"{' '*15}"
                        f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                    )

        # Groupes de semaine
        self.logger.info("\nGROUPES SEMAINE:")
        self.logger.info("-" * 60)
        self.logger.info(header)
        
        for group, count in adjusted_posts["weekday_groups"].items():
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{group:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

        # Groupes weekend (fusion des groupes samedi et dimanche)
        self.logger.info("\nGROUPES WEEKEND:")
        self.logger.info("-" * 60)
        self.logger.info(header)
        
        weekend_groups = adjusted_posts["weekend_groups"]
        # Correction du calcul de NLw
        weekend_groups["NLw"] = (
            adjusted_posts["saturday"].get("NL", 0) +  # NLs
            adjusted_posts["sunday_holiday"].get("NL", 0) +  # NLd
            adjusted_posts["weekday_groups"].get("NLv", 0)  # NLv
        )
        
        for group, count in weekend_groups.items():
            if count > 0:
                full_time_range = self.round_ideal(count, 2)
                half_time_range = self.round_ideal(count, 1)
                self.logger.info(
                    f"{group:<6} {count:>8} "
                    f"[{full_time_range['min']:>2}-{full_time_range['max']:<2}]"
                    f"{' '*15}"
                    f"[{half_time_range['min']:>2}-{half_time_range['max']:<2}]"
                )

    def _log_ideal_distribution(self, adjusted_posts: Dict):
        """Affiche la distribution idéale des postes par type de médecin"""
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        full_time_count = sum(1 for d in self.doctors if d.half_parts == 2)
        half_time_count = sum(1 for d in self.doctors if d.half_parts == 1)

        self.logger.info("\nDISTRIBUTION IDÉALE PAR MÉDECIN TYPE")
        self.logger.info("=" * 100)

        # En-tête avec le nombre de médecins
        self.logger.info(f"Nombre de médecins plein temps: {full_time_count}")
        self.logger.info(f"Nombre de médecins mi-temps: {half_time_count}")
        self.logger.info(f"Total demi-parts: {total_half_parts}")
        self.logger.info("")

        header = "{:<8} {:<10} {:<25} {:<25}".format(
            "Type", "Total", "Plein temps", "Mi-temps"
        )

        def log_section(title: str, items: Dict[str, int]):
            """Affiche une section des résultats"""
            self.logger.info(f"\n{title}")
            self.logger.info("-" * 100)
            self.logger.info(header)
            self.logger.info("-" * 100)

            for post_type, total in sorted(items.items()):
                if total > 0:
                    # Utiliser round_ideal pour les deux calculs
                    full_time_range = self.round_ideal(total, 2)
                    half_time_range = self.round_ideal(total, 1)

                    self.logger.info("{:<8} {:<10.1f} [{:>2d}-{:<2d}] ({:.1f})           [{:>2d}-{:<2d}] ({:.1f})".format(
                        post_type,
                        total,
                        full_time_range['min'], full_time_range['max'], full_time_range['target'],
                        half_time_range['min'], half_time_range['max'], half_time_range['target']
                    ))

        # Gardes de nuit semaine
        night_posts = {
            "NL": adjusted_posts["weekday"]["NL"],
            "NLv": adjusted_posts["weekday_groups"]["NLv"]
        }
        log_section("GARDES DE NUIT SEMAINE", night_posts)

        # Autres postes semaine
        weekday_posts = {
            k: v for k, v in adjusted_posts["weekday"].items() 
            if k not in ["NL", "NLv"]
        }
        log_section("AUTRES POSTES SEMAINE", weekday_posts)

        # Groupes semaine
        weekday_groups = {
            k: v for k, v in adjusted_posts["weekday_groups"].items() 
            if k not in ["NL", "NLv"]
        }
        log_section("GROUPES SEMAINE", weekday_groups)

        # Postes weekend
        weekend_posts = {}
        for post_type in set(list(adjusted_posts["saturday"].keys()) + 
                            list(adjusted_posts["sunday_holiday"].keys())):
            total = (adjusted_posts["saturday"].get(post_type, 0) + 
                    adjusted_posts["sunday_holiday"].get(post_type, 0))
            if total > 0:
                weekend_posts[post_type] = total
        log_section("POSTES WEEKEND", weekend_posts)

        # Groupes weekend
        log_section("GROUPES WEEKEND", adjusted_posts["weekend_groups"])
    
        
    def _log_weekend_posts(self, total_posts: Dict, total_parts: int):
        """Affiche les statistiques des postes du weekend"""
        self.logger.info("\nPOSTES WEEKEND")
        self.logger.info("="*80)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.info(f"\n{day_type.upper()}:")
            self.logger.info("-"*80)
            
            for post_type, count in sorted(total_posts[day_type].items()):
                if count > 0:
                    full_time, half_time = self._calculate_ranges(count, total_parts)
                    self.logger.info(
                        f"{post_type:<6} {count:<8} "
                        f"[{full_time['min']}-{full_time['max']}]"
                        f"{' '*8}"
                        f"[{half_time['min']}-{half_time['max']}]"
                    )

    def _log_weekend_groups(self, groups: Dict, total_parts: int):
        """Affiche les statistiques des groupes du weekend"""
        self.logger.info("\nGROUPES WEEKEND")
        self.logger.info("="*80)
        header = f"{'Groupe':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        self.logger.info("-"*80)
        
        for group, count in sorted(groups.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{group:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )

    def _log_weekday_distribution(self, weekday_posts: Dict, weekday_groups: Dict, total_parts: int):
        """Affiche les statistiques des postes et groupes de semaine"""
        self.logger.info("\nDISTRIBUTION SEMAINE")
        self.logger.info("="*80)
        header = f"{'Type':<6} {'Total':<8} {'Plein temps (min-max)':<20} {'Mi-temps (min-max)':<20}"
        self.logger.info(header)
        
        self.logger.info("\nPOSTES:")
        self.logger.info("-"*80)
        for post_type, count in sorted(weekday_posts.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{post_type:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )
        
        self.logger.info("\nGROUPES:")
        self.logger.info("-"*80)
        for group, count in sorted(weekday_groups.items()):
            if count > 0:
                full_time, half_time = self._calculate_ranges(count, total_parts)
                self.logger.info(
                    f"{group:<6} {count:<8} "
                    f"[{full_time['min']}-{full_time['max']}]"
                    f"{' '*8}"
                    f"[{half_time['min']}-{half_time['max']}]"
                )




    def is_bridge_day(self, day: date) -> bool:
        return DayType.is_bridge_day(day, self.cal)

    def get_post_period(self, start_time: time, end_time: time) -> int:
        """
        Détermine la période d'un poste basé sur ses horaires.
        Retourne:
            0: Matin (7h-13h)
            1: Après-midi (13h-18h)
            2: Soir (18h-7h)
        """
        # Si le poste traverse minuit
        if end_time < start_time:
            hours_range = list(range(start_time.hour, 24)) + list(range(0, end_time.hour + 1))
        else:
            hours_range = list(range(start_time.hour, end_time.hour + 1))
        
        # Compte les heures dans chaque période
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        # Retourne la période avec le plus d'heures
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        if max_hours == morning_hours:
            return 0
        elif max_hours == afternoon_hours:
            return 1
        else:
            return 2

    def get_post_period_static(self, post_type: str) -> int:
        """
        Détermine la période d'un poste standard basé sur son type.
        Retourne:
            0: Matin (ML, MC, MM, CM, HM, SM, RM)
            1: Après-midi (CA, HA, SA, RA, AL, AC)
            2: Soir (autres)
        """
        if post_type in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return 0
        elif post_type in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1
        else:
            return 2
        
    def overlaps(self, desiderata: Desiderata, start: date, end: date) -> bool:
        """Vérifie si une période de desiderata chevauche une période donnée"""
        return max(desiderata.start_date, start) <= min(desiderata.end_date, end)

    def analyze_unavailability(self) -> Dict:
        """
        Analyse les indisponibilités des médecins sur la période.
        Distingue les desiderata primaires (stricts) et secondaires (souples).
        """
        unavailability = {}
        daily_availability = {
            (self.start_date + timedelta(days=i)): {
                "primary": 0,
                "secondary": 0,
                "total": 0
            } for i in range((self.end_date - self.start_date).days + 1)
        }
        
        total_days = (self.end_date - self.start_date).days + 1
        total_periods = total_days * 3  # 3 périodes par jour

        self.logger.info(f"Analyzing unavailability for {len(self.doctors)} doctors over {total_days} days ({total_periods} total periods)")

        for doctor in self.doctors:
            # Initialisation des compteurs par type
            primary_periods = 0
            secondary_periods = 0
            
            for desiderata in doctor.desiderata:
                if self.overlaps(desiderata, self.start_date, self.end_date):
                    start = max(desiderata.start_date, self.start_date)
                    end = min(desiderata.end_date, self.end_date)
                    days = (end - start).days + 1
                    
                    # Détermination du type de desiderata (rétrocompatibilité)
                    priority = getattr(desiderata, 'priority', 'primary')
                    
                    # Mise à jour des compteurs selon le type
                    if priority == "primary":
                        primary_periods += days
                    else:  # secondary
                        secondary_periods += days
                    
                    # Mise à jour du compteur quotidien
                    for day in (start + timedelta(n) for n in range(days)):
                        daily_availability[day][priority] += 1
                        daily_availability[day]["total"] += 1

            # Calcul des pourcentages pour chaque type
            total_periods_unavailable = primary_periods + secondary_periods
            raw_primary = round((primary_periods / total_periods) * 100, 2)
            raw_secondary = round((secondary_periods / total_periods) * 100, 2)
            raw_total = round((total_periods_unavailable / total_periods) * 100, 2)
            
            # Ajustement pour les mi-temps
            if doctor.half_parts == 1:
                adjusted_primary = round(raw_primary / 2, 2)
                adjusted_secondary = round(raw_secondary / 2, 2)
                adjusted_total = round(raw_total / 2, 2)
                
                unavailability[doctor.name] = {
                    "primary": {
                        "raw": raw_primary,
                        "adjusted": adjusted_primary,
                        "periods": primary_periods
                    },
                    "secondary": {
                        "raw": raw_secondary,
                        "adjusted": adjusted_secondary,
                        "periods": secondary_periods
                    },
                    "total": {
                        "raw": raw_total,
                        "adjusted": adjusted_total,
                        "periods": total_periods_unavailable
                    },
                    "is_half_time": True
                }
                
                self.logger.debug(
                    f"Doctor {doctor.name} (mi-temps):\n"
                    f"  Primary: {primary_periods} périodes ({raw_primary}% brut, {adjusted_primary}% ajusté)\n"
                    f"  Secondary: {secondary_periods} périodes ({raw_secondary}% brut, {adjusted_secondary}% ajusté)\n"
                    f"  Total: {total_periods_unavailable} périodes ({raw_total}% brut, {adjusted_total}% ajusté)")
            else:
                unavailability[doctor.name] = {
                    "primary": {
                        "raw": raw_primary,
                        "adjusted": raw_primary,
                        "periods": primary_periods
                    },
                    "secondary": {
                        "raw": raw_secondary,
                        "adjusted": raw_secondary,
                        "periods": secondary_periods
                    },
                    "total": {
                        "raw": raw_total,
                        "adjusted": raw_total,
                        "periods": total_periods_unavailable
                    },
                    "is_half_time": False
                }
                
                self.logger.debug(
                    f"Doctor {doctor.name}:\n"
                    f"  Primary: {primary_periods} périodes ({raw_primary}%)\n"
                    f"  Secondary: {secondary_periods} périodes ({raw_secondary}%)\n"
                    f"  Total: {total_periods_unavailable} périodes ({raw_total}%)")

        # Tri des médecins par pourcentage total d'indisponibilité
        sorted_unavailability = sorted(
            unavailability.items(),
            key=lambda x: x[1]["total"]["raw"],
            reverse=True
        )

        # Log détaillé des résultats
        self.logger.info("\nINDISPONIBILITÉS DES MÉDECINS:")
        self.logger.info("-" * 80)
        for doctor_name, data in sorted_unavailability:
            if data["is_half_time"]:
                self.logger.info(
                    f"{doctor_name:<15}: "
                    f"Primaire: {data['primary']['raw']:>5.2f}% ({data['primary']['adjusted']:>5.2f}% ajusté), "
                    f"Secondaire: {data['secondary']['raw']:>5.2f}% ({data['secondary']['adjusted']:>5.2f}% ajusté), "
                    f"Total: {data['total']['raw']:>5.2f}% ({data['total']['adjusted']:>5.2f}% ajusté)"
                )
            else:
                self.logger.info(
                    f"{doctor_name:<15}: "
                    f"Primaire: {data['primary']['raw']:>5.2f}%, "
                    f"Secondaire: {data['secondary']['raw']:>5.2f}%, "
                    f"Total: {data['total']['raw']:>5.2f}%"
                )

        # Identification des jours critiques
        least_available_days = sorted(
            [(day, counts) for day, counts in daily_availability.items()],
            key=lambda x: x[1]["total"],
            reverse=True
        )[:5]

        self.logger.info("\nJOURS LES PLUS CRITIQUES:")
        self.logger.info("-" * 80)
        for day, counts in least_available_days:
            self.logger.info(
                f"{day.strftime('%d/%m/%Y')} : "
                f"{counts['total']} médecins indisponibles "
                f"(Primaire: {counts['primary']}, Secondaire: {counts['secondary']})"
            )

        return {
            "doctor_unavailability": unavailability,
            "least_available_days": least_available_days
        }

    def analyze_ideal_distribution(self, adjusted_posts: Dict) -> Dict:
        """Calcule la distribution idéale des postes et groupes pour chaque médecin"""
        ideal_distribution = {}
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)

        for doctor in self.doctors:
            ideal_distribution[doctor.name] = {
                "weekday_posts": {},
                "weekend_posts": {},
                "weekday_groups": {},
                "weekend_groups": {}
            }

            # Traitement des postes de semaine
            for post_type, total in adjusted_posts["weekday"].items():
                if total > 0:
                    # Calcul du nombre idéal pour ce médecin
                    posts_per_half_part = total / total_half_parts
                    target_value = posts_per_half_part * doctor.half_parts

                    ideal_distribution[doctor.name]["weekday_posts"][post_type] = {
                        "min": math.floor(target_value),
                        "max": math.ceil(target_value),
                        "target": target_value
                    }

            # Traitement des postes de weekend
            for post_type, total in adjusted_posts.get("saturday", {}).items():
                weekend_total = (total + adjusted_posts["sunday_holiday"].get(post_type, 0))
                if weekend_total > 0:
                    posts_per_half_part = weekend_total / total_half_parts
                    target_value = posts_per_half_part * doctor.half_parts

                    ideal_distribution[doctor.name]["weekend_posts"][post_type] = {
                        "min": math.floor(target_value),
                        "max": math.ceil(target_value),
                        "target": target_value
                    }

            # Traitement des groupes
            for group_type, groups in [
                ("weekend_groups", ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]),
                ("weekday_groups", ["XmM", "XM", "XA", "XS", "NMC", "Vm", "NL", "NLv"])
            ]:
                for group in groups:
                    total = adjusted_posts.get(group_type.split('_')[0] + "_groups", {}).get(group, 0)
                    if total > 0:
                        posts_per_half_part = total / total_half_parts
                        target_value = posts_per_half_part * doctor.half_parts

                        ideal_distribution[doctor.name][group_type][group] = {
                            "min": math.floor(target_value),
                            "max": math.ceil(target_value),
                            "target": target_value
                        }

        return ideal_distribution

    def _get_combo_groups(self, combo: str) -> List[str]:
        """Retourne les groupes impliqués dans une combinaison"""
        group_mapping = {
            # Premier poste
            "ML": ["VmS", "VmD"],
            "MC": ["VmD"],
            "CM": ["CmS"],
            "HM": ["CmS"],
            "SM": ["CmD"],
            "RM": ["CmD"],
            # Second poste
            "CA": ["CaSD"],
            "HA": ["CaSD"],
            "SA": ["CaSD"],
            "RA": ["CaSD"],
            "CS": ["CsSD"],
            "HS": ["CsSD"],
            "SS": ["CsSD"],
            "RS": ["CsSD"],
            "AL": ["VaSD"],
            "AC": ["VaSD"],
            "NA": ["NAMw"]
        }
        
        first_post = combo[:2]
        second_post = combo[2:]
        
        groups = set()
        if first_post in group_mapping:
            groups.update(group_mapping[first_post])
        if second_post in group_mapping:
            groups.update(group_mapping[second_post])
            
        return list(groups)

    def _calculate_combo_total(self, combo: str, adjusted_posts: Dict) -> int:
        """Calcule le total possible pour une combinaison"""
        first_post = combo[:2]
        second_post = combo[2:]
        
        first_total = (
            adjusted_posts["saturday"].get(first_post, 0) +
            adjusted_posts["sunday_holiday"].get(first_post, 0)
        )
        second_total = (
            adjusted_posts["saturday"].get(second_post, 0) +
            adjusted_posts["sunday_holiday"].get(second_post, 0)
        )
        
        return min(first_total, second_total)
    def _calculate_combo_base_value(self, combo: str, adjusted_posts: Dict, half_parts: int) -> float:
        """Calcule la valeur de base pour une combinaison"""
        # Trouver les postes constituant la combinaison
        first_post, second_post = combo[:2], combo[2:]
        
        # Calculer le total disponible
        total_first = (
            adjusted_posts["saturday"].get(first_post, 0) +
            adjusted_posts["sunday_holiday"].get(first_post, 0)
        )
        total_second = (
            adjusted_posts["saturday"].get(second_post, 0) +
            adjusted_posts["sunday_holiday"].get(second_post, 0)
        )
        
        total_combo = min(total_first, total_second)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        
        # Retourne la valeur proportionnelle aux demi-parts
        return total_combo * (half_parts / total_half_parts)
    
    def adjust_posts_for_cats(self, total_posts_analysis: Dict, cat_posts: Dict) -> Dict:
        """Ajuste les totaux de postes en soustrayant les postes CAT, avec chaque CAT recevant son quota complet"""
        self.logger.info("\nAjustement des postes pour les médecins")
        
        # Nombre de CAT
        num_cats = len(self.cats)
        
        # Initialisation des dictionnaires de résultats
        adjusted_posts = {
            "weekday": {},
            "saturday": {},
            "sunday_holiday": {},
            "weekend_groups": {},
            "weekday_groups": {}
        }
        
        # 1. Ajustement des postes de semaine
        self.logger.info("\nAJUSTEMENT POSTES SEMAINE:")
        for post_type in total_posts_analysis["weekday"]:
            if post_type not in ["NL", "NLv"]:  # Traitement spécial pour NL/NLv
                total_count = total_posts_analysis["weekday"].get(post_type, 0)
                cat_count = cat_posts["weekday"].get(post_type, 0)
                cat_total = cat_count * num_cats  # Multiplier par le nombre de CAT
                adjusted_count = max(0, total_count - cat_total)
                adjusted_posts["weekday"][post_type] = adjusted_count
                if total_count > 0 or cat_count > 0:
                    self.logger.info(f"{post_type:4}: Total={total_count:3d}, CAT={cat_count:2d} x {num_cats} = {cat_total:2d}, Ajusté={adjusted_count:3d}")

        # 2. Ajustement spécial pour NL et NLv de semaine
        total_nl = total_posts_analysis["weekday_groups"]["NL"]
        total_nlv = total_posts_analysis["weekday_groups"]["NLv"]
        cat_nl = cat_posts["weekday"].get("NL", 0) * num_cats
        cat_nlv = cat_posts["weekday"].get("NLv", 0) * num_cats

        adjusted_nl = max(0, total_nl - cat_nl)
        adjusted_nlv = max(0, total_nlv - cat_nlv)

        adjusted_posts["weekday"]["NL"] = adjusted_nl
        adjusted_posts["weekday_groups"]["NL"] = adjusted_nl
        adjusted_posts["weekday_groups"]["NLv"] = adjusted_nlv

        self.logger.info(f"NL  : Total={total_nl:3d}, CAT={cat_nl//num_cats:2d} x {num_cats} = {cat_nl:2d}, Ajusté={adjusted_nl:3d}")
        self.logger.info(f"NLv : Total={total_nlv:3d}, CAT={cat_nlv//num_cats:2d} x {num_cats} = {cat_nlv:2d}, Ajusté={adjusted_nlv:3d}")

        # 3. Ajustement des postes de weekend (samedi et dimanche séparément)
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.info(f"\nAJUSTEMENT POSTES {day_type.upper()}:")
            for post_type in total_posts_analysis[day_type]:
                total_count = total_posts_analysis[day_type].get(post_type, 0)
                cat_count = cat_posts[day_type].get(post_type, 0)
                cat_total = cat_count * num_cats
                adjusted_count = max(0, total_count - cat_total)
                adjusted_posts[day_type][post_type] = adjusted_count
                if total_count > 0 or cat_count > 0:
                    self.logger.info(f"{post_type:4}: Total={total_count:3d}, CAT={cat_count:2d} x {num_cats} = {cat_total:2d}, Ajusté={adjusted_count:3d}")

        # 4. Ajustement des groupes de semaine
        self.logger.info("\nAJUSTEMENT GROUPES SEMAINE:")
        for group in total_posts_analysis["weekday_groups"]:
            if group not in ["NL", "NLv"]:  # Déjà traités
                cat_group_count = self.calculate_cat_group_count(group, cat_posts) * num_cats
                total_group_count = total_posts_analysis["weekday_groups"][group]
                adjusted_count = max(0, total_group_count - cat_group_count)
                adjusted_posts["weekday_groups"][group] = adjusted_count
                if total_group_count > 0 or cat_group_count > 0:
                    self.logger.info(f"{group:6}: Total={total_group_count:3d}, CAT={cat_group_count//num_cats:2d} x {num_cats} = {cat_group_count:2d}, Ajusté={adjusted_count:3d}")

        # 5. Ajustement des groupes de weekend
        self.logger.info("\nAJUSTEMENT GROUPES WEEKEND:")
        for group in total_posts_analysis["weekend_groups"]:
            if group != "NLw":  # Traitement spécial pour NLw
                cat_group_count = self.calculate_cat_group_count(group, cat_posts) * num_cats
                total_group_count = total_posts_analysis["weekend_groups"][group]
                adjusted_count = max(0, total_group_count - cat_group_count)
                adjusted_posts["weekend_groups"][group] = adjusted_count
                if total_group_count > 0 or cat_group_count > 0:
                    self.logger.info(f"{group:6}: Total={total_group_count:3d}, CAT={cat_group_count//num_cats:2d} x {num_cats} = {cat_group_count:2d}, Ajusté={adjusted_count:3d}")

        # 6. Calcul spécial pour NLw
        total_nls = total_posts_analysis["saturday"].get("NL", 0)
        total_nld = total_posts_analysis["sunday_holiday"].get("NL", 0)
        total_nlv = total_posts_analysis["weekday_groups"].get("NLv", 0)
        total_nlw = total_nls + total_nld + total_nlv

        cat_nls = cat_posts["saturday"].get("NL", 0) * num_cats
        cat_nld = cat_posts["sunday_holiday"].get("NL", 0) * num_cats
        cat_nlv = cat_posts["weekday"].get("NLv", 0) * num_cats
        cat_total = cat_nls + cat_nld + cat_nlv

        adjusted_nls = max(0, total_nls - cat_nls)
        adjusted_nld = max(0, total_nld - cat_nld)
        adjusted_nlv = max(0, total_nlv - cat_nlv)
        adjusted_total = adjusted_nls + adjusted_nld + adjusted_nlv

        adjusted_posts["weekend_groups"]["NLw"] = adjusted_total

        self.logger.info(
            f"NLw    : Total={total_nlw:3d} (NLs {total_nls} + NLd {total_nld} + NLv {total_nlv})  "
            f"CAT={cat_total//num_cats:2d} (NLs {cat_nls//num_cats} + NLd {cat_nld//num_cats} + NLv {cat_nlv//num_cats}) x {num_cats} = {cat_total:2d}  "
            f"Ajusté={adjusted_total:3d}"
        )

        return adjusted_posts
    

    def round_ideal(self, total_posts: float, half_parts: int) -> Dict[str, float]:
        """
        Calcule la répartition idéale des postes basée sur le nombre de demi-parts
        avec un intervalle serré (±1 autour de la moyenne arrondie)
        
        Args:
            total_posts: Nombre total de postes à répartir
            half_parts: Nombre de demi-parts du médecin (1 ou 2)
                
        Returns:
            Dict avec min, max et target (moyenne exacte)
        """
        # Calcul de la moyenne exacte
        base_value = total_posts * (half_parts / self.total_half_parts)
        
        # Arrondir au plus proche
        rounded = round(base_value)
        
        # Si la moyenne est inférieure à la valeur arrondie
        # l'intervalle sera [rounded-1, rounded]
        if base_value < rounded:
            return {
                "min": max(0, rounded - 1),  # Éviter les valeurs négatives
                "max": rounded,
                "target": base_value
            }
        # Si la moyenne est supérieure ou égale à la valeur arrondie
        # l'intervalle sera [rounded, rounded+1]
        else:
            return {
                "min": rounded,
                "max": rounded + 1,
                "target": base_value
            }
        
    

    
    
    
    
    def _log_analysis_summary(self, total_posts: Dict, cat_posts: Dict, adjusted_posts: Dict):
        """Affiche un tableau récapitulatif de l'analyse complète"""
        
        def print_header():
            headers = [
                "Type", "Total", "CAT", "Médecins", 
                "Temps Plein [min-max]", "Mi-temps [min-max]"
            ]
            header = "{:<20} {:>8} {:>8} {:>10} {:>20} {:>20}".format(*headers)
            self.logger.info("\n" + "=" * 90)
            self.logger.info(header)
            self.logger.info("-" * 90)

        def print_section(title):
            self.logger.info("\n" + title)
            self.logger.info("-" * 90)
            print_header()

        def format_line(post_type, total, cat, med, full_range, half_range):
            return "{:<20} {:>8d} {:>8d} {:>10d} {:>20} {:>20}".format(
                post_type, total, cat, med,
                f"[{full_range['min']}-{full_range['max']}]",
                f"[{half_range['min']}-{half_range['max']}]"
            )

        self.logger.info("\nTABLEAU RÉCAPITULATIF DE L'ANALYSE")
        self.logger.info("=" * 90)

        # SEMAINE
        print_section("POSTES SEMAINE")
        for post in sorted(total_posts["weekday"]):
            if total_posts["weekday"][post] > 0:
                total = total_posts["weekday"][post]
                cat = cat_posts["weekday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["weekday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # GROUPES SEMAINE
        print_section("GROUPES SEMAINE")
        for group in sorted(total_posts["weekday_groups"]):
            total = total_posts["weekday_groups"][group]
            cat = self.calculate_cat_group_count(group, cat_posts) * len(self.cats)
            med = adjusted_posts["weekday_groups"][group]
            full_range = self.round_ideal(med, 2)
            half_range = self.round_ideal(med, 1)
            self.logger.info(format_line(group, total, cat, med, full_range, half_range))

        # WEEKEND (SAMEDI)
        print_section("POSTES SAMEDI")
        for post in sorted(total_posts["saturday"]):
            if total_posts["saturday"][post] > 0:
                total = total_posts["saturday"][post]
                cat = cat_posts["saturday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["saturday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # WEEKEND (DIMANCHE)
        print_section("POSTES DIMANCHE/FÉRIÉS")
        for post in sorted(total_posts["sunday_holiday"]):
            if total_posts["sunday_holiday"][post] > 0:
                total = total_posts["sunday_holiday"][post]
                cat = cat_posts["sunday_holiday"].get(post, 0) * len(self.cats)
                med = adjusted_posts["sunday_holiday"][post]
                full_range = self.round_ideal(med, 2)
                half_range = self.round_ideal(med, 1)
                self.logger.info(format_line(post, total, cat, med, full_range, half_range))

        # GROUPES WEEKEND
        print_section("GROUPES WEEKEND")
        for group in sorted(total_posts["weekend_groups"]):
            total = total_posts["weekend_groups"][group]
            cat = self.calculate_cat_group_count(group, cat_posts) * len(self.cats)
            med = adjusted_posts["weekend_groups"][group]
            full_range = self.round_ideal(med, 2)
            half_range = self.round_ideal(med, 1)
            self.logger.info(format_line(group, total, cat, med, full_range, half_range))
            
            
            
            
    def get_all_post_types(self, day_type: str) -> List[str]:
        """Retourne tous les types de postes pour un type de jour donné"""
        all_posts = set(ALL_POST_TYPES)  # Utiliser un set pour éviter les doublons
        
        # Ajouter les postes personnalisés
        if hasattr(self, 'custom_posts'):
            custom_posts = [
                post_name
                for post_name, post in self.custom_posts.items()
                if hasattr(post, 'day_types') and day_type in post.day_types
            ]
            all_posts.update(custom_posts)
            
        return list(all_posts)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    def analyze_weekend_combinations_distribution(self, adjusted_posts: Dict) -> Dict:
        """Analyse la distribution des combinaisons de postes pour le weekend"""
        self.logger.info("\nANALYSE DES COMBINAISONS WEEKEND")
        self.logger.info("=" * 100)

        # Structure pour les postes disponibles (sans réduction)
        available_posts = {
            "saturday": adjusted_posts["saturday"].copy(),
            "sunday_holiday": adjusted_posts["sunday_holiday"].copy()
        }
        
        # Structure pour les postes CAT
        cat_posts = {
            "saturday": {},
            "sunday_holiday": {}
        }
        for post_type in ALL_POST_TYPES:
            for day_type in ["saturday", "sunday_holiday"]:
                config = getattr(self.post_configuration, f"cat_{day_type}")
                if hasattr(config, post_type):  # Voici le problème !
                    cat_posts[day_type][post_type] = config[post_type].total * len(self.cats)

        combinations_analysis = {}
        priority_combinations = self._get_post_combinations()

        # En-tête du tableau modifié
        header = "{:<10} {:<8} {:<25} {:<25} {:<40}".format(
            "Combo", "Total", "Plein temps (moy)", "Mi-temps (moy)", "CAT (S/D/Total)"
        )
        self.logger.info("\n" + header)
        self.logger.info("-" * len(header))

        for priority, combinations in priority_combinations.items():
            if combinations:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                priority_results = {}

                for combo in combinations:
                    first_post, second_post = combo[:2], combo[2:]
                    
                    # Calcul des combinaisons possibles pour médecins
                    med_combinations = self._calculate_possible_combinations(
                        first_post, second_post, available_posts
                    )
                    
                    # Calcul détaillé des combinaisons CAT
                    cat_detail = self._calculate_cat_combinations(
                        first_post, second_post, cat_posts
                    )

                    # Calcul des intervalles
                    intervals = self._calculate_combination_intervals(
                        med_combinations,
                        cat_detail['total']
                    )

                    # Affichage avec détail CAT
                    cat_display = (f"{cat_detail['saturday']}/{cat_detail['sunday_holiday']}/"
                                f"{cat_detail['total']}" if self.cats else "N/A")
                    
                    self.logger.info(
                        "{:<10} {:<8d} {:<25} {:<25} {:<40}".format(
                            combo,
                            med_combinations,
                            f"{self._format_interval(intervals['full_time'])}",
                            f"{self._format_interval(intervals['half_time'])}",
                            cat_display
                        )
                    )

                    # Stockage des résultats
                    priority_results[combo] = {
                        "total": med_combinations,
                        "cat_detail": cat_detail,
                        "intervals": intervals
                    }

                if priority_results:
                    combinations_analysis[priority] = priority_results

        return combinations_analysis

    def _calculate_possible_combinations(self, first_post: str, second_post: str, 
                                    posts: Dict[str, Dict[str, int]]) -> int:
        """
        Calcule le nombre de combinaisons possibles entre deux postes
        """
        # Log des postes disponibles
        self.logger.debug(f"\nAnalyse combinaison {first_post}+{second_post}:")
        for day_type in ["saturday", "sunday_holiday"]:
            self.logger.debug(f"{day_type} - {first_post}: {posts[day_type].get(first_post, 0)}, "
                            f"{second_post}: {posts[day_type].get(second_post, 0)}")

        # Somme des postes disponibles sur samedi et dimanche
        first_count = sum(posts[day].get(first_post, 0) for day in ["saturday", "sunday_holiday"])
        second_count = sum(posts[day].get(second_post, 0) for day in ["saturday", "sunday_holiday"])

        self.logger.debug(f"Totaux: {first_post}={first_count}, {second_post}={second_count}")

        # Vérifier la compatibilité temporelle
        compatible = any(self._are_posts_compatible(first_post, second_post, day_type) 
                        for day_type in ["saturday", "sunday_holiday"])
        self.logger.debug(f"Compatible: {compatible}")

        if not compatible:
            return 0

        # Pour les combinaisons avec visites
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            result = min(first_count, second_count, 
                        math.floor(min(first_count, second_count) * 0.8))
            self.logger.debug(f"Combinaison avec visite: {result}")
            return result
        
        result = min(first_count, second_count)
        self.logger.debug(f"Combinaison standard: {result}")
        return result

    def _calculate_combination_intervals(self, total_combinations: int, cat_combinations: int) -> Dict:
        """
        Calcule les intervalles pour les combinaisons de postes
        """
        # Pour les médecins temps plein
        full_time_value = total_combinations * (2 / self.total_half_parts)
        full_time_interval = self.round_ideal(total_combinations, 2)

        # Pour les médecins mi-temps
        half_time_value = total_combinations * (1 / self.total_half_parts)
        half_time_interval = self.round_ideal(total_combinations, 1)

        # Pour les CAT
        cat_interval = {
            "min": math.floor(cat_combinations / len(self.cats)) if self.cats else 0,
            "max": math.ceil(cat_combinations / len(self.cats)) if self.cats else 0
        }

        return {
            "full_time": full_time_interval,
            "half_time": half_time_interval,
            "cat": cat_interval
        }
    
    def _calculate_cat_combinations(self, first_post: str, second_post: str, cat_posts: Dict) -> Dict:
        """
        Calcule et détaille les combinaisons possibles pour les CAT par jour.
        """
        self.logger.debug(f"\nCalcul combinaisons CAT pour {first_post}+{second_post}:")
        
        cat_detail = {
            "saturday": 0,
            "sunday_holiday": 0,
            "total": 0
        }
        
        num_cats = len(self.cats)
        if num_cats == 0:
            return cat_detail
            
        for day_type in ["saturday", "sunday_holiday"]:
            # Log des postes disponibles pour CAT
            first_count = cat_posts[day_type].get(first_post, 0) // num_cats
            second_count = cat_posts[day_type].get(second_post, 0) // num_cats
            
            self.logger.debug(f"{day_type} - Postes disponibles:")
            self.logger.debug(f"{first_post}: {first_count} par CAT ({cat_posts[day_type].get(first_post, 0)} total)")
            self.logger.debug(f"{second_post}: {second_count} par CAT ({cat_posts[day_type].get(second_post, 0)} total)")
                
            # Vérifier la compatibilité temporelle
            if self._are_posts_compatible(first_post, second_post, day_type):
                # Calculer les combinaisons possibles
                day_combinations = min(first_count, second_count)
                
                # Pour les visites, réduire de 20%
                if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
                    day_combinations = math.floor(day_combinations * 0.8)
                    
                cat_detail[day_type] = day_combinations * num_cats
                cat_detail["total"] += cat_detail[day_type]
                
                self.logger.debug(f"Combinaisons pour {day_type}: {day_combinations} par CAT ({cat_detail[day_type]} total)")

        self.logger.debug(f"Total combinaisons CAT: {cat_detail['total']}")
        return cat_detail
    
    def _format_interval(self, interval: Dict) -> str:
        """Formate un intervalle pour l'affichage"""
        return f"[{interval['min']:2d}-{interval['max']:2d}]"

    def _get_post_combinations(self) -> Dict[str, List[str]]:
        """
        Retourne les combinaisons de postes organisées par priorité.
        Les combinaisons sont ordonnées selon leur importance stratégique dans le planning.
        """
        return {
            # Priorité 1: Combinaisons stratégiques principales
            "priority1": [
                # Combinaisons St André et Créon soir
                "SASS", "RARS",  # Combinaisons après-midi/soir pour les sites distants
                "SMSA", "RMRA",  # Combinaisons après-midi/soir pour les sites distants
                "MLCA","MMAC"         # Visite longue avec consultation Cenon
                "CMAL","MMAL"         # Consultation Cenon avec visite après-midi
                "HMAL",         # Consultation Beychac avec visite après-midi
                "HAHS",         # Beychac après-midi/soir
                "HMAC",         # Beychac matin avec visite
                "SMAC",         # St André matin avec visite
                "CMAC"          # Cenon matin avec visite
            ],
            
            # Priorité 2: Combinaisons visites-consultations
            "priority2": [
                "MLHA",  # Visite longue avec Beychac après-midi
                "MLSA",  # Visite longue avec St André après-midi
                "MLRA",  # Visite longue avec Créon après-midi
                "MCCA",  # Visite courte avec Cenon après-midi
                "MCHA",  # Visite courte avec Beychac après-midi
                "MCRA",  # Visite courte avec Créon après-midi
                "MCSA"   # Visite courte avec St André après-midi
            ],
            
            # Priorité 3: Combinaisons matin-après-midi visites
            "priority3": [
                "MCAL",  # Visite courte matin avec visite après-midi
                "CMAL",  # Cenon matin avec visite après-midi
                "CACS",  # Cenon matin avec visite après-midi
                "HMAL",  # Beychac matin avec visite après-midi
                "HMAC",  # Beychac matin avec visite courte
                "RMAL",  # Créon matin avec visite après-midi
                "RMAC",  # Créon matin avec visite courte
                "SMAL",  # St André matin avec visite après-midi
                "SMAC"   # St André matin avec visite courte
            ],
            
            # Priorité 5: Combinaisons avec nuit courte (NA)
            "priority5": [
                "SANA",  # St André après-midi + nuit courte
                "RANA",  # Créon après-midi + nuit courte
                "CANA",  # Cenon après-midi + nuit courte
                "HANA"   # Beychac après-midi + nuit courte
            ]
        }
    def _are_posts_compatible(self, post1: str, post2: str, day_type: str) -> bool:
        """Vérifie si deux postes sont compatibles dans le même jour"""
        # Récupérer les détails des postes depuis le PostManager
        post1_details = self.post_manager.get_post_details(post1, day_type)
        post2_details = self.post_manager.get_post_details(post2, day_type)
        
        self.logger.debug(f"\nVérification compatibilité {post1}-{post2} ({day_type}):")
        self.logger.debug(f"Post1 {post1}: {post1_details}")
        self.logger.debug(f"Post2 {post2}: {post2_details}")
        
        if not (post1_details and post2_details):
            self.logger.debug("Un des postes n'a pas de détails")
            return False
            
        # Vérifier le chevauchement des horaires
        compatible = (post1_details["end_time"] <= post2_details["start_time"] or
                    post2_details["end_time"] <= post1_details["start_time"])
        self.logger.debug(f"Compatibilité: {compatible}")
        return compatible
    
    
    def _check_combination_compatibility(self, first_post: str, second_post: str, 
                                    day_type: str, remaining_posts: Dict) -> int:
        """
        Vérifie la compatibilité d'une combinaison de postes et retourne le nombre possible.
        
        Args:
            first_post: Premier poste de la combinaison
            second_post: Second poste de la combinaison
            day_type: Type de jour (saturday/sunday_holiday)
            remaining_posts: Dictionnaire des postes restants disponibles
        
        Returns:
            Nombre de combinaisons possibles
        """
        # Vérifier si les postes existent et sont disponibles
        if first_post not in remaining_posts[day_type] or second_post not in remaining_posts[day_type]:
            return 0
            
        first_count = remaining_posts[day_type][first_post]
        second_count = remaining_posts[day_type][second_post]
        
        # Vérifier la compatibilité temporelle des postes
        if not self._are_posts_compatible(first_post, second_post, day_type):
            return 0
            
        # Pour les combinaisons avec visites (ML, MC, AL, AC)
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            # Réduire le nombre possible pour tenir compte des temps de déplacement
            return min(first_count, second_count, math.floor(min(first_count, second_count) * 0.8))
        
        return min(first_count, second_count)

    def _log_combinations_analysis(self, analysis: Dict):
        """Affiche les résultats de l'analyse des combinaisons"""
        headers = ["Combinaison", "Total", "Plein temps", "Mi-temps", "CAT"]
        format_str = "{:<12} {:<8} {:<15} {:<15} {:<15}"
        
        self.logger.info(format_str.format(*headers))
        self.logger.info("-" * 70)
        
        for priority in ["priority1", "priority2", "priority3", "priority4", "priority5"]:
            if analysis[priority]:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                for combo, data in analysis[priority].items():
                    intervals = data["intervals"]
                    self.logger.info(format_str.format(
                        combo,
                        data["total"],
                        f"[{intervals['full_time']['min']}-{intervals['full_time']['max']}]",
                        f"[{intervals['half_time']['min']}-{intervals['half_time']['max']}]",
                        f"[{intervals['cat']['min']}-{intervals['cat']['max']}]"
                    ))
                    
    
    def analyze_weekday_combinations_distribution(self, adjusted_posts: Dict) -> Dict:
        """Analyse la distribution des combinaisons de postes pour les jours de semaine"""
        self.logger.info("\nANALYSE DES COMBINAISONS SEMAINE")
        self.logger.info("=" * 100)

        # Structure pour les postes disponibles
        available_posts = {
            "weekday": adjusted_posts["weekday"].copy()
        }
        
        # Structure pour les postes CAT
        cat_posts = {"weekday": {}}
        for post_type in ALL_POST_TYPES:
            config = getattr(self.post_configuration, "cat_weekday")
            if hasattr(config, post_type):
                cat_posts["weekday"][post_type] = config[post_type].total * len(self.cats)

        combinations_analysis = {}
        priority_combinations = self._get_weekday_post_combinations()

        # En-tête du tableau
        header = "{:<10} {:<8} {:<25} {:<25} {:<25}".format(
            "Combo", "Total", "Plein temps (moy)", "Mi-temps (moy)", "CAT (moy)"
        )
        self.logger.info("\n" + header)
        self.logger.info("-" * len(header))

        # Traiter les combinaisons par priorité
        for priority, combinations in priority_combinations.items():
            if combinations:
                self.logger.info(f"\nPriorité {priority[-1]}:")
                priority_results = {}

                for combo in combinations:
                    first_post, second_post = combo[:2], combo[2:]
                    
                    # Calcul des combinaisons possibles pour médecins
                    med_combinations = self._calculate_weekday_possible_combinations(
                        first_post, second_post, available_posts
                    )
                    
                    # Calcul des combinaisons possibles pour CAT
                    cat_combinations = self._calculate_weekday_possible_combinations(
                        first_post, second_post, cat_posts
                    )

                    if med_combinations > 0 or cat_combinations > 0:
                        intervals = self._calculate_combination_intervals(
                            med_combinations,
                            cat_combinations
                        )
                        priority_results[combo] = {
                            "total": med_combinations,
                            "cat_total": cat_combinations,
                            "intervals": intervals
                        }

                        # Dans l'affichage des résultats
                        self.logger.info(
                            "{:<10} {:<8d} {:<25} {:<25} {:<10}".format(
                                combo,
                                med_combinations,
                                f"{self._format_interval(intervals['full_time'])}",
                                f"{self._format_interval(intervals['half_time'])}",
                                f"{intervals['cat']['total']}" if self.cats else "N/A"
                            )

                            )
                        

                if priority_results:
                    combinations_analysis[priority] = priority_results

        return combinations_analysis

    def _get_weekday_post_combinations(self) -> Dict[str, List[str]]:
        """
        Retourne les combinaisons de postes pour les jours de semaine.
        Les combinaisons sont organisées par priorité.
        """
        return {
            "priority1": [
                "MLCA", "MLHA",  # Visite longue avec consultations après-midi
                "MLSA", "MLRA", 
                "MCCA", "MCHA",  # Visite courte avec consultations après-midi
                "MCRA", "MCSA"
            
            ],
            "priority2": [
                "CMCA", "CACS","MMCA",  # Cenon matin-après-midi et après-midi-soir
                "HMHA", "HAHS",  # Beychac matin-après-midi et après-midi-soir
                "SMSA", "SASS",  # St André matin-après-midi et après-midi-soir
                "RMRA", "RARS"   # Créon matin-après-midi et après-midi-soir
            ],
            "priority3": [
                "MCAL", "CMAL", "MMAC", # Combinaisons avec visites après-midi
                "HMAL", "HMAC", "MMAL", 
                "RMAL", "RMAC",
                "SMAL", "SMAC"
            ],
            "priority5": [
                "SANA", "RANA",  # Combinaisons avec nuit courte
                "CANA", "HANA"
            ]
        }

    def _calculate_weekday_possible_combinations(self, first_post: str, second_post: str, 
                                            posts: Dict[str, Dict[str, int]]) -> int:
        """
        Calcule le nombre de combinaisons possibles entre deux postes pour les jours de semaine
        """
        # Obtenir le nombre de postes disponibles
        first_count = posts["weekday"].get(first_post, 0)
        second_count = posts["weekday"].get(second_post, 0)

        # Vérifier la compatibilité temporelle
        if not self._are_posts_compatible(first_post, second_post, "weekday"):
            return 0

        # Ajustement pour les visites
        if any(p.startswith(('ML', 'MC', 'AL', 'AC')) for p in (first_post, second_post)):
            return min(first_count, second_count, 
                    math.floor(min(first_count, second_count) * 0.8))
        
        return min(first_count, second_count)

# core/Analyzer/combinations_analyzer.py

# core/Analyzer/combinations_analyzer.py

from typing import Dict, List, Tuple, Optional
from datetime import date, timedelta
from core.Constantes.models import (Doctor, CAT, WEEKEND_COMBINATIONS, 
                        WEEKDAY_COMBINATIONS, ALL_POST_TYPES)
from core.Analyzer.availability_matrix import AvailabilityMatrix
import logging

class CombinationsAnalyzer:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], 
                availability_matrix: AvailabilityMatrix, 
                pre_analysis_results: Dict):
        self.doctors = doctors
        self.cats = cats
        self.availability_matrix = availability_matrix
        self.pre_analysis_results = pre_analysis_results
        self.logger = logging.getLogger(__name__)
        
        # Vérification détaillée de la structure pre_analysis_results
        self.logger.info("\nVérification structure pre_analysis_results:")
        if "ideal_distribution" in pre_analysis_results:
            first_doctor = next(iter(pre_analysis_results["ideal_distribution"].values()))
            if "weekday_groups" in first_doctor:
                self.logger.info("Structure weekday_groups pour le premier médecin:")
                for group, value in first_doctor["weekday_groups"].items():
                    self.logger.info(f"- {group}: {value}")
            else:
                self.logger.error("weekday_groups non trouvé dans ideal_distribution")
        else:
            self.logger.error("ideal_distribution non trouvé dans pre_analysis_results")

    def analyze(self) -> Dict:
        """Point d'entrée principal de l'analyse des combinaisons."""
        self.logger.info("\nANALYSE GLOBALE DES COMBINAISONS")
        self.logger.info("=" * 100)

        # Ajout de la vérification des groupes disponibles
        if "ideal_distribution" in self.pre_analysis_results:
            first_doctor = next(iter(self.pre_analysis_results["ideal_distribution"].values()))
            self.logger.info("Groupes disponibles dans weekday_groups:")
            for group in first_doctor.get("weekday_groups", {}):
                self.logger.info(f"- {group}")

        analysis_results = {
            "weekend": self.analyze_weekend_combinations(),
            "weekday": self.analyze_weekday_combinations()
        }

        self._log_summary(analysis_results)
        return analysis_results

    def analyze_weekend_combinations(self) -> Dict:
        """Analyse toutes les combinaisons weekend."""
        self._log_analysis_header("weekend")
        results = {}
        
        for combo in WEEKEND_COMBINATIONS:
            results[combo] = self._analyze_combination(combo, "weekend")
            self._log_combination_analysis(combo, results[combo], "weekend")
        
        return results

    def analyze_weekday_combinations(self) -> Dict:
        """Analyse toutes les combinaisons semaine."""
        self._log_analysis_header("weekday")
        results = {}
        
        for combo in WEEKDAY_COMBINATIONS:
            results[combo] = self._analyze_combination(combo, "weekday")
            self._log_combination_analysis(combo, results[combo], "weekday")
        
        return results

    def _analyze_combination(self, combo: str, day_type: str) -> Dict:
        """Analyse détaillée d'une combinaison spécifique."""
        eligible_doctors = self._get_eligible_doctors(combo, day_type)
        groups = self._get_combo_groups(combo, day_type)  # Ajout du day_type ici
        posts = self._get_combo_posts(combo)
        requirements = self._get_posts_requirements(combo, day_type)
        
        ratio = self._calculate_combination_ratio(combo, len(eligible_doctors), day_type)
        status = self._determine_combination_status(ratio)
        
        return {
            "eligible_doctors": [doc.name for doc in eligible_doctors],
            "groups": groups,
            "posts": posts,
            "requirements": requirements,
            "ratio": ratio,
            "status": status
        }

    def _get_eligible_doctors(self, combo: str, day_type: str) -> List[Doctor]:
        """Retourne la liste des médecins pouvant prendre cette combinaison."""
        return [
            doctor for doctor in self.doctors
            if self._can_doctor_take_combo(doctor, combo, day_type)
        ]

    def _can_doctor_take_combo(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """Vérifie si un médecin peut prendre une combinaison."""
        groups = self._get_combo_groups(combo, day_type)  # Ajout day_type
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]

        for group in groups:
            if day_type == "weekend":
                max_allowed = doctor_limits["weekend_groups"][group]["max"]
                current = doctor.weekend_combo_counts.get(group, 0)
            else:
                max_allowed = doctor_limits["weekday_groups"][group]["max"]
                current = doctor.weekday_combo_counts.get(group, 0)
                
            if current >= max_allowed:
                return False
                
        return self._check_doctor_availability(doctor, combo, day_type)

    def _check_doctor_availability(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """Vérifie les disponibilités du médecin pour la combinaison."""
        post1, post2 = self._get_combo_posts(combo)
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]
        
        if day_type == "weekend":
            max_post1 = doctor_limits["weekend_posts"].get(post1, {}).get("max", 0)
            max_post2 = doctor_limits["weekend_posts"].get(post2, {}).get("max", 0)
        else:
            max_post1 = doctor_limits["weekday_posts"].get(post1, {}).get("max", 0)
            max_post2 = doctor_limits["weekday_posts"].get(post2, {}).get("max", 0)
            
        return max_post1 > 0 and max_post2 > 0

    def _check_group_limits(self, doctor: Doctor, combo: str, day_type: str) -> bool:
        """
        Vérifie les limites de groupes pour le médecin.
        """
        groups = self._get_combo_groups(combo, day_type)
        doctor_limits = self.pre_analysis_results["ideal_distribution"][doctor.name]
        
        for group in groups:
            try:
                if day_type == "weekend":
                    current = doctor.weekend_combo_counts.get(group, 0)
                    max_allowed = doctor_limits["weekend_groups"][group]["max"]
                else:
                    current = doctor.weekday_combo_counts.get(group, 0)
                    # Si le groupe n'existe pas ou a une limite de 0, 
                    # la combinaison n'est pas possible
                    if group not in doctor_limits["weekday_groups"]:
                        max_allowed = 0
                    else:
                        max_allowed = doctor_limits["weekday_groups"].get(group, {}).get("max", 0)

                # Si max_allowed est 0, cette combinaison n'est pas possible
                if max_allowed == 0:
                    return False
                    
                if current >= max_allowed:
                    return False
                    
            except KeyError:
                # Si une clé n'existe pas, c'est que le groupe n'est pas disponible
                self.logger.debug(f"Groupe {group} non disponible pour {doctor.name}")
                return False
                    
        return True

    def _get_combo_groups(self, combo: str, day_type: str) -> List[str]:
        """
        Identifie les groupes impactés par une combinaison selon le type de jour.
        """
        groups = set()
        first_post = combo[:2]
        second_post = combo[2:]
        
        if day_type == "weekend":
            # Mapping des postes vers les groupes weekend
            WEEKEND_MAPPING = {
                "ML": "VmS",
                "MC": "VmD",
                "CM": "CmS",
                "HM": "CmS",
                "SM": "CmD",
                "RM": "CmD",
                "CA": "CaSD",
                "HA": "CaSD",
                "SA": "CaSD",
                "RA": "CaSD",
                "CS": "CsSD",
                "HS": "CsSD",
                "SS": "CsSD",
                "RS": "CsSD",
                "AL": "VaSD",
                "AC": "VaSD"
            }
            
            if first_post in WEEKEND_MAPPING:
                groups.add(WEEKEND_MAPPING[first_post])
            if second_post in WEEKEND_MAPPING:
                groups.add(WEEKEND_MAPPING[second_post])
                
        else:
            # Mapping des postes vers les groupes semaine
            WEEKDAY_MAPPING = {
                "MM": "XmM",
                "SM": "XmM",
                "RM": "XmM",
                "CM": "XM",
                "HM": "XM",
                "CA": "XA",
                "HA": "XA",
                "SA": "XA",
                "RA": "XA",
                "CS": "XS",
                "HS": "XS",
                "SS": "XS",
                "RS": "XS",
                "ML": "Vm",
                "MC": "Vm",
            }
            
            if first_post in WEEKDAY_MAPPING:
                groups.add(WEEKDAY_MAPPING[first_post])
            if second_post in WEEKDAY_MAPPING:
                groups.add(WEEKDAY_MAPPING[second_post])

        if not groups:
            self.logger.warning(f"Aucun groupe identifié pour la combinaison {combo} ({day_type})")
        
        return list(groups)
    def _get_combo_posts(self, combo: str) -> Tuple[str, str]:
        """Sépare une combinaison en ses deux postes."""
        return combo[:2], combo[2:]

    def _get_posts_requirements(self, combo: str, day_type: str) -> Dict:
        """Récupère les besoins en postes pour cette combinaison."""
        post1, post2 = self._get_combo_posts(combo)
        if day_type == "weekend":
            return {
                post1: self.pre_analysis_results["weekend_posts"].get(post1, 0),
                post2: self.pre_analysis_results["weekend_posts"].get(post2, 0)
            }
        return {
            post1: self.pre_analysis_results["weekday_posts"].get(post1, 0),
            post2: self.pre_analysis_results["weekday_posts"].get(post2, 0)
        }

    def _calculate_combination_ratio(self, combo: str, eligible_count: int, day_type: str) -> float:
        """Calcule le ratio de disponibilité/besoin pour une combinaison."""
        requirements = self._get_posts_requirements(combo, day_type)
        groups = self._get_combo_groups(combo, day_type)  # Ajout day_type
        needed = max(requirements.values()) if requirements else 0
        return eligible_count / needed if needed > 0 else float('inf')

    def _determine_combination_status(self, ratio: float) -> str:
        """Détermine le statut d'une combinaison basé sur son ratio."""
        if ratio >= 1.2:
            return "OK"
        elif ratio >= 0.8:
            return "ATTENTION"
        return "CRITIQUE"

    def _log_analysis_header(self, day_type: str):
        """Affiche l'en-tête de l'analyse."""
        self.logger.info(f"\nANALYSE DES COMBINAISONS {day_type.upper()}")
        self.logger.info("=" * 100)
        self.logger.info("{:<8} {:<15} {:<25} {:<12} {:<10}".format(
            "COMBO", "ÉLIGIBLES", "GROUPES", "RATIO", "STATUT"
        ))
        self.logger.info("-" * 80)

    def _log_combination_analysis(self, combo: str, analysis: Dict, day_type: str):
        """Log les résultats d'analyse d'une combinaison."""
        self.logger.info("{:<8} {:<15} {:<25} {:<12.2f} {:<10}".format(
            combo,
            f"{len(analysis['eligible_doctors'])}/{len(self.doctors)}",
            "+".join(analysis['groups']),
            analysis['ratio'],
            analysis['status']
        ))


    def _log_summary(self, all_analysis: Dict):
        """Affiche un résumé de l'analyse complète."""
        self.logger.info("\nRÉSUMÉ DE L'ANALYSE DES COMBINAISONS")
        self.logger.info("=" * 100)
        
        for day_type, combinations in all_analysis.items():
            critical = sum(1 for c in combinations.values() if c['status'] == "CRITIQUE")
            attention = sum(1 for c in combinations.values() if c['status'] == "ATTENTION")
            ok = sum(1 for c in combinations.values() if c['status'] == "OK")
            
            self.logger.info(f"\n{day_type.upper()}:")
            self.logger.info(f"Critiques  : {critical}")
            self.logger.info(f"Attention  : {attention}")
            self.logger.info(f"OK        : {ok}")
            
            

# core/Analyzer/availability_matrix.py

# core/Analyzer/availability_matrix.py

from datetime import date, timedelta
from typing import Dict, List, Tuple, Optional, Union
from core.Constantes.models import Doctor, CAT, Planning, TimeSlot, DayPlanning
from workalendar.europe import France
import logging

logger = logging.getLogger(__name__)

class AvailabilityMatrix:
    def __init__(self, start_date: date = None, end_date: date = None, doctors: List[Doctor] = None, cats: List[CAT] = None):
        self.start_date = start_date
        self.end_date = end_date
        self.doctors = doctors or []
        self.cats = cats or []
        self.cal = France()
        self.availability_matrix = {}
        self.critical_periods = []
        self._initialize_matrix()  # Renommé de init_matrix à _initialize_matrix
        
    def _initialize_matrix(self):  # Correction du nom de la méthode
        """Initialise la matrice de disponibilité"""
        self.availability_matrix = {
            person.name: {} for person in self.doctors + self.cats
        }
        
        if not (self.start_date and self.end_date):
            return

        # Initialiser la matrice avec les dates
        for person_name in self.availability_matrix:
            current_date = self.start_date
            while current_date <= self.end_date:
                self.availability_matrix[person_name][current_date] = {
                    1: True,  # Matin
                    2: True,  # Après-midi
                    3: True   # Soir/Nuit
                }
                current_date += timedelta(days=1)

        self._apply_desiderata()
        self._identify_critical_periods()

    def _apply_desiderata(self):
        """Applique les desiderata à la matrice"""
        if not (self.start_date and self.end_date):
            return
            
        for person in self.doctors + self.cats:
            for des in person.desiderata:
                current_date = max(des.start_date, self.start_date)
                end_date = min(des.end_date, self.end_date)
                while current_date <= end_date:
                    if current_date in self.availability_matrix[person.name]:
                        self.availability_matrix[person.name][current_date][des.period] = False
                    current_date += timedelta(days=1)

    def _identify_critical_periods(self):
        """Identifie les périodes critiques (≥35% d'indisponibilité)"""
        import random  # Ajouter en haut du fichier si pas déjà présent
        
        self.critical_periods = []
        
        if not (self.start_date and self.end_date):
            return

        current_date = self.start_date
        while current_date <= self.end_date:
            for period in [1, 2, 3]:  # Matin, Après-midi, Soir
                # Calculer le nombre de personnes disponibles
                available_count = sum(
                    1 for person in self.availability_matrix 
                    if current_date in self.availability_matrix[person] and 
                    self.availability_matrix[person][current_date][period]
                )
                
                total_personnel = len(self.doctors) + len(self.cats)
                if total_personnel == 0:
                    continue
                    
                # Calculer le pourcentage d'indisponibilité
                unavailability_percentage = ((total_personnel - available_count) / total_personnel) * 100
                
                # Ajouter si indisponibilité ≥ 35%
                if unavailability_percentage >= 35:
                    self.critical_periods.append((
                        current_date,
                        period,
                        unavailability_percentage,
                        available_count
                    ))
                    
            current_date += timedelta(days=1)

        # Trier d'abord par pourcentage d'indisponibilité (du plus critique au moins critique)
        self.critical_periods.sort(key=lambda x: (-x[2], x[3]))  # -x[2] pour ordre décroissant
        
        # Regrouper les périodes similaires (marge de 5%)
        if self.critical_periods:
            groups = []
            current_group = [self.critical_periods[0]]
            
            for i in range(1, len(self.critical_periods)):
                current = self.critical_periods[i]
                previous = current_group[0]
                
                if abs(current[2] - previous[2]) <= 5:  # Marge de 5%
                    current_group.append(current)
                else:
                    if len(current_group) > 1:
                        random.shuffle(current_group)
                    groups.extend(current_group)
                    current_group = [current]
            
            # Ne pas oublier le dernier groupe
            if len(current_group) > 1:
                random.shuffle(current_group)
            groups.extend(current_group)
            
            self.critical_periods = groups

        logger.debug(f"Périodes critiques identifiées : {len(self.critical_periods)}")
        for date, period, unavail_pct, available in self.critical_periods:
            period_name = {1: "Matin", 2: "Après-midi", 3: "Soir"}[period]
          

    def update_matrix(self, start_date: date, end_date: date):
        """Met à jour la matrice avec de nouvelles dates"""
        self.start_date = start_date
        self.end_date = end_date
        self._initialize_matrix()  # Utilisation du nouveau nom

    def get_period_availability(self, person: str, date: date, period: Union[int, str]) -> bool:
        """Vérifie la disponibilité d'une personne pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return (self.availability_matrix.get(person, {})
                .get(date, {})
                .get(period, False))

    def get_period_from_text(self, period_text: str) -> int:
        """Convertit une période textuelle en numéro"""
        period_mapping = {
            "morning": 1,
            "afternoon": 2,
            "evening": 3,
            "M": 1,
            "AM": 2,
            "S": 3,
        }
        return period_mapping.get(period_text, 1)

    def get_available_personnel(self, date: date, period: Union[int, str]) -> List[str]:
        """Retourne la liste du personnel disponible pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return [
            person for person in self.availability_matrix 
            if date in self.availability_matrix[person] and 
            self.availability_matrix[person][date][period]
        ]

    def update_availability(self, person: str, date: date, period: int, available: bool):
        """Met à jour la disponibilité"""
        try:
            if (person in self.availability_matrix and 
                date in self.availability_matrix[person]):
                self.availability_matrix[person][date][period] = available
                self._identify_critical_periods()  # Mettre à jour les périodes critiques
        except Exception as e:
            logger.error(f"Erreur mise à jour disponibilité pour {person} le {date}: {e}")
        
    def get_period_from_slot(self, slot: TimeSlot) -> int:
        """Détermine la période d'un slot"""
        start_hour = slot.start_time.hour
        if 7 <= start_hour < 13:
            return 1  # Matin
        elif 13 <= start_hour < 18:
            return 2  # Après-midi
        else:
            return 3  # Soir/Nuit

    def get_available_personnel(self, date: date, period: Union[int, str]) -> List[str]:
        """Retourne la liste du personnel disponible pour une période"""
        if isinstance(period, str):
            period = self.get_period_from_text(period)
        return [
            person for person in self.availability_matrix 
            if self.availability_matrix[person][date][period]
        ]


    def _update_critical_periods(self, date: date, period: int):
        """Met à jour les périodes critiques après une modification"""
        # Recalculer la disponibilité pour cette période
        available_count = sum(
            1 for person in self.availability_matrix 
            if self.availability_matrix[person][date][period]
        )
        
        # Mettre à jour la liste des périodes critiques
        self.critical_periods = [
            (d, p, c) for d, p, c in self.critical_periods 
            if d != date or p != period
        ]
        
        total_personnel = len(self.doctors) + len(self.cats)
        if available_count < total_personnel * 0.5:
            self.critical_periods.append((date, period, available_count))
            self.critical_periods.sort(key=lambda x: x[2])


   
    

# gui/main_window.py


# © 2024 HILAL Arkane. Tous droits réservés.
# .gui/main_window.py
from PyQt6.QtWidgets import QMainWindow, QTabWidget, QPushButton, QVBoxLayout, QWidget
from PyQt6.QtCore import Qt, QDate, QSize
from PyQt6.QtGui import QIcon
from .personnel_management import PersonnelManagementWidget
from .planning_view import PlanningViewWidget
from .desiderata_management import DesiderataManagementWidget
from .post_configuration import PostConfigurationWidget
from core.Constantes.data_persistence import DataPersistence
from .stats_view import StatsView
from .doctor_planning_view import DoctorPlanningView
from .planning_comparison_view import PlanningComparisonView
from .detached_stats_window import DetachedStatsWindow
from .planning_management import PlanningManagementWidget
from core.utils import resource_path



class MainWindow(QMainWindow):
    def __init__(self, doctors, cats, post_configuration):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.data_persistence = DataPersistence()
        self.detached_stats_window = None
        self.init_ui()
        
        self.planning_tab.dates_changed.connect(self.on_planning_dates_changed)

    def init_ui(self):
        self.setWindowTitle('Planificateur SOS Médecins')
        self.setGeometry(100, 100, 1200, 800)

        self.tab_widget = QTabWidget()
        self.tab_widget.setIconSize(QSize(32, 32))  # Définir la taille des icônes pour tous les onglets
        self.setCentralWidget(self.tab_widget)

        # Onglet Planning (créé en premier pour pouvoir accéder aux dates)
        self.planning_tab = PlanningViewWidget(self.doctors, self.cats, self.post_configuration, self)
        
        # Onglet Gestion du personnel
        self.personnel_tab = PersonnelManagementWidget(self.doctors, self.cats, self.post_configuration, self)
        self.tab_widget.addTab(self.personnel_tab, self.create_tab_icon("icons/personnel.png"), "Gestion du personnel")

        # Onglet Gestion des desiderata
        self.desiderata_tab = DesiderataManagementWidget(self.doctors, self.cats, self.planning_tab.start_date.date().toPyDate(), self.planning_tab.end_date.date().toPyDate(), self)
        self.tab_widget.addTab(self.desiderata_tab, self.create_tab_icon("icons/desiderata.png"), "Gestion des desiderata")

        # Ajout de l'onglet Planning
        self.tab_widget.addTab(self.planning_tab, self.create_tab_icon("icons/planning.png"), "Planning")

        # Onglet Planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        self.tab_widget.addTab(self.doctor_planning_view, self.create_tab_icon("icons/doctor_planning.png"), "Planning par médecin")

        # Onglet Statistiques
        self.stats_tab = StatsView(doctors=self.doctors, cats=self.cats)
        stats_container = QWidget()
        stats_layout = QVBoxLayout(stats_container)
        detach_button = QPushButton("Détacher les statistiques")
        detach_button.clicked.connect(self.detach_stats)
        stats_layout.addWidget(detach_button)
        stats_layout.addWidget(self.stats_tab)
        self.stats_index = self.tab_widget.addTab(stats_container, self.create_tab_icon("icons/statistics.png"), "Statistiques")

        # Onglet Comparaison des plannings
        self.comparison_view = PlanningComparisonView(None, self.doctors, self.cats, self)
        self.tab_widget.addTab(self.comparison_view, self.create_tab_icon("icons/comparaison.png"), "Comparaison des plannings")

        # Onglet Exporter
        self.planning_management_tab = PlanningManagementWidget(self)
        self.tab_widget.addTab(self.planning_management_tab, self.create_tab_icon("icons/export.png"), "Exporter")

        # Mettre à jour les dates dans PostConfigurationWidget
        start_date = self.planning_tab.start_date.date().toPyDate()
        end_date = self.planning_tab.end_date.date().toPyDate()
        self.personnel_tab.post_config_tab.update_dates(start_date, end_date)

        self.planning_tab.dates_changed.connect(self.on_planning_dates_changed)

    def create_tab_icon(self, icon_path, size=32):
        return QIcon(resource_path(icon_path))

   
    def on_planning_dates_changed(self, start_date, end_date):
        self.desiderata_tab.sync_dates_from_planning(start_date, end_date)


    def closeEvent(self, event):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        event.accept()

    def update_post_configuration(self, new_post_configuration):
        """Met à jour la configuration des postes"""
        try:
            self.post_configuration = new_post_configuration
            self.planning_tab.update_post_configuration(new_post_configuration)
            self.personnel_tab.post_config_tab.update_configuration(new_post_configuration)
            self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
            return True
        except Exception as e:
            self.logger.error(f"Erreur lors de la mise à jour de la configuration : {e}", exc_info=True)
            return False

    def update_data(self):
        self.personnel_tab.update_tables()
        self.planning_tab.update_data(self.doctors, self.cats, self.post_configuration)
        
        if hasattr(self.planning_tab, 'planning') and self.planning_tab.planning:
            start_date = self.planning_tab.planning.start_date
            end_date = self.planning_tab.planning.end_date
            
            # Mettre à jour les dates dans PlanningViewWidget
            self.planning_tab.start_date.setDate(QDate(start_date))
            self.planning_tab.end_date.setDate(QDate(end_date))
            
            # Mettre à jour les dates dans DesiderataManagementWidget
            self.desiderata_tab.sync_dates_from_planning(start_date, end_date)
            
            self.update_stats_view()
            self.comparison_view.planning = self.planning_tab.planning
            self.comparison_view.update_comparison(preserve_selection=True)
            self.doctor_planning_view.planning = self.planning_tab.planning
            self.doctor_planning_view.update_table()
        else:
            # Réinitialiser les vues si aucun planning n'est chargé
            self.stats_tab.clear_stats()
            self.comparison_view.reset_view()
            self.doctor_planning_view.clear_view()

        self.desiderata_tab.update_stats()
        self.personnel_tab.post_config_tab.update_configuration(self.post_configuration)
    def update_stats_view(self):
        if self.detached_stats_window:
            self.detached_stats_window.update_stats()
        else:
            self.stats_tab.update_stats(self.planning_tab.planning, self.doctors, self.cats)

    def save_data(self):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        self.planning_management_tab.update_planning_list()
    def detach_stats(self):
        if not self.detached_stats_window:
            self.tab_widget.removeTab(self.stats_index)
            self.detached_stats_window = DetachedStatsWindow(self)
            self.detached_stats_window.show()
            # Assurez-vous que les statistiques sont à jour lors du détachement
            self.update_stats_view()

    def reattach_stats(self):
        if self.detached_stats_window:
            self.detached_stats_window.close()
            self.detached_stats_window = None
            stats_container = QWidget()
            stats_layout = QVBoxLayout(stats_container)
            detach_button = QPushButton("Détacher les statistiques")
            detach_button.clicked.connect(self.detach_stats)
            stats_layout.addWidget(detach_button)
            stats_layout.addWidget(self.stats_tab)
            self.stats_index = self.tab_widget.insertTab(self.stats_index, stats_container, "Statistiques")
            self.tab_widget.setCurrentIndex(self.stats_index)
            # Assurez-vous que les statistiques sont à jour lors du rattachement
            self.update_stats_view()
            

    def reset_all_views(self):
        # Réinitialiser la vue de comparaison
        self.comparison_view.reset_view()
        
        # Réinitialiser la vue des statistiques
        self.stats_tab.clear_stats()
        
        # Réinitialiser la vue du planning par médecin
        self.doctor_planning_view.clear_view()
        
        # Mettre à jour les autres vues si nécessaire
        self.update_data()

# gui/stats_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/stats_view.py

import logging
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QTabWidget, QPushButton
from PyQt6.QtGui import QColor, QBrush, QFont
from PyQt6.QtCore import Qt
from core.Constantes.models import ALL_POST_TYPES
from core.Constantes.data_persistence import DataPersistence
from gui.post_configuration import PostConfig   
import numpy as np
from datetime import datetime, time, date
from typing import List, Dict, Optional, Tuple, Union
from PyQt6.QtCore import QPropertyAnimation, QEasingCurve, QTimer, Qt, QSize
from PyQt6.QtWidgets import QLabel
from PyQt6.QtGui import QPainter, QFontMetrics
from workalendar.europe import France
# Initialiser le logger
logger = logging.getLogger(__name__)


class StatsView(QWidget):
    def __init__(self, planning=None, doctors=None, cats=None):
        super().__init__()
        self.planning = planning
        self.doctors = doctors
        self.cats = cats
        self.data_persistence = DataPersistence()
        self.custom_posts = self.load_custom_posts()
        
        # Initialisation des attributs pour la gestion de l'expansion
        self.expanded_group = None
        self.component_columns = {}  # Déplacé ici depuis init_ui
        
        # Définition des groupes de postes comme attribut de classe
        self.post_groups = {
            'matin': {
                'label': 'Matin',
                'posts': ['MM', 'CM', 'HM', 'SM', 'RM', 'ML', 'MC'],
                'color': QColor('#E3F2FD')
            },
            'apresMidi': {
                'label': 'Après-midi',
                'posts': ['CA', 'HA', 'SA', 'RA', 'AL', 'AC'],
                'color': QColor('#FFF3E0')
            },
            'soirNuit': {
                'label': 'Soir/Nuit',
                'posts': ['CS', 'HS', 'SS', 'RS', 'NL', 'NM', 'NA', 'NC'],
                'color': QColor('#EDE7F6')
            }
        }
        
        # Ajout des postes personnalisés aux groupes
        for post_name, custom_post in self.custom_posts.items():
            start_hour = custom_post.start_time.hour
            if 7 <= start_hour < 13:
                self.post_groups['matin']['posts'].append(post_name)
            elif 13 <= start_hour < 18:
                self.post_groups['apresMidi']['posts'].append(post_name)
            else:
                self.post_groups['soirNuit']['posts'].append(post_name)
        
        self.current_filter = 'all'  # Pour suivre le filtre actif
        
        # Initialisation des structures pour les groupes
        self.group_details = {
            'NLw': {
                'components': ['NLv', 'NLs', 'NLd'],
                'description': 'Nuits longues weekend'
            },
            'NAMw': {
                'components': ['NAs', 'NAd', 'NMs', 'NMd'],
                'description': 'Nuits courtes et moyennes weekend'
            },
            'VmS': {
                'components': ['ML', 'MC'],
                'description': 'Visites matin samedi'
            },
            'VmD': {
                'components': ['ML', 'MC'],
                'description': 'Visites matin dimanche'
            },
            'VaSD': {
                'components': ['AL', 'AC'],
                'description': 'Visites après-midi weekend'
            },
            'CmS': {
                'components': ['CM', 'HM', 'SM', 'RM'],
                'description': 'Consultations matin samedi'
            },
            'CmD': {
                'components': ['CM', 'HM', 'SM', 'RM'],
                'description': 'Consultations matin dimanche'
            },
            'CaSD': {
                'components': ['CA', 'HA', 'SA', 'RA'],
                'description': 'Consultations après-midi weekend'
            },
            'CsSD': {
                'components': ['CS', 'HS', 'SS', 'RS'],
                'description': 'Consultations soir weekend'
            }
        }
        
        self.init_ui()

    def init_ui(self):
        """Initialise l'interface utilisateur"""
        layout = QVBoxLayout(self)
        
        # Création des tableaux
        self.stats_table = QTableWidget()
        self.weekend_stats_table = QTableWidget()
        self.detailed_stats_table = QTableWidget()
        self.weekly_stats_table = QTableWidget()
        self.weekday_group_stats_table = QTableWidget()
        
        # Création des boutons de filtrage
        filter_widget = QWidget()
        filter_layout = QHBoxLayout(filter_widget)
        filter_layout.setContentsMargins(0, 0, 0, 10)
        
        self.filter_buttons = {}
        for group_key, group in self.post_groups.items():
            btn = QPushButton(group['label'])
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, k=group_key: self.apply_filter(k))
            filter_layout.addWidget(btn)
            self.filter_buttons[group_key] = btn
        
        all_btn = QPushButton("Tous")
        all_btn.setCheckable(True)
        all_btn.setChecked(True)
        all_btn.clicked.connect(lambda: self.apply_filter('all'))
        filter_layout.addWidget(all_btn)
        self.filter_buttons['all'] = all_btn
        
        layout.addWidget(filter_widget)
        
        # Création des onglets
        tab_widget = QTabWidget()
        
        def setup_table_in_tab(table, title):
            widget = QWidget()
            layout = QVBoxLayout(widget)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.addWidget(table)
            tab_widget.addTab(widget, title)
            
            # Configuration commune des tableaux
            table.setHorizontalScrollMode(QTableWidget.ScrollMode.ScrollPerPixel)
            table.setVerticalScrollMode(QTableWidget.ScrollMode.ScrollPerPixel)
            table.horizontalHeader().setFixedHeight(30)
            table.verticalHeader().setVisible(False)
        
        # Configuration de chaque tableau dans son onglet
        setup_table_in_tab(self.stats_table, "Statistiques générales")
        setup_table_in_tab(self.weekend_stats_table, "Statistiques weekend")
        setup_table_in_tab(self.detailed_stats_table, "Groupe Weekend")
        setup_table_in_tab(self.weekly_stats_table, "Statistiques semaine")
        setup_table_in_tab(self.weekday_group_stats_table, "Groupes semaine")
        
        layout.addWidget(tab_widget)
        
        # Configuration de la synchronisation du scroll
        self.setup_scroll_sync()
        
        if self.planning and self.doctors and self.cats:
            self.update_stats()
        else:
            self.set_empty_table_message(self.stats_table)
            self.set_empty_table_message(self.detailed_stats_table)
            self.set_empty_table_message(self.weekly_stats_table)
            self.set_empty_table_message(self.weekend_stats_table)
            self.set_empty_table_message(self.weekday_group_stats_table)
    def apply_filter(self, group_key):
        """Applique le filtre à tous les tableaux"""
        # Mise à jour des boutons
        self.current_filter = group_key
        for key, btn in self.filter_buttons.items():
            btn.setChecked(key == group_key)
        
        # Application du filtre à chaque tableau
        self._apply_filter_to_table(self.stats_table)
        self._apply_filter_to_table(self.weekend_stats_table)
        self._apply_filter_to_table(self.weekly_stats_table)
        self._apply_filter_to_table(self.detailed_stats_table)
        self._apply_filter_to_table(self.weekday_group_stats_table)

    def load_custom_posts(self):
        """Charge les postes personnalisés"""
        custom_posts_data = self.data_persistence.load_custom_posts()
        logger.info(f"Chargement des postes personnalisés: {custom_posts_data}")
        if custom_posts_data:
            try:
                if isinstance(next(iter(custom_posts_data.values())), dict):
                    from core.Constantes.custom_post import CustomPost
                    self.custom_posts = {
                        name: CustomPost.from_dict(data) 
                        for name, data in custom_posts_data.items()
                    }
                    logger.info(f"Postes personnalisés chargés: {list(self.custom_posts.keys())}")
                else:
                    self.custom_posts = custom_posts_data
                # Mise à jour des groupes après chargement
                self.update_post_groups()
                return self.custom_posts
            except Exception as e:
                logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")
        return {}
    
    def update_post_groups(self):
        """Met à jour les groupes avec les postes personnalisés"""
        # Réinitialisation des listes de postes dans les groupes
        self.post_groups = {
            'matin': {
                'label': 'Matin',
                'posts': ['MM', 'CM', 'HM', 'SM', 'RM', 'ML', 'MC'],
                'color': QColor('#E3F2FD')
            },
            'apresMidi': {
                'label': 'Après-midi',
                'posts': ['CA', 'HA', 'SA', 'RA', 'AL', 'AC','CT'],
                'color': QColor('#FFF3E0')
            },
            'soirNuit': {
                'label': 'Soir/Nuit',
                'posts': ['CS', 'HS', 'SS', 'RS', 'NL', 'NM', 'NA', 'NC'],
                'color': QColor('#EDE7F6')
            }
        }

        # Ajout des postes personnalisés aux groupes appropriés
        logger.info("Mise à jour des groupes avec les postes personnalisés")
        for post_name, custom_post in self.custom_posts.items():
            logger.info(f"Traitement du poste {post_name}")
            start_hour = custom_post.start_time.hour
            if 7 <= start_hour < 13:
                self.post_groups['matin']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe matin")
            elif 13 <= start_hour < 18:
                self.post_groups['apresMidi']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe après-midi")
            else:
                self.post_groups['soirNuit']['posts'].append(post_name)
                logger.info(f"- Ajouté au groupe soir/nuit")

    def get_all_post_types(self):
        """Retourne tous les types de postes standards et personnalisés"""
        all_posts = set(ALL_POST_TYPES)
        if self.custom_posts:
            all_posts.update(self.custom_posts.keys())
        return sorted(list(all_posts))
        
    
    def get_post_group(self, post_type: str, day_info: Union[date, int]) -> str:
        """Détermine le groupe statistique d'un poste, y compris les postes personnalisés"""
        if post_type in self.custom_posts:
            custom_post = self.custom_posts[post_type]
            return custom_post.statistic_group if custom_post.statistic_group else "Other"
            
            
    def set_empty_table_message(self, table):
        table.setRowCount(1)
        table.setColumnCount(1)
        table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))

    def update_stats(self, planning=None, doctors=None, cats=None):
        """Mise à jour de tous les tableaux de statistiques"""
        if planning is not None:
            self.planning = planning
        if doctors is not None:
            self.doctors = doctors
        if cats is not None:
            self.cats = cats
        
        # Recharger les postes personnalisés et mettre à jour les groupes
        self.custom_posts = self.load_custom_posts()
        
        if self.planning and self.doctors and self.cats:
            self.create_stats_table()
            detailed_stats = self.calculate_detailed_stats()
            self.update_detailed_stats_table(detailed_stats)
            weekly_stats = self.calculate_weekday_stats()
            self.update_weekly_stats_table(weekly_stats)
            weekend_stats = self.calculate_weekend_stats()
            self.update_weekend_stats_table(weekend_stats)
            weekday_group_stats = self.calculate_weekday_group_stats()
            self.update_weekday_group_stats_table(weekday_group_stats)
        else:
            self.set_empty_table_message(self.stats_table)
            self.set_empty_table_message(self.detailed_stats_table)
            self.set_empty_table_message(self.weekly_stats_table)
            self.set_empty_table_message(self.weekend_stats_table)
            self.set_empty_table_message(self.weekday_group_stats_table)




    def update_stats_table(self, stats, table):
        sorted_doctors = sorted([d.name for d in self.doctors], key=str.lower)
        sorted_cats = sorted([c.name for c in self.cats], key=str.lower)
        sorted_assignees = sorted_doctors + sorted_cats + ["Non attribué"]
        all_posts = self.get_all_post_types()

        table.setRowCount(len(sorted_assignees) + 1)
        table.setColumnCount(len(all_posts) + 2)

        headers = ["Assigné à"] + all_posts + ["Total"]
        table.setHorizontalHeaderLabels(headers)

        total_row = {post_type: 0 for post_type in all_posts}
        total_row["Total"] = 0

        for row, assignee in enumerate(sorted_assignees):
            table.setItem(row, 0, QTableWidgetItem(str(assignee)))
            assignee_stats = stats.get(assignee, {})

            assignee_total = 0
            for col, post_type in enumerate(all_posts, start=1):
                count = assignee_stats.get(post_type, 0)
                item = QTableWidgetItem(str(count))
                
                # Appliquer la couleur de fond pour les postes personnalisés en gérant les erreurs
                if hasattr(self, 'custom_posts') and post_type in self.custom_posts:
                    custom_post = self.custom_posts[post_type]
                    if hasattr(custom_post, 'color'):
                        item.setBackground(QBrush(custom_post.color))
                    elif isinstance(custom_post, dict) and 'color' in custom_post:
                        # Si c'est encore un dictionnaire, créer la couleur à partir de la valeur
                        item.setBackground(QBrush(QColor(custom_post['color'])))
                    else:
                        # Couleur par défaut si aucune n'est définie
                        item.setBackground(QBrush(QColor("#E6F3FF")))
                
                table.setItem(row, col, item)
                assignee_total += count
                total_row[post_type] += count

            table.setItem(row, len(all_posts) + 1, QTableWidgetItem(str(assignee_total)))
            total_row["Total"] += assignee_total

            # Griser les lignes des médecins à 1 demi-part
            doctor = next((d for d in self.doctors if d.name == assignee), None)
            if doctor and doctor.half_parts == 1:
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setBackground(QBrush(QColor(240, 240, 240)))

        self.add_total_row(table, total_row, all_posts)
    
    def add_total_row(self, table, total_row, all_posts):
        """Ajoute la ligne des totaux au tableau"""
        last_row = table.rowCount() - 1
        table.setItem(last_row, 0, QTableWidgetItem("Total"))
        for col, post_type in enumerate(all_posts, start=1):
            table.setItem(last_row, col, QTableWidgetItem(str(total_row[post_type])))
        table.setItem(last_row, len(all_posts) + 1, QTableWidgetItem(str(total_row["Total"])))
        
    def _get_combined_intervals(self, doctor_name: str) -> Dict:
        """
        Calcule les intervalles combinés (semaine + weekend) pour tous les types de postes.
        Utilisé dans l'onglet des statistiques générales.
        
        Args:
            doctor_name: Nom du médecin
        
        Returns:
            Dict: Dictionnaire des intervalles combinés pour chaque type de poste
        """
        combined_intervals = {}
        pre_analysis = self.planning.pre_analysis_results
        if not pre_analysis or 'ideal_distribution' not in pre_analysis:
            return {}

        doctor_dist = pre_analysis['ideal_distribution'].get(doctor_name, {})
        weekday_posts = doctor_dist.get('weekday_posts', {})
        weekend_posts = doctor_dist.get('weekend_posts', {})

        # Pour chaque type de poste, combiner les intervalles
        all_post_types = set(weekday_posts.keys()) | set(weekend_posts.keys())
        for post_type in all_post_types:
            weekday_interval = weekday_posts.get(post_type, {'min': 0, 'max': float('inf')})
            weekend_interval = weekend_posts.get(post_type, {'min': 0, 'max': float('inf')})

            # Calculer la somme des minimums
            combined_min = weekday_interval['min'] + weekend_interval['min']

            # Calculer la somme des maximums, en gérant le cas float('inf')
            if weekday_interval['max'] == float('inf') and weekend_interval['max'] == float('inf'):
                combined_max = float('inf')
            elif weekday_interval['max'] == float('inf'):
                combined_max = float('inf')
            elif weekend_interval['max'] == float('inf'):
                combined_max = float('inf')
            else:
                combined_max = weekday_interval['max'] + weekend_interval['max']

            combined_intervals[post_type] = {
                'min': combined_min,
                'max': combined_max
            }

        return combined_intervals

    def create_stats_table(self):
        """Version modifiée de create_stats_table utilisant les intervalles combinés"""
        stats = self.calculate_stats()
        self.stats_table.clear()

        # Initialisation du tableau avec toutes les colonnes
        all_posts = []
        for group in self.post_groups.values():
            all_posts.extend(group['posts'])

        self.stats_table.setColumnCount(len(all_posts) + 2)  # +2 pour nom et total
        headers = ['Assigné à'] + all_posts + ['Total']
        self.stats_table.setHorizontalHeaderLabels(headers)

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes
        self.stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec badge CAT si nécessaire
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.stats_table.setItem(row, 0, name_item)

            # Pour les médecins, récupérer les intervalles combinés
            combined_intervals = {}
            if hasattr(person, 'half_parts'):
                combined_intervals = self._get_combined_intervals(person.name)

            # Valeurs des postes
            row_total = 0
            for col, post_type in enumerate(all_posts, start=1):
                count = stats.get(person.name, {}).get(post_type, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:
                        item.setBackground(QColor('#F3F4F6'))
                        
                    # Coloration selon les intervalles combinés pour les médecins
                    if post_type in combined_intervals:
                        min_val = combined_intervals[post_type]['min']
                        max_val = combined_intervals[post_type]['max']
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif max_val != float('inf') and count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                    
                if post_type in self.custom_posts:
                    item.setBackground(self.custom_posts[post_type].color)
                    
                self.stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.stats_table.setItem(row, len(all_posts) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row(len(all_personnel), stats, all_posts)
        self._add_total_row(len(all_personnel) + 1, stats, all_posts)

        # Configuration de l'affichage
        self.stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.stats_table.verticalHeader().setVisible(False)
        self.stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.stats_table)

    def _apply_filter_to_table(self, table):
        """Applique le filtre actuel à un tableau donné"""
        if not table:
            return

        for col in range(1, table.columnCount() - 1):  # Exclure nom et total
            header_item = table.horizontalHeaderItem(col)
            if not header_item:
                continue
                
            post = header_item.text()
            is_visible = self.current_filter == 'all'
            
            if not is_visible:
                # Vérifier si le poste appartient au groupe actif
                is_visible = post in self.post_groups.get(self.current_filter, {}).get('posts', [])
            
            table.setColumnHidden(col, not is_visible)
        
        # Mise à jour des totaux
        self._update_visible_totals(table)

    def _filter_posts(self, group_key):
        """Filtre les colonnes affichées selon le groupe sélectionné"""
        # Mise à jour des boutons
        for key, btn in self.filter_buttons.items():
            btn.setChecked(key == group_key)

        # Affichage/masquage des colonnes
        for col in range(1, self.stats_table.columnCount() - 1):  # Exclure la colonne nom et total
            header_item = self.stats_table.horizontalHeaderItem(col)
            post = header_item.text()
            
            if group_key == 'all':
                self.stats_table.setColumnHidden(col, False)
            else:
                # Vérifier si le poste appartient au groupe sélectionné
                visible = False
                if group_key in self.post_groups and post in self.post_groups[group_key]['posts']:
                    visible = True
                self.stats_table.setColumnHidden(col, not visible)

        # Recalcul des totaux visibles
        self._update_visible_totals
        
    def _update_visible_totals(self, table):
        """Met à jour les totaux en fonction des colonnes visibles"""
        if not table:
            return

        # Pour chaque ligne du tableau
        for row in range(table.rowCount()):
            visible_total = 0
            
            # Calcul du total sur les colonnes visibles uniquement
            for col in range(1, table.columnCount() - 1):  # Exclure nom et total
                if not table.isColumnHidden(col):
                    item = table.item(row, col)
                    if item:
                        try:
                            visible_total += int(item.text())
                        except ValueError:
                            continue

            # Mise à jour de la cellule total
            total_item = table.item(row, table.columnCount() - 1)
            if total_item:
                # Conserver le style existant
                background = total_item.background()
                font = total_item.font()
                
                # Mise à jour du total
                total_item = QTableWidgetItem(str(visible_total))
                total_item.setBackground(background)
                total_item.setFont(font)
                table.setItem(row, table.columnCount() - 1, total_item)

    def _calculate_row_total(self, table, row):
        """Calcule le total d'une ligne en ne prenant en compte que les colonnes visibles"""
        total = 0
        for col in range(1, table.columnCount() - 1):
            if not table.isColumnHidden(col):
                item = table.item(row, col)
                if item:
                    try:
                        total += int(item.text())
                    except ValueError:
                        continue
        return total
    def _add_unassigned_row(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des postes non attribués"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par poste
        for col, post_type in enumerate(all_posts, start=1):
            count = unassigned_stats.get(post_type, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.stats_table.setItem(row_index, len(all_posts) + 1, total_item)

    def _add_total_row(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des totaux"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par poste
        grand_total = 0
        for col, post_type in enumerate(all_posts, start=1):
            total = sum(person_stats.get(post_type, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.stats_table.setItem(row_index, len(all_posts) + 1, final_total)


    def update_detailed_stats_table(self, detailed_stats):
        """Mise à jour de l'onglet des groupes weekend avec fonctionnalité d'expansion"""
        self.detailed_stats_table.clear()
        self.expanded_group = None
        self.component_columns.clear()

        # Mettre à jour les composants des groupes avec les postes personnalisés
        self._update_group_components()

        # Configuration des données de base
        weekend_groups = {
            'gardes': {
                'label': 'Gardes',
                'groups': ['NLw', 'NAMw'],
                'color': QColor('#E3F2FD')
            },
            'visites': {
                'label': 'Visites',
                'groups': ['VmS', 'VmD', 'VaSD'],
                'color': QColor('#FFF3E0')
            },
            'consultations': {
                'label': 'Consultations',
                'groups': ['CmS', 'CmD', 'CaSD', 'CsSD'],
                'color': QColor('#EDE7F6')
            }
        }
 # Collecte des groupes principaux
        all_groups = []
        for category in weekend_groups.values():
            all_groups.extend(category['groups'])

        # Configuration initiale du tableau
        self.detailed_stats_table.setColumnCount(len(all_groups) + 2)  # +2 pour nom et total
        headers = ['Assigné à'] + all_groups + ['Total']
        
        # Modifier la création des en-têtes pour utiliser AnimatedDetailedGroupHeader
        for col, group in enumerate(all_groups, start=1):
            header_item = AnimatedDetailedGroupHeader(
                group, 
                self.group_details.get(group, {}).get('components', [])
            )
            self.detailed_stats_table.setHorizontalHeaderItem(col, header_item)
        
            
            # Coloration selon la catégorie
            for category in weekend_groups.values():
                if group in category['groups']:
                    header_item.setBackground(category['color'])
                    
                    # Ajout d'une infobulle explicative
                    tooltip = self.get_group_tooltip(group)
                    header_item.setToolTip(tooltip)
                    break
                # Configuration des événements d'en-tête
        self.detailed_stats_table.horizontalHeader().sectionClicked.connect(self._handle_header_click)


        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes
        self.detailed_stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec distinction CAT/mi-temps
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.detailed_stats_table.setItem(row, 0, name_item)

            # Valeurs des groupes
            row_total = 0
            for col, group in enumerate(all_groups, start=1):
                count = detailed_stats.get(person.name, {}).get(group, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                    
                    # Coloration selon les intervalles pour les médecins
                    intervals = ideal_intervals.get(person.name, {}).get('weekend_groups', {}).get(group, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                self.detailed_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.detailed_stats_table.setItem(row, len(all_groups) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_detailed(len(all_personnel), detailed_stats, all_groups)
        self._add_total_row_detailed(len(all_personnel) + 1, detailed_stats, all_groups)

        # Configuration de l'affichage
        self.detailed_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.detailed_stats_table.verticalHeader().setVisible(False)
        self.detailed_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.detailed_stats_table)

    def get_group_tooltip(self, group):
        """Retourne l'infobulle explicative pour chaque groupe"""
        tooltips = {
            'NLw': "Gardes de nuit longues weekend (NLv + NLs + NLd)",
            'NAMw': "Gardes de nuit courtes et moyennes weekend (NA + NM)",
            'VmS': "Visites du matin samedi",
            'VmD': "Visites du matin dimanche/férié",
            'VaSD': "Visites après-midi samedi et dimanche/férié",
            'CmS': "Consultations matin samedi",
            'CmD': "Consultations matin dimanche/férié",
            'CaSD': "Consultations après-midi samedi et dimanche/férié",
            'CsSD': "Consultations soir samedi et dimanche/férié"
        }
        return tooltips.get(group, "")
    
    def _handle_header_click(self, logical_index):
        """Gère le clic sur un en-tête de colonne"""
        if logical_index == 0 or logical_index == self.detailed_stats_table.columnCount() - 1:
            return  # Ignorer les clics sur 'Assigné à' et 'Total'

        header_item = self.detailed_stats_table.horizontalHeaderItem(logical_index)
        if not isinstance(header_item, DetailedGroupHeader):
            return

        if self.expanded_group == header_item.group_name:
            # Cacher les composants du groupe actuel
            self._collapse_group(header_item.group_name)
            self.expanded_group = None
        else:
            # Cacher les composants du groupe précédent s'il y en a un
            if self.expanded_group:
                self._collapse_group(self.expanded_group)
            
            # Montrer les composants du nouveau groupe
            self._expand_group(header_item.group_name)
            self.expanded_group = header_item.group_name

    def _update_group_components(self):
        """Met à jour les composants des groupes en incluant les postes personnalisés"""
        # Copie des composants standards
        updated_details = self.group_details.copy()
        
        # Parcourir tous les postes personnalisés
        for post_name, custom_post in self.custom_posts.items():
            if custom_post.statistic_group:
                # Si le poste appartient à un groupe
                group = custom_post.statistic_group
                if group in updated_details:
                    # Ajouter le poste personnalisé aux composants du groupe
                    if 'components' not in updated_details[group]:
                        updated_details[group]['components'] = []
                    updated_details[group]['components'].append(post_name)
                    
                    # Log pour le débogage
                    logger.info(f"Ajout du poste personnalisé {post_name} au groupe {group}")
        
        self.group_details = updated_details

    def calculate_weekend_component_stats(self):
        """
        Calcule les statistiques détaillées des composants pour les groupes weekend.
        Retourne un dictionnaire avec les stats de chaque composant par personne.
        """
        stats = {}
        if not self.planning:
            return stats

        # Initialiser les statistiques pour tout le personnel
        for person in self.doctors + self.cats:
            stats[person.name] = {}
            # Initialiser les composants pour chaque groupe
            for group_name, details in self.group_details.items():
                stats[person.name][group_name] = 0  # Total du groupe
                for component in details['components']:
                    stats[person.name][component] = 0  # Composants individuels

        # Ajouter "Non attribué"
        stats["Non attribué"] = {}
        for group_name, details in self.group_details.items():
            stats["Non attribué"][group_name] = 0
            for component in details['components']:
                stats["Non attribué"][component] = 0

        for day in self.planning.days:
            is_friday = day.date.weekday() == 4
            is_saturday = day.date.weekday() == 5
            is_sunday = day.date.weekday() == 6
            is_holiday = day.is_holiday_or_bridge

            for slot in day.slots:
                assignee = slot.assignee if slot.assignee in stats else "Non attribué"
                
                # Traitement spécial pour NLw et ses composants
                if slot.abbreviation == "NL":
                    stats[assignee]["NLw"] = stats[assignee].get("NLw", 0) + 1
                    if is_friday:
                        stats[assignee]["NLv"] = stats[assignee].get("NLv", 0) + 1
                    elif is_saturday:
                        stats[assignee]["NLs"] = stats[assignee].get("NLs", 0) + 1
                    elif is_sunday or is_holiday:
                        stats[assignee]["NLd"] = stats[assignee].get("NLd", 0) + 1
                        
                # Traitement pour NAMw
                elif slot.abbreviation in ["NA", "NM"] and (is_saturday or is_sunday or is_holiday):
                    stats[assignee]["NAMw"] = stats[assignee].get("NAMw", 0) + 1
                    if is_saturday:
                        if slot.abbreviation == "NA":
                            stats[assignee]["NAs"] = stats[assignee].get("NAs", 0) + 1
                        else:  # NM
                            stats[assignee]["NMs"] = stats[assignee].get("NMs", 0) + 1
                    else:  # Dimanche ou férié
                        if slot.abbreviation == "NA":
                            stats[assignee]["NAd"] = stats[assignee].get("NAd", 0) + 1
                        else:  # NM
                            stats[assignee]["NMd"] = stats[assignee].get("NMd", 0) + 1

                # Traitement pour les autres groupes selon group_details
                for group_name, details in self.group_details.items():
                    if slot.abbreviation in details['components']:
                        # Mettre à jour le composant individuel
                        stats[assignee][slot.abbreviation] = stats[assignee].get(slot.abbreviation, 0) + 1
                        
                        # Mettre à jour le total du groupe selon les conditions spécifiques
                        if group_name in ["VmS", "CmS"] and is_saturday:
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1
                        elif group_name in ["VmD", "CmD"] and (is_sunday or is_holiday):
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1
                        elif group_name in ["VaSD", "CaSD", "CsSD"] and (is_saturday or is_sunday or is_holiday):
                            stats[assignee][group_name] = stats[assignee].get(group_name, 0) + 1

        return stats
    def _expand_group(self, group_name):
        """Version améliorée de l'expansion de groupe avec animation"""
        components = self.group_details[group_name]['components']
        if not components:
            return

        # Trouver la colonne du groupe
        group_index = -1
        for i in range(self.detailed_stats_table.columnCount()):
            header = self.detailed_stats_table.horizontalHeaderItem(i)
            if isinstance(header, AnimatedDetailedGroupHeader) and header.group_name == group_name:
                group_index = i
                break

        if group_index == -1:
            return

        # Mettre à jour l'indicateur
        header = self.detailed_stats_table.horizontalHeaderItem(group_index)
        header.toggle_expansion()

        # Insérer et préparer les colonnes des composants
        current_column = group_index + 1
        self.component_columns[group_name] = []
        stats = self.calculate_weekend_component_stats()

        # Créer les colonnes masquées initialement
        for component in components:
            self.detailed_stats_table.insertColumn(current_column)
            header_item = QTableWidgetItem(component)
            self.detailed_stats_table.setHorizontalHeaderItem(current_column, header_item)
            
            # Remplir les données
            for row in range(self.detailed_stats_table.rowCount()):
                person_name = self.detailed_stats_table.item(row, 0).text()
                value = stats.get(person_name, {}).get(component, 0)
                self.detailed_stats_table.setItem(row, current_column, QTableWidgetItem(str(value)))
            
            self.component_columns[group_name].append(current_column)
            current_column += 1

        # Lancer l'animation d'expansion
        animation = ColumnAnimation(
            self.detailed_stats_table,
            group_index + 1,
            group_index + len(components)
        )
        animation.expand()

    def _collapse_group(self, group_name):
        """Version améliorée de la réduction de groupe avec animation"""
        if group_name not in self.component_columns:
            return

        # Mettre à jour l'indicateur
        group_index = -1
        for i in range(self.detailed_stats_table.columnCount()):
            header = self.detailed_stats_table.horizontalHeaderItem(i)
            if isinstance(header, AnimatedDetailedGroupHeader) and header.group_name == group_name:
                group_index = i
                header.toggle_expansion()
                break

        # Lancer l'animation de réduction
        columns = self.component_columns[group_name]
        animation = ColumnAnimation(
            self.detailed_stats_table,
            min(columns),
            max(columns)
        )
        animation.collapse()
        
        # Supprimer les colonnes après l'animation
        def remove_columns():
            for column in sorted(self.component_columns[group_name], reverse=True):
                self.detailed_stats_table.removeColumn(column)
            self.component_columns.pop(group_name)

        QTimer.singleShot(animation.duration + 50, remove_columns)

    
    def _add_unassigned_row_detailed(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des postes non attribués pour les groupes weekend"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.detailed_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par groupe
        for col, group in enumerate(all_groups, start=1):
            count = unassigned_stats.get(group, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.detailed_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.detailed_stats_table.setItem(row_index, len(all_groups) + 1, total_item)

    def _add_total_row_detailed(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des totaux pour les groupes weekend"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.detailed_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par groupe
        grand_total = 0
        for col, group in enumerate(all_groups, start=1):
            # Exclure "Non attribué" du calcul s'il existe
            total = sum(person_stats.get(group, 0) 
                    for name, person_stats in stats.items() 
                    if name != "Non attribué")
            
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.detailed_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.detailed_stats_table.setItem(row_index, len(all_groups) + 1, final_total)

    def update_detailed_stats_with_custom_posts(self):
        """Mise à jour des statistiques détaillées pour inclure les postes personnalisés"""
        stats = self.calculate_detailed_stats()
        
        # Ajouter les groupes statistiques des postes personnalisés
        custom_groups = set()
        for post in self.custom_posts.values():
            if post.statistic_group:
                custom_groups.add(post.statistic_group)

        # Mettre à jour les en-têtes avec les nouveaux groupes
        headers = self.get_detailed_stats_headers()
        headers.extend(list(custom_groups))

        self.detailed_stats_table.setColumnCount(len(headers))
        self.detailed_stats_table.setHorizontalHeaderLabels(headers)

        # Mise à jour des données
        self.update_detailed_stats_table(stats)

    def update_weekday_group_stats_table(self, weekday_group_stats):
        """Met à jour le tableau des statistiques des groupes de semaine avec une présentation améliorée"""
        self.weekday_group_stats_table.clear()

        # Définition des groupes et de leurs couleurs
        group_categories = {
            'consultations': {
                'label': 'Consultations',
                'groups': ['XM', 'XA', 'XS'],
                'color': QColor('#E3F2FD')
            },
            'visites': {
                'label': 'Visites',
                'groups': ['VsM', 'VsA'],
                'color': QColor('#FFF3E0')
            },
            'gardes': {
                'label': 'Gardes',
                'groups': ['NAC', 'NL'],
                'color': QColor('#EDE7F6')
            }
        }

        # Collecte des groupes
        all_groups = []
        for category in group_categories.values():
            all_groups.extend(category['groups'])

        # Configuration du tableau
        self.weekday_group_stats_table.setColumnCount(len(all_groups) + 2)  # +2 pour nom et total
        headers = ['Assigné à'] + all_groups + ['Total']
        self.weekday_group_stats_table.setHorizontalHeaderLabels(headers)

        # Coloration des en-têtes selon la catégorie
        for col, group in enumerate(all_groups, start=1):
            header_item = self.weekday_group_stats_table.horizontalHeaderItem(col)
            for category in group_categories.values():
                if group in category['groups']:
                    header_item.setBackground(category['color'])
                    
                    # Ajout d'infobulle explicative
                    tooltip = self.get_weekday_group_tooltip(group)
                    header_item.setToolTip(tooltip)
                    break

        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri et préparation du personnel
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes
        self.weekday_group_stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Configuration du nom
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.weekday_group_stats_table.setItem(row, 0, name_item)

            # Valeurs des groupes
            row_total = 0
            person_intervals = ideal_intervals.get(person.name, {}).get('weekday_groups', {})

            for col, group in enumerate(all_groups, start=1):
                count = weekday_group_stats.get(person.name, {}).get(group, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                        
                    # Coloration selon les intervalles pour les médecins
                    intervals = person_intervals.get(group, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                self.weekday_group_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.weekday_group_stats_table.setItem(row, len(all_groups) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_weekday_groups(len(all_personnel), weekday_group_stats, all_groups)
        self._add_total_row_weekday_groups(len(all_personnel) + 1, weekday_group_stats, all_groups)

        # Configuration de l'affichage
        self.weekday_group_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.weekday_group_stats_table.verticalHeader().setVisible(False)
        self.weekday_group_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.weekday_group_stats_table)

    def get_weekday_group_tooltip(self, group: str) -> str:
        """Version enrichie de la méthode existante avec intervalles"""
        base_tooltips = {
            'XM': "Consultations du matin (CM, HM, SM, RM)",
            'XA': "Consultations après-midi (CA, HA, SA, RA)",
            'XS': "Consultations du soir (CS, HS, SS, RS)",
            'NAC': "Gardes de nuit courtes (NA, NC)",
            'VsM': "Visites du matin (ML, MC)",
            'VsA': "Visites après-midi (AL, AC)",
            'NL': "Gardes de nuit longues"
        }
        
        base_tooltip = base_tooltips.get(group, "")
        full_time_intervals = self.get_intervals_tooltip_text(group, "full_time")
        half_time_intervals = self.get_intervals_tooltip_text(group, "half_time")
        
        tooltip_parts = [base_tooltip]
        if full_time_intervals:
            tooltip_parts.append(full_time_intervals)
        if half_time_intervals:
            tooltip_parts.append(half_time_intervals)
            
        return "\n\n".join(tooltip_parts)

    def _add_unassigned_row_weekday_groups(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des postes non attribués pour les groupes de semaine"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.weekday_group_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par groupe
        for col, group in enumerate(all_groups, start=1):
            count = unassigned_stats.get(group, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.weekday_group_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.weekday_group_stats_table.setItem(row_index, len(all_groups) + 1, total_item)

    def _add_total_row_weekday_groups(self, row_index: int, stats: dict, all_groups: list):
        """Ajoute la ligne des totaux pour les groupes de semaine"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekday_group_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par groupe
        grand_total = 0
        for col, group in enumerate(all_groups, start=1):
            total = sum(person_stats.get(group, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.weekday_group_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekday_group_stats_table.setItem(row_index, len(all_groups) + 1, final_total)

    def update_weekly_stats_table(self, weekly_stats):
        """Met à jour le tableau des statistiques de semaine avec une présentation améliorée"""
        self.weekly_stats_table.clear()

        # Récupération des statistiques de semaine
        stats = self.calculate_weekday_stats()

        # Récupérer les configurations de semaine depuis le planning
        weekday_config = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            weekday_config = self.planning.pre_analysis_results.get('total_posts', {}).get('weekday', {})

        # Créer un set pour collecter tous les postes configurés
        active_posts = set()

        # Vérification des postes configurés ou utilisés
        for group in self.post_groups.values():
            for post in group['posts']:
                weekday_count = weekday_config.get(post, 0)
                
                # Si le poste est configuré ou utilisé dans les stats
                if (weekday_count > 0 or
                    any(stats[person.name].get(post, 0) > 0 for person in self.doctors + self.cats)):
                    active_posts.add(post)

        # Organisation des postes selon l'ordre des groupes
        all_posts = []
        for group in self.post_groups.values():
            # Ajouter uniquement les postes actifs de ce groupe, dans l'ordre du groupe
            group_posts = [post for post in group['posts'] if post in active_posts]
            all_posts.extend(group_posts)

        # Configuration du tableau
        self.weekly_stats_table.setColumnCount(len(all_posts) + 2)
        headers = ['Assigné à'] + all_posts + ['Total']
        self.weekly_stats_table.setHorizontalHeaderLabels(headers)

        # Coloration des en-têtes selon les groupes
        for col, post in enumerate(all_posts, start=1):
            header_item = self.weekly_stats_table.horizontalHeaderItem(col)
            weekday_count = weekday_config.get(post, 0)
            base_tooltip = f"Configuration semaine : {weekday_count}"
            enhanced_tooltip = self.get_enhanced_post_tooltip(post, base_tooltip)
            header_item.setToolTip(enhanced_tooltip)


        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri des médecins et CATs
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes du tableau
        self.weekly_stats_table.setRowCount(len(all_personnel) + 2)  # +2 pour Non attribué et Total

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Nom avec distinction CAT/mi-temps
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # C'est un CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.weekly_stats_table.setItem(row, 0, name_item)

            # Valeurs des postes
            row_total = 0
            person_intervals = ideal_intervals.get(person.name, {}).get('weekday_posts', {})

            for col, post in enumerate(all_posts, start=1):
                count = stats.get(person.name, {}).get(post, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                        
                    # Coloration selon les intervalles pour les médecins
                    intervals = person_intervals.get(post, {})
                    if intervals:
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                
                if post in self.custom_posts:
                    item.setBackground(self.custom_posts[post].color)
                    
                self.weekly_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.weekly_stats_table.setItem(row, len(all_posts) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_weekly(len(all_personnel), stats, all_posts)
        self._add_total_row_weekly(len(all_personnel) + 1, stats, all_posts)

        # Configuration de l'affichage
        self.weekly_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.weekly_stats_table.verticalHeader().setVisible(False)
        self.weekly_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.weekly_stats_table)

    def _add_unassigned_row_weekly(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des postes non attribués pour les statistiques semaine"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.weekly_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par poste
        for col, post_type in enumerate(all_posts, start=1):
            count = unassigned_stats.get(post_type, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.weekly_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.weekly_stats_table.setItem(row_index, len(all_posts) + 1, total_item)

    def _add_total_row_weekly(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des totaux pour les statistiques semaine"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekly_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par poste
        grand_total = 0
        for col, post_type in enumerate(all_posts, start=1):
            total = sum(person_stats.get(post_type, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.weekly_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekly_stats_table.setItem(row_index, len(all_posts) + 1, final_total)

    def update_weekend_stats_table(self, weekend_stats):
        """Met à jour le tableau des statistiques weekend"""
        self.weekend_stats_table.clear()

        # Récupération des statistiques weekend
        stats = self.calculate_weekend_stats()

        # Récupération des configurations weekend depuis le planning
        weekend_config = {}
        holiday_config = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            weekend_config = self.planning.pre_analysis_results.get('total_posts', {}).get('saturday', {})
            holiday_config = self.planning.pre_analysis_results.get('total_posts', {}).get('sunday_holiday', {})

        # Création d'un set pour collecter tous les postes configurés
        active_posts = set()

        # Vérification des postes configurés ou utilisés
        for group in self.post_groups.values():
            for post in group['posts']:
                saturday_count = weekend_config.get(post, 0)
                holiday_count = holiday_config.get(post, 0)
                
                # Si le poste est configuré ou utilisé dans les stats
                if (saturday_count > 0 or holiday_count > 0 or
                    any(stats[person.name].get(post, 0) > 0 for person in self.doctors + self.cats)):
                    active_posts.add(post)

        # Organisation des postes selon l'ordre des groupes
        all_posts = []
        for group in self.post_groups.values():
            # Ajouter uniquement les postes actifs de ce groupe, dans l'ordre du groupe
            group_posts = [post for post in group['posts'] if post in active_posts]
            all_posts.extend(group_posts)

        # Configuration du tableau
        self.weekend_stats_table.setColumnCount(len(all_posts) + 2)
        headers = ['Assigné à'] + all_posts + ['Total']
        self.weekend_stats_table.setHorizontalHeaderLabels(headers)

        # Coloration des en-têtes selon les groupes
        for col, post in enumerate(all_posts, start=1):
            header_item = self.weekend_stats_table.horizontalHeaderItem(col)
            saturday_count = weekend_config.get(post, 0)
            holiday_count = holiday_config.get(post, 0)
            base_tooltip = f"Configuration :\nSamedi : {saturday_count}\nDimanche/Férié : {holiday_count}"
            enhanced_tooltip = self.get_enhanced_post_tooltip(post, base_tooltip)
            header_item.setToolTip(enhanced_tooltip)

        # Récupération des intervalles depuis la pré-analyse
        ideal_intervals = {}
        if self.planning and hasattr(self.planning, 'pre_analysis_results'):
            ideal_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {})

        # Tri et préparation du personnel
        sorted_doctors = sorted([d for d in self.doctors if d.half_parts == 2], key=lambda x: x.name)
        sorted_half_doctors = sorted([d for d in self.doctors if d.half_parts == 1], key=lambda x: x.name)
        sorted_cats = sorted(self.cats, key=lambda x: x.name)
        all_personnel = sorted_doctors + sorted_half_doctors + sorted_cats

        # Configuration des lignes du tableau
        self.weekend_stats_table.setRowCount(len(all_personnel) + 2)

        # Remplissage des données
        for row, person in enumerate(all_personnel):
            # Configuration du nom
            name_item = QTableWidgetItem(person.name)
            if not hasattr(person, 'half_parts'):  # CAT
                name_item.setFont(QFont("", -1, QFont.Weight.Bold))
                name_item.setBackground(QColor('#E8F5E9'))
            elif person.half_parts == 1:  # Mi-temps
                name_item.setBackground(QColor('#F3F4F6'))
            self.weekend_stats_table.setItem(row, 0, name_item)

            # Récupération des intervalles spécifiques à la personne
            person_intervals = ideal_intervals.get(person.name, {})
            weekend_group_intervals = person_intervals.get('weekend_groups', {})
            weekend_post_intervals = person_intervals.get('weekend_posts', {})

            # Calcul du total des NL (incluant NLv)
            nl_total = weekend_stats.get(person.name, {}).get('NL', 0)

            row_total = 0
            for col, post in enumerate(all_posts, start=1):
                count = weekend_stats.get(person.name, {}).get(post, 0)
                item = QTableWidgetItem(str(count))
                
                # Gestion de la coloration
                if hasattr(person, 'half_parts'):
                    if person.half_parts == 1:  # Mi-temps
                        item.setBackground(QColor('#F3F4F6'))
                    elif post == 'NL':  # Cas spécial pour NL
                        nlw_intervals = weekend_group_intervals.get('NLw', {})
                        min_val = nlw_intervals.get('min', 0)
                        max_val = nlw_intervals.get('max', float('inf'))
                        
                        if nl_total < min_val:
                            item.setBackground(QColor('#E8F5E9'))  # Vert clair
                        elif nl_total > max_val:
                            item.setBackground(QColor('#FFEBEE'))  # Rouge clair
                    else:  # Autres postes
                        intervals = weekend_post_intervals.get(post, {})
                        min_val = intervals.get('min', 0)
                        max_val = intervals.get('max', float('inf'))
                        if count < min_val:
                            item.setBackground(QColor('#E8F5E9'))
                        elif count > max_val:
                            item.setBackground(QColor('#FFEBEE'))
                
                if post in self.custom_posts:
                    item.setBackground(self.custom_posts[post].color)
                    
                self.weekend_stats_table.setItem(row, col, item)
                row_total += count

            # Total de la ligne
            total_item = QTableWidgetItem(str(row_total))
            if hasattr(person, 'half_parts') and person.half_parts == 1:
                total_item.setBackground(QColor('#F3F4F6'))
            self.weekend_stats_table.setItem(row, len(all_posts) + 1, total_item)

        # Ajout des lignes "Non attribué" et "Total"
        self._add_unassigned_row_weekend(len(all_personnel), weekend_stats, all_posts)
        self._add_total_row_weekend(len(all_personnel) + 1, weekend_stats, all_posts)

        # Configuration de l'affichage
        self.weekend_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.weekend_stats_table.verticalHeader().setVisible(False)
        self.weekend_stats_table.setAlternatingRowColors(False)

        # Application du filtre actuel
        self._apply_filter_to_table(self.weekend_stats_table)
    
    def _add_unassigned_row_weekend(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des postes non attribués pour les statistiques weekend"""
        unassigned_stats = stats.get("Non attribué", {})
        unassigned_total = 0
        
        # Cellule du nom
        name_item = QTableWidgetItem("Non attribué")
        name_item.setBackground(QColor('#F5F5F5'))
        self.weekend_stats_table.setItem(row_index, 0, name_item)
        
        # Valeurs par poste
        for col, post_type in enumerate(all_posts, start=1):
            count = unassigned_stats.get(post_type, 0)
            item = QTableWidgetItem(str(count))
            item.setBackground(QColor('#F5F5F5'))
            self.weekend_stats_table.setItem(row_index, col, item)
            unassigned_total += count
        
        # Total
        total_item = QTableWidgetItem(str(unassigned_total))
        total_item.setBackground(QColor('#F5F5F5'))
        self.weekend_stats_table.setItem(row_index, len(all_posts) + 1, total_item)

    def _add_total_row_weekend(self, row_index: int, stats: dict, all_posts: list):
        """Ajoute la ligne des totaux pour les statistiques weekend"""
        # Cellule du nom
        name_item = QTableWidgetItem("Total")
        name_item.setBackground(QColor('#EEEEEE'))
        name_item.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekend_stats_table.setItem(row_index, 0, name_item)
        
        # Calcul des totaux par poste
        grand_total = 0
        for col, post_type in enumerate(all_posts, start=1):
            total = sum(person_stats.get(post_type, 0) 
                    for person_stats in stats.values())
            item = QTableWidgetItem(str(total))
            item.setBackground(QColor('#EEEEEE'))
            item.setFont(QFont("", -1, QFont.Weight.Bold))
            self.weekend_stats_table.setItem(row_index, col, item)
            grand_total += total
        
        # Total général
        final_total = QTableWidgetItem(str(grand_total))
        final_total.setBackground(QColor('#EEEEEE'))
        final_total.setFont(QFont("", -1, QFont.Weight.Bold))
        self.weekend_stats_table.setItem(row_index, len(all_posts) + 1, final_total)

    def calculate_stats(self):
        # Récupérer tous les types de postes possibles
        all_post_types = set(ALL_POST_TYPES)  # Postes standards
        
        # Ajouter les postes personnalisés s'ils existent
        if hasattr(self, 'custom_posts'):
            all_post_types.update(self.custom_posts.keys())
        
        # Initialiser les stats avec tous les types de postes
        stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}
        
        if not self.planning or not self.planning.days:
            return stats

        for day_planning in self.planning.days:
            for slot in day_planning.slots:
                # S'assurer que le type de poste existe dans les stats
                if slot.abbreviation not in stats["Non attribué"]:
                    # Ajouter le nouveau type de poste à tous les dictionnaires
                    for person_stats in stats.values():
                        person_stats[slot.abbreviation] = 0
                        
                if slot.assignee in stats:
                    stats[slot.assignee][slot.abbreviation] += 1
                else:
                    stats["Non attribué"][slot.abbreviation] += 1

        return stats
    
    def calculate_detailed_stats(self):
        """
        Calcule les statistiques détaillées des groupes weekend en prenant en compte
        correctement les jours fériés et les ponts, avec un traitement spécial pour les NLv.
        
        Les NLv (nuits longues du vendredi) sont toujours comptées dans le groupe NLw,
        indépendamment du fait que le vendredi soit un pont ou non. Cela permet de
        maintenir la cohérence dans le décompte des gardes de nuit du weekend.
        """
        stats = {person.name: {
            "NLv": 0, "NLs": 0, "NLd": 0, "NLw": 0, "NAMw": 0,
            "VmS": 0, "VmD": 0, "VaSD": 0,
            "CmS": 0, "CmD": 0, "CaSD": 0, "CsSD": 0,
            "WE Lib": 0
        } for person in self.doctors + self.cats}
        stats["Non attribué"] = {key: 0 for key in stats[self.doctors[0].name].keys()}

        if not self.planning or not self.planning.days:
            return stats

        from core.Constantes.day_type import DayType
        cal = France()

        for day in self.planning.days:
            # Déterminer le type de jour
            day_type = DayType.get_day_type(day.date, cal)
            is_friday = day.date.weekday() == 4
            is_bridge = DayType.is_bridge_day(day.date, cal)
            
            # Un samedi de pont est traité comme un dimanche/férié, sauf pour NLv
            is_saturday = day.date.weekday() == 5 and not is_bridge
            is_sunday_holiday = day_type == "sunday_holiday" or is_bridge

            for slot in day.slots:
                assignee = slot.assignee if slot.assignee in stats else "Non attribué"

                # 1. Traitement spécial des gardes de nuit longues
                if slot.abbreviation == "NL":
                    if is_friday:
                        # Les NLv sont toujours comptées séparément, même si c'est un pont
                        stats[assignee]["NLv"] += 1
                        stats[assignee]["NLw"] += 1
                    elif is_saturday:
                        stats[assignee]["NLs"] += 1
                        stats[assignee]["NLw"] += 1
                    elif is_sunday_holiday:
                        stats[assignee]["NLd"] += 1
                        stats[assignee]["NLw"] += 1

                # 2. Traitement des autres postes de garde
                elif slot.abbreviation in ["NM", "NA"] and (is_saturday or is_sunday_holiday):
                    stats[assignee]["NAMw"] += 1

                # 3. Traitement des visites matin avec prise en compte des ponts
                elif slot.abbreviation in ["ML", "MC"]:
                    if is_saturday:
                        stats[assignee]["VmS"] += 1
                    elif is_sunday_holiday:
                        stats[assignee]["VmD"] += 1

                # 4. Traitement des visites après-midi
                elif slot.abbreviation in ["AL", "AC"] and (is_saturday or is_sunday_holiday):
                    stats[assignee]["VaSD"] += 1

                # 5. Traitement des consultations matin
                elif slot.abbreviation in ["CM", "HM", "SM", "RM", "MM"]:
                    if is_saturday:
                        stats[assignee]["CmS"] += 1
                    elif is_sunday_holiday:
                        stats[assignee]["CmD"] += 1

                # 6. Traitement des consultations après-midi
                elif slot.abbreviation in ["CA", "HA", "SA", "RA"] and (is_saturday or is_sunday_holiday):
                    stats[assignee]["CaSD"] += 1

                # 7. Traitement des consultations soir
                elif slot.abbreviation in ["CS", "HS", "SS", "RS"] and (is_saturday or is_sunday_holiday):
                    stats[assignee]["CsSD"] += 1

            # Calculer les weekends libres pour chaque personne
            for person in self.doctors + self.cats:
                stats[person.name]["WE Lib"] = self.calculate_we_lib(person.name)

        return stats
    def calculate_weekday_group_stats(self):
        """
        Calcule les statistiques des groupes de semaine en excluant les NL du vendredi.
        """
        stats = {person.name: {
            "XM": 0, "XA": 0, "XS": 0, "NAC": 0, "VsM": 0, "VsA": 0, "NL": 0
        } for person in self.doctors + self.cats}
        stats["Non attribué"] = {key: 0 for key in stats[self.doctors[0].name].keys()}

        if not self.planning or not self.planning.days:
            return stats

        for day in self.planning.days:
            # Exclure weekends, fériés, ponts et vendredis pour les NL
            is_friday = day.date.weekday() == 4
            if (day.is_weekend or day.is_holiday_or_bridge):
                continue

            for slot in day.slots:
                assignee = slot.assignee if slot.assignee in stats else "Non attribué"

                # Traitement des NL : ignorer les vendredis
                if slot.abbreviation == "NL":
                    if not is_friday:  # Compter uniquement les NL de lundi à jeudi
                        stats[assignee]["NL"] += 1
                
                # Traitement des autres groupes de postes
                elif slot.abbreviation in ["CM", "HM", "RM", "SM"]:
                    stats[assignee]["XM"] += 1
                elif slot.abbreviation in ["CA", "HA", "RA", "SA"]:
                    stats[assignee]["XA"] += 1
                elif slot.abbreviation in ["CS", "RS", "SS", "HS"]:
                    stats[assignee]["XS"] += 1
                elif slot.abbreviation in ["NA", "NC"]:
                    stats[assignee]["NAC"] += 1
                elif slot.abbreviation in ["ML", "MC"]:
                    stats[assignee]["VsM"] += 1
                elif slot.abbreviation in ["AL", "AC"]:
                    stats[assignee]["VsA"] += 1

        return stats


    def calculate_weekday_stats(self):
        """
        Calcule les statistiques de semaine en excluant les NL du vendredi
        Retourne un dictionnaire avec les stats par personne et par type de poste
        """
        all_post_types = set(ALL_POST_TYPES)
        if self.custom_posts:
            all_post_types.update(self.custom_posts.keys())
        
        weekday_stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        weekday_stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        weekday_stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}

        if not self.planning or not self.planning.days:
            return weekday_stats

        for day in self.planning.days:
            is_friday = day.date.weekday() == 4
            
            # Ne compter que les jours de semaine non fériés
            if day.date.weekday() < 5 and not day.is_holiday_or_bridge:
                for slot in day.slots:
                    # Ignorer les NL du vendredi
                    if is_friday and slot.abbreviation == "NL":
                        continue
                    
                    assignee = slot.assignee if slot.assignee in weekday_stats else "Non attribué"
                    weekday_stats[assignee][slot.abbreviation] += 1

        return weekday_stats

    def calculate_weekend_stats(self):
        """
        Calcule les statistiques du weekend en incluant les NLv du vendredi
        Retourne un dictionnaire avec les stats par personne et par type de poste
        """
        all_post_types = set(ALL_POST_TYPES)
        if self.custom_posts:
            all_post_types.update(self.custom_posts.keys())
            
        weekend_stats = {
            doctor.name: {post_type: 0 for post_type in all_post_types}
            for doctor in self.doctors
        }
        weekend_stats.update({
            cat.name: {post_type: 0 for post_type in all_post_types}
            for cat in self.cats
        })
        weekend_stats["Non attribué"] = {post_type: 0 for post_type in all_post_types}

        if not self.planning or not self.planning.days:
            return weekend_stats

        for day in self.planning.days:
            is_weekend = day.date.weekday() in [5, 6]
            is_friday = day.date.weekday() == 4
            is_holiday_or_bridge = day.is_holiday_or_bridge

            # Compter tous les postes du weekend/férié et les NL du vendredi
            if is_weekend or is_holiday_or_bridge or (is_friday and not is_holiday_or_bridge):
                for slot in day.slots:
                    # Pour les vendredis normaux, ne compter que les NL
                    if is_friday and not is_holiday_or_bridge and slot.abbreviation != "NL":
                        continue
                    
                    assignee = slot.assignee if slot.assignee in weekend_stats else "Non attribué"
                    weekend_stats[assignee][slot.abbreviation] += 1

        return weekend_stats

    def calculate_we_lib(self, person_name):
        we_lib = 0
        current_we_start = None
        consecutive_free_days = 0
        
        for day in self.planning.days:
            is_weekend_or_holiday = day.date.weekday() >= 5 or day.is_holiday_or_bridge
            
            if is_weekend_or_holiday:
                if current_we_start is None:
                    current_we_start = day.date
                
                # Vérifier si la personne travaille ce jour-là
                person_works = any(slot.assignee == person_name and
                                ((slot.start_time.time() >= time(3, 0) and day.date == current_we_start) or
                                    (slot.end_time.time() <= time(23, 59) and (day.date - current_we_start).days >= 1))
                                for slot in day.slots)
                
                if person_works:
                    current_we_start = None
                    consecutive_free_days = 0
                else:
                    consecutive_free_days += 1
                    if consecutive_free_days == 2:
                        we_lib += 1
                        current_we_start = None
                        consecutive_free_days = 0
            else:
                current_we_start = None
                consecutive_free_days = 0
        
        return we_lib
    
    
    
    def uniformize_table_style(self, table):
        # Définir une taille de police uniforme
        table.setStyleSheet("font-size: 12px;")

        # Appliquer une taille de ligne uniforme
        table.verticalHeader().setDefaultSectionSize(24)  # Par exemple, 24 pixels de hauteur

        # Appliquer une largeur uniforme pour chaque colonne
        table.horizontalHeader().setDefaultSectionSize(100)  # Largeur par défaut des colonnes

        # Ajuster les colonnes pour remplir l'espace
        table.resizeColumnsToContents()
        table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        
    def clear_stats(self):
        self.planning = None
        self.stats_table.setRowCount(0)
        self.stats_table.setColumnCount(0)
        self.weekend_stats_table.setRowCount(0)
        self.weekend_stats_table.setColumnCount(0)
        self.detailed_stats_table.setRowCount(0)
        self.detailed_stats_table.setColumnCount(0)
        self.weekly_stats_table.setRowCount(0)
        self.weekly_stats_table.setColumnCount(0)
        self.weekday_group_stats_table.setRowCount(0)
        self.weekday_group_stats_table.setColumnCount(0)


    def update_color_coding(self, item: QTableWidgetItem, post_type: str):
        """Met à jour la couleur de fond des cellules en fonction du type de poste"""
        if post_type in self.custom_posts:
            item.setBackground(self.custom_posts[post_type].color)
            
            
            
    
    
    
    
    def setup_scroll_sync(self):
        """Configure la synchronisation du scroll entre tous les tableaux de statistiques"""
        tables = [
            self.stats_table,
            self.weekend_stats_table,
            self.detailed_stats_table,
            self.weekly_stats_table,
            self.weekday_group_stats_table
        ]

        # Synchronisation du scroll vertical
        def sync_vertical_scroll(source_table):
            def _sync_scroll(value):
                # Synchroniser tous les autres tableaux avec la position de scroll de la source
                for table in tables:
                    if table != source_table and table.verticalScrollBar():
                        table.verticalScrollBar().setValue(value)
            return _sync_scroll

        # Synchronisation du scroll horizontal
        def sync_horizontal_scroll(source_table):
            def _sync_scroll(value):
                # Synchroniser tous les autres tableaux avec la position de scroll de la source
                for table in tables:
                    if table != source_table and table.horizontalScrollBar():
                        table.horizontalScrollBar().setValue(value)
            return _sync_scroll

        # Application de la synchronisation à tous les tableaux
        for table in tables:
            if table.verticalScrollBar():
                table.verticalScrollBar().valueChanged.connect(
                    sync_vertical_scroll(table)
                )
            if table.horizontalScrollBar():
                table.horizontalScrollBar().valueChanged.connect(
                    sync_horizontal_scroll(table)
                )
                
                
                
    def get_intervals_tooltip_text(self, post_type: str, doctor_type: str = "full_time") -> str:
        """
        Génère le texte de l'infobulle pour les intervalles d'un poste selon le type de médecin
        
        Args:
            post_type: Type de poste
            doctor_type: Type de médecin ("full_time" ou "half_time")
            
        Returns:
            str: Texte formaté des intervalles
        """
        if not self.planning or not hasattr(self.planning, 'pre_analysis_results'):
            return ""
            
        intervals = {}
        for doctor in self.doctors:
            if (doctor_type == "full_time" and doctor.half_parts == 2) or \
            (doctor_type == "half_time" and doctor.half_parts == 1):
                doctor_intervals = self.planning.pre_analysis_results.get('ideal_distribution', {}).get(doctor.name, {})
                weekday_intervals = doctor_intervals.get('weekday_posts', {}).get(post_type, {})
                weekend_intervals = doctor_intervals.get('weekend_posts', {}).get(post_type, {})
                
                if weekday_intervals or weekend_intervals:
                    intervals['weekday'] = weekday_intervals
                    intervals['weekend'] = weekend_intervals

        if not intervals:
            return ""

        tooltip_text = []
        if doctor_type == "full_time":
            tooltip_text.append("Intervalles temps plein:")
        else:
            tooltip_text.append("Intervalles mi-temps:")

        for period, data in intervals.items():
            if data:
                min_val = data.get('min', 0)
                max_val = data.get('max', float('inf'))
                if period == 'weekday':
                    text = f"  Semaine: {min_val}-{max_val if max_val != float('inf') else '∞'}"
                else:
                    text = f"  Weekend: {min_val}-{max_val if max_val != float('inf') else '∞'}"
                tooltip_text.append(text)

        return "\n".join(tooltip_text)

    def get_enhanced_post_tooltip(self, post_type: str, existing_tooltip: str = "") -> str:
        """
        Crée une infobulle enrichie combinant l'information existante et les intervalles
        """
        full_time_intervals = self.get_intervals_tooltip_text(post_type, "full_time")
        half_time_intervals = self.get_intervals_tooltip_text(post_type, "half_time")
        
        tooltip_parts = []
        if existing_tooltip:
            tooltip_parts.append(existing_tooltip)
        if full_time_intervals:
            tooltip_parts.append(full_time_intervals)
        if half_time_intervals:
            tooltip_parts.append(half_time_intervals)
            
        return "\n\n".join(tooltip_parts)


class DetailedGroupHeader(QTableWidgetItem):
    """Classe personnalisée pour les en-têtes de groupe avec fonctionnalité d'expansion"""
    def __init__(self, group_name, components=None):
        super().__init__(group_name)
        self.group_name = group_name
        self.components = components or []
        self.is_expanded = False
        
class AnimatedDetailedGroupHeader(DetailedGroupHeader):
    """En-tête de groupe amélioré avec indicateur d'expansion"""
    def __init__(self, group_name, components=None):
        super().__init__(group_name, components)
        self._arrow_expanded = "▼"
        self._arrow_collapsed = "►"
        self._update_text()

    def _update_text(self):
        """Met à jour le texte avec l'indicateur approprié"""
        arrow = self._arrow_expanded if self.is_expanded else self._arrow_collapsed
        self.setText(f"{arrow} {self.group_name}")

    def toggle_expansion(self):
        """Change l'état d'expansion et met à jour l'indicateur"""
        self.is_expanded = not self.is_expanded
        self._update_text()

class ColumnAnimation:
    """Gère l'animation des colonnes lors de l'expansion/réduction"""
    def __init__(self, table, start_col, end_col, duration=300):
        self.table = table
        self.start_col = start_col
        self.end_col = end_col
        self.duration = duration
        self.animations = []

    def expand(self):
        """Anime l'expansion des colonnes"""
        for col in range(self.start_col, self.end_col + 1):
            anim = QPropertyAnimation(self.table.horizontalHeader(), b"sectionSize")
            anim.setDuration(self.duration)
            anim.setStartValue(0)
            target_width = int(self.table.columnWidth(self.start_col - 1) * 0.6)
            anim.setEndValue(target_width)
            anim.setEasingCurve(QEasingCurve.Type.OutQuad)
            
            # Décalage progressif pour effet cascade
            QTimer.singleShot((col - self.start_col) * 50, anim.start)
            self.animations.append(anim)

    def collapse(self):
        """Anime la réduction des colonnes"""
        for col in range(self.end_col, self.start_col - 1, -1):
            anim = QPropertyAnimation(self.table.horizontalHeader(), b"sectionSize")
            anim.setDuration(self.duration)
            anim.setStartValue(self.table.columnWidth(col))
            anim.setEndValue(0)
            anim.setEasingCurve(QEasingCurve.Type.InQuad)
            
            # Décalage progressif pour effet cascade
            QTimer.singleShot((self.end_col - col) * 50, anim.start)
            self.animations.append(anim)

# gui/planning_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_management.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QTextEdit, QFileDialog, QMessageBox, QListWidget)
from PyQt6.QtCore import Qt, QDate
import os
import json
import csv
import openpyxl
from datetime import datetime, timedelta
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from calendar import monthrange, day_abbr
from openpyxl.utils import get_column_letter
from core.Constantes.models import Planning, DayPlanning, TimeSlot
from workalendar.europe import France

ORDERED_POST_TYPES = [
    "MLD1", "ACD1", "MCD1", "ALD1", "MLD2", "ACD2", "MCD2", "ALD2", "MLD3", "ACD3", "MCD3", "ALD3",
    "MLD4", "ACD4", "MCD4", "ALD4", "MLD5", "ACD5", "MCD5", "ALD5", "MMD1", "MMD2", "AMD1", "NLD1",
    "NLD2", "NMD1", "NMD2", "NMD3", "NAD1", "NAD2", "NAD3", "NZD1", "NCD1", "NCD2", "NCD3", "SMD1",
    "SAD1", "SSD1", "RMD1", "RAD1", "RSD1", "HMD1", "HAD1", "HSD1", "CMD1", "CAD1", "CSD1", "CMD2",
    "CAD2", "CSD2", "CMD3", "CAD3", "CMD4", "CAD4", "CTD1"
]
POST_TYPE_MAPPING = {
    "ML": "MLD", "AC": "ACD", "MC": "MCD", "AL": "ALD", "MM": "MMD", "AM": "AMD",
    "NL": "NLD", "NM": "NMD", "NA": "NAD", "NC": "NCD", "SM": "SMD", "SA": "SAD",
    "SS": "SSD", "RM": "RMD", "RA": "RAD", "RS": "RSD", "HM": "HMD", "HA": "HAD",
    "HS": "HSD", "CM": "CMD", "CA": "CAD", "CS": "CSD", "CT": "CTD"
}
class PlanningManagementWidget(QWidget):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.cal = France()  # Initialisation du calendrier ici
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Boutons
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Sauvegarder le planning")
        self.load_button = QPushButton("Charger un planning")
        self.export_csv_button = QPushButton("Exporter en CSV")
        self.export_excel_button = QPushButton("Exporter en Excel")
        
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.load_button)
        button_layout.addWidget(self.export_csv_button)
        button_layout.addWidget(self.export_excel_button)
        
        layout.addLayout(button_layout)

        # Liste des plannings
        self.planning_list = QListWidget()
        layout.addWidget(self.planning_list)

        # Connecter les boutons aux fonctions
        self.save_button.clicked.connect(self.save_planning)
        self.load_button.clicked.connect(self.load_planning)
        self.export_csv_button.clicked.connect(self.export_to_csv)
        self.export_excel_button.clicked.connect(self.export_to_excel)

        # Mettre à jour la liste des plannings
        self.update_planning_list()

    def save_planning(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à sauvegarder.")
            return

        planning = self.main_window.planning_tab.planning
        start_date = planning.start_date
        end_date = planning.end_date
        filename = f"P {start_date.strftime('%b')} - {end_date.strftime('%b')} - {end_date.year}.json"

        data = {
            "start_date": start_date.isoformat(),
            "end_date": end_date.isoformat(),
            "days": [
                {
                    "date": day.date.isoformat(),
                    "slots": [
                        {
                            "start_time": slot.start_time.isoformat(),
                            "end_time": slot.end_time.isoformat(),
                            "site": slot.site,
                            "slot_type": slot.slot_type,
                            "abbreviation": slot.abbreviation,
                            "assignee": slot.assignee
                        } for slot in day.slots
                    ]
                } for day in planning.days
            ]
        }

        with open(filename, 'w') as f:
            json.dump(data, f)

        self.update_planning_list()
        QMessageBox.information(self, "Succès", f"Planning sauvegardé sous {filename}")

    def load_planning(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Charger un planning", "", "Fichiers JSON (*.json)")
        if not filename:
            return

        with open(filename, 'r') as f:
            data = json.load(f)

        planning = Planning(
            start_date=datetime.fromisoformat(data['start_date']).date(),
            end_date=datetime.fromisoformat(data['end_date']).date()
        )

        for day_data in data['days']:
            day = DayPlanning(date=datetime.fromisoformat(day_data['date']).date())
            for slot_data in day_data['slots']:
                slot = TimeSlot(
                    start_time=datetime.fromisoformat(slot_data['start_time']),
                    end_time=datetime.fromisoformat(slot_data['end_time']),
                    site=slot_data['site'],
                    slot_type=slot_data['slot_type'],
                    abbreviation=slot_data['abbreviation'],
                    assignee=slot_data['assignee']
                )
                day.slots.append(slot)
            planning.days.append(day)

        if 'pre_analysis_results' in data:
            planning.pre_analysis_results = data['pre_analysis_results']
        else:
            planning.pre_analysis_results = {}

        self.main_window.planning_tab.planning = planning
        
        # Mettre à jour les dates dans PlanningViewWidget
        self.main_window.planning_tab.start_date.setDate(QDate(planning.start_date))
        self.main_window.planning_tab.end_date.setDate(QDate(planning.end_date))
        
        # Mettre à jour les dates dans DesiderataManagementWidget
        self.main_window.desiderata_tab.sync_dates_from_planning(planning.start_date, planning.end_date)
        
        self.main_window.planning_tab.update_table()
        self.main_window.update_data()
        QMessageBox.information(self, "Succès", f"Planning chargé depuis {filename}")

    def export_to_csv(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à exporter.")
            return

        folder = QFileDialog.getExistingDirectory(self, "Sélectionner le dossier d'exportation")
        if not folder:
            return

        planning = self.main_window.planning_tab.planning
        
        # Exporter le planning global
        self.export_global_planning_to_csv(planning, folder)

        # Exporter les plannings individuels
        for person in self.main_window.doctors + self.main_window.cats:
            self.export_individual_planning_to_csv(planning, person, folder)

        QMessageBox.information(self, "Succès", f"Plannings exportés en CSV dans {folder}")

    def export_to_excel(self):
        if not self.main_window.planning_tab.planning:
            QMessageBox.warning(self, "Erreur", "Aucun planning à exporter.")
            return

        folder = QFileDialog.getExistingDirectory(self, "Sélectionner le dossier d'exportation")
        if not folder:
            return

        planning = self.main_window.planning_tab.planning
        
        # Exporter tous les plannings dans un seul fichier Excel
        self.export_all_plannings_to_excel(planning, folder)

        QMessageBox.information(self, "Succès", f"Plannings exportés en Excel dans {folder}")

    def update_planning_list(self):
        self.planning_list.clear()
        plannings = [f for f in os.listdir() if f.startswith("P ") and f.endswith(".json")]
        self.planning_list.addItems(plannings)

    def export_global_planning_to_csv(self, planning, folder):
        filename = os.path.join(folder, f"Planning_global_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.csv")
        
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            
            for day in planning.days:
                date_str = day.date.strftime('%d/%m/%Y')
                slots_by_type = {}
                
                # Regrouper les slots par type de poste
                for slot in day.slots:
                    base_type = POST_TYPE_MAPPING.get(slot.abbreviation, slot.abbreviation)
                    if base_type not in slots_by_type:
                        slots_by_type[base_type] = []
                    slots_by_type[base_type].append(slot)
                
                # Écrire les lignes pour chaque type de poste ordonné
                for post_type in ORDERED_POST_TYPES:
                    base_type = post_type[:-1] if post_type[-1].isdigit() else post_type
                    index = int(post_type[-1]) if post_type[-1].isdigit() else 1
                    
                    if base_type in slots_by_type and index <= len(slots_by_type[base_type]):
                        slot = slots_by_type[base_type][index - 1]
                        writer.writerow(["+", date_str, slot.assignee or "", post_type])
                    else:
                        writer.writerow(["+", date_str, "", post_type])

    def export_individual_planning_to_csv(self, planning, person, folder):
        filename = os.path.join(folder, f"Planning_{person.name}_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.csv")
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Date', 'Créneau', 'Type', 'Site'])
            for day in planning.days:
                for slot in day.slots:
                    if slot.assignee == person.name:
                        writer.writerow([
                            day.date.strftime('%d-%m-%y'),
                            f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}",
                            slot.abbreviation,
                            slot.site
                        ])

    def export_all_plannings_to_excel(self, planning, folder):
        filename = os.path.join(folder, f"Tous_les_plannings_{planning.start_date.strftime('%d-%m-%y')}-{planning.end_date.strftime('%d-%m-%y')}.xlsx")
        workbook = openpyxl.Workbook()
        
        # Supprimer la feuille par défaut
        workbook.remove(workbook.active)
        
        # Créer une feuille pour chaque médecin et CAT
        for person in self.main_window.doctors + self.main_window.cats:
            sheet = workbook.create_sheet(title=person.name)
            self.create_individual_planning_sheet(sheet, planning, person)

        workbook.save(filename)

    def create_individual_planning_sheet(self, sheet, planning, person):
        cal = self.cal  # Utiliser le calendrier de l'instance
    
        
        # Define colors and styles
        weekend_color = PatternFill(start_color="F0F0F0", end_color="F0F0F0", fill_type="solid")
        desiderata_color = PatternFill(start_color="FFE6E6", end_color="FFE6E6", fill_type="solid")
        weekend_desiderata_color = PatternFill(start_color="FFCCCB", end_color="FFCCCB", fill_type="solid")
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

        # Set column widths
        sheet.column_dimensions['A'].width = 5  # Jour (Numeric day column)
        sheet.column_dimensions['B'].width = 5  # Semaine column (used as a separator)

        # Create the header with months and days
        months = self.get_month_names(planning.start_date, planning.end_date)
        header = ["Jour", "Sem"]  # Add "Sem" as a standalone column for reference
        for month in months:
            header.extend([month, "", "", ""])  # Four columns for J, M, AM, S
        sheet.append(header)
        
        # Merge cells for the month headers and add subheaders for J, M, AM, S
        col = 3  # Start from column 3 to skip "Jour" and "Sem"
        for month in months:
            sheet.merge_cells(start_row=1, start_column=col, end_row=1, end_column=col+3)
            for i, period in enumerate(["J", "M", "AM", "S"]):
                sheet.cell(row=2, column=col+i, value=period)
            col += 4  # Move to the next group of columns for the next month
        
        # Fill in the days and data
        current_date = planning.start_date
        while current_date <= planning.end_date:
            row = current_date.day
            month_col = (current_date.year - planning.start_date.year) * 12 + current_date.month - planning.start_date.month
            col = 3 + month_col * 4

            # Fill day number
            sheet.cell(row=row+2, column=1, value=current_date.day)

            # Fill weekday
            weekday = current_date.strftime("%a")[:2]
            sheet.cell(row=row+2, column=col, value=weekday)

            # Fill slots
            day_planning = next((d for d in planning.days if d.date == current_date), None)
            m, am, s = self.get_cell_values(day_planning, person)
            sheet.cell(row=row+2, column=col+1, value=m)
            sheet.cell(row=row+2, column=col+2, value=am)
            sheet.cell(row=row+2, column=col+3, value=s)

            # Apply styles and colors
            for i in range(4):
                cell = sheet.cell(row=row+2, column=col+i)
                cell.border = thin_border
                cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)

                is_weekend = current_date.weekday() >= 5
                is_holiday_or_bridge = cal.is_holiday(current_date) or self.is_bridge_day(current_date)
                period = ["J", "M", "AM", "S"][i]
                has_desiderata = self.has_desiderata(person, current_date, period)

                if is_weekend or is_holiday_or_bridge:
                    if has_desiderata:
                        cell.fill = weekend_desiderata_color
                    else:
                        cell.fill = weekend_color
                elif has_desiderata:
                    cell.fill = desiderata_color

            current_date += timedelta(days=1)

        # Set column widths for all J, M, AM, S columns (except "Sem")
        for col in range(3, sheet.max_column + 1):
            sheet.column_dimensions[get_column_letter(col)].width = 6

        # Apply styles to the headers
        for cell in sheet[1] + sheet[2]:
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
            cell.border = thin_border

    def is_bridge_day(self, date):
        # 1) Lundi avant un mardi férié
        if date.weekday() == 0 and self.cal.is_holiday(date + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if date.weekday() in [4, 5] and self.cal.is_holiday(date - timedelta(days=1 if date.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if date.weekday() == 5 and self.cal.is_holiday(date - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= date.weekday() <= 4:  # Jours de semaine (lundi à vendredi)
            if (self.cal.is_holiday(date - timedelta(days=1)) and 
                self.cal.is_holiday(date + timedelta(days=1))):
                return True
        
        return False
            
    def get_cell_values(self, day_planning, person):
        if not day_planning:
            return "", "", ""
        slots = [slot for slot in day_planning.slots if slot.assignee == person.name]
        periods = {"M": [], "AM": [], "S": []}
        for slot in slots:
            period = self.get_post_period(slot.abbreviation)
            periods[period].append(slot.abbreviation)
        return " ".join(periods["M"]), " ".join(periods["AM"]), " ".join(periods["S"])

    def get_post_period(self, post):
        if post in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
            return "M"
        elif post in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return "AM"
        else:
            return "S"

    def has_desiderata(self, person, date, period):
        for des in person.desiderata:
            if des.start_date <= date <= des.end_date:
                if (period == "M" and des.period == 1) or \
                (period == "AM" and des.period == 2) or \
                (period == "S" and des.period == 3):
                    return True
        return False

    def get_month_names(self, start_date, end_date):
        months = []
        current_date = start_date.replace(day=1)
        while current_date <= end_date:
            months.append(current_date.strftime("%b"))
            current_date = (current_date.replace(day=1) + timedelta(days=32)).replace(day=1)
        return months

# gui/planning_comparison_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_comparison_view.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox, QPushButton, QHeaderView, QMessageBox,
                             QTableWidget, QTableWidgetItem, QDialog, QLabel, QScrollArea, QTextEdit)
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QColor, QBrush, QFont, QTextCharFormat
from datetime import date, timedelta
from core.utils import get_post_period
from core.Constantes.models import TimeSlot


# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class PlanningComparisonView(QWidget):
    def __init__(self, planning, doctors, cats, main_window):
        super().__init__()
        self.planning = planning
        self.main_window = main_window
        self.doctors = sorted(doctors, key=lambda d: d.name)
        self.cats = sorted(cats, key=lambda c: c.name)
        self.exchange_history = []
        self.post_balance = {}
        self.init_ui()
        self.synchronize_scrollbars()
        
        self.selector1.currentIndexChanged.connect(self.on_selector_changed)
        self.selector2.currentIndexChanged.connect(self.on_selector_changed)

        self.post_groups = {
            "VmS": ["ML"],
            "VmD": ["ML", "MC"],
            "VaSD": ["AL", "AC"],
            "CmS": ["CM", "HM","MM"],
            "CmD": ["CM", "HM", "SM", "RM"],
            "CaSD": ["CA", "HA", "RA", "SA"],
            "CsSD": ["CS", "HS", "RS", "SS"],
            "NLw": ["NL"],
            "NAMw": ["NM", "NA"]
        }
        
    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteurs
        controls_layout = QHBoxLayout()
        self.selector1 = QComboBox()
        self.selector2 = QComboBox()
        self.info_label1 = QLabel("")  # Label pour afficher les informations sous le premier menu
        self.info_label2 = QLabel("")  # Label pour afficher les informations sous le deuxième menu
        self.update_selectors()
        controls_layout.addWidget(self.selector1)
        controls_layout.addWidget(self.info_label1)
        controls_layout.addWidget(self.selector2)
        controls_layout.addWidget(self.info_label2)
        layout.addLayout(controls_layout)

        
        # Tableaux de planning
        tables_layout = QHBoxLayout()
        tables_layout.setSpacing(10)  # Réduire l'espace entre les tableaux

         # Scroll areas pour les tables
        scroll_area1 = QScrollArea()
        scroll_area2 = QScrollArea()
        scroll_area1.setWidgetResizable(True)
        scroll_area2.setWidgetResizable(True)

        self.table1 = FullPlanningTable(self)
        self.table2 = FullPlanningTable(self)
        scroll_area1.setWidget(self.table1)
        scroll_area2.setWidget(self.table2)

        tables_layout.addWidget(scroll_area1)
        tables_layout.addWidget(scroll_area2)
        
        layout.addLayout(tables_layout, 1)  # Donner plus d'importance aux tableaux

        # Initialiser l'affichage
        self.update_comparison()
        
        # Ajouter les nouveaux champs en bas avec une hauteur réduite
        bottom_layout = QHBoxLayout()
        bottom_layout.setContentsMargins(0, 0, 0, 0)  # Réduire les marges

         # Champs d'historique et de bilan
        bottom_layout = QHBoxLayout()
        bottom_layout.setContentsMargins(0, 5, 0, 0)  # Réduire les marges

        # Historique des échanges
        exchange_history_layout = QVBoxLayout()
        exchange_history_layout.setSpacing(2)
        exchange_history_label = QLabel("Historique des échanges")
        exchange_history_label.setStyleSheet("font-weight: bold; margin-bottom: 2px;")
        exchange_history_layout.addWidget(exchange_history_label)
        self.exchange_history_widget = QTextEdit()
        self.exchange_history_widget.setReadOnly(True)
        self.exchange_history_widget.setMinimumHeight(100) 
        self.exchange_history_widget.setMaximumHeight(150)
        exchange_history_layout.addWidget(self.exchange_history_widget)
        bottom_layout.addLayout(exchange_history_layout)

        # Bilan des postes
        post_balance_layout = QVBoxLayout()
        post_balance_layout.setSpacing(2)
        post_balance_label = QLabel("Bilan des postes")
        post_balance_label.setStyleSheet("font-weight: bold; margin-bottom: 2px;")
        post_balance_layout.addWidget(post_balance_label)
        self.post_balance_widget = QTextEdit()
        self.post_balance_widget.setReadOnly(True)
        self.post_balance_widget.setMinimumHeight(100)  # Augmenter un peu la hauteur pour accommoder plus de contenu
        self.post_balance_widget.setMaximumHeight(150)  # Limiter la hauteur maximale
        post_balance_layout.addWidget(self.post_balance_widget)
        bottom_layout.addLayout(post_balance_layout)

        layout.addLayout(bottom_layout)

        self.setLayout(layout)

    def get_doctor_parts(self, doctor_name):
        """
        Méthode pour récupérer dynamiquement le nombre de parts d'un médecin.
        Doit être adaptée en fonction de l'endroit où cette information est stockée.
        """
        doctor = next((d for d in self.doctors if d.name == doctor_name), None)
        if doctor:
            # Vérifier si le médecin a un attribut ou une méthode pour obtenir le nombre de parts
            return getattr(doctor, 'half_parts', 1)  # Utilise 'half_parts' ou une valeur par défaut de 1
        return None

    def update_selectors(self, preserve_selection=False, allow_new_selection=False):
        current1 = self.selector1.currentText() if preserve_selection else None
        current2 = self.selector2.currentText() if preserve_selection else None

        self.selector1.blockSignals(True)
        self.selector2.blockSignals(True)

        self.selector1.clear()
        self.selector2.clear()

        options = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        self.selector1.addItems(options)
        self.selector2.addItems(options)

        if preserve_selection:
            self.selector1.setCurrentText(current1)
            self.selector2.setCurrentText(current2)

        self.selector1.blockSignals(False)
        self.selector2.blockSignals(False)

        if allow_new_selection:
            # Reconnectez les signaux pour permettre de nouvelles sélections
            self.selector1.currentIndexChanged.connect(self.on_selector_changed)
            self.selector2.currentIndexChanged.connect(self.on_selector_changed)

        # Mettre à jour les labels d'information
        self.update_info_label1()
        self.update_info_label2()
                
        # Colorer les CAT
        for i in range(self.selector1.count()):
            if i > len(self.doctors):
                self.selector1.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)
                self.selector2.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)

        # Conserver le focus sur le sélecteur pour parcourir avec les flèches
        self.selector1.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.selector2.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    def on_selector_changed(self):
        sender = self.sender()
        if sender == self.selector1:
            self.current_selection1 = sender.currentText()
            self.table1.populate_table(self.current_selection1)
        elif sender == self.selector2:
            self.current_selection2 = sender.currentText()
            self.table2.populate_table(self.current_selection2)
        
        self.update_info_label1()
        self.update_info_label2()


    def update_info_label1(self):
        selected = self.selector1.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label1.setText("Médecin à plein temps")
            else:
                self.info_label1.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label1.setText("CAT")
        else:
            self.info_label1.setText("")

    def update_info_label2(self):
        selected = self.selector2.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label2.setText("Médecin à plein temps")
            else:
                self.info_label2.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label2.setText("CAT")
        else:
            self.info_label2.setText("")

    def update_comparison(self, preserve_selection=False):
        if preserve_selection and hasattr(self, 'current_selection1') and hasattr(self, 'current_selection2'):
            selected1 = self.current_selection1
            selected2 = self.current_selection2
        else:
            selected1 = self.selector1.currentText()
            selected2 = self.selector2.currentText()
        
        self.table1.populate_table(selected1)
        self.table2.populate_table(selected2)
        
        self.update_info_label1()
        self.update_info_label2()
        
        if preserve_selection:
            self.selector1.setCurrentText(selected1)
            self.selector2.setCurrentText(selected2)
    
    def reset_selectors(self):
        self.selector1.setCurrentIndex(0)
        self.selector2.setCurrentIndex(0)
        self.update_comparison()

    def save_current_selections(self):
        self.current_selection1 = self.selector1.currentText()
        self.current_selection2 = self.selector2.currentText()

    def on_assignment_changed(self, old_assignee, new_assignee, post_type):
        self.save_current_selections()
        self.main_window.planning_tab.update_table()
        self.main_window.update_stats_view()
        self.main_window.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
        
        # Mettre à jour les sélecteurs en permettant de nouvelles sélections
        self.update_selectors(preserve_selection=True, allow_new_selection=True)
        
        # Mettre à jour les tables
        self.table1.populate_table(self.current_selection1)
        self.table2.populate_table(self.current_selection2)
        
        # Mettre à jour les informations
        self.update_info_label1()
        self.update_info_label2()
        
         # Mettre à jour l'historique des échanges
        self.update_exchange_history(old_assignee, new_assignee, post_type)
      

        # Mettre à jour les excédents/déficits de postes
        self.update_post_balance(old_assignee, new_assignee, post_type)
        
    def synchronize_scrollbars(self):
        """
        Synchronise les barres de défilement des deux tables pour un défilement horizontal et vertical simultané.
        """
        # Synchronisation du défilement vertical
        self.table1.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table2)
        self.table2.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table1)

        # Synchronisation du défilement horizontal
        self.table1.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table2)
        self.table2.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table1)

        self.is_syncing_vertical = False
        self.is_syncing_horizontal = False

    def sync_scroll_vertical_table2(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table2.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_vertical_table1(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table1.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_horizontal_table2(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table2.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False

    def sync_scroll_horizontal_table1(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table1.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False

    def update_exchange_history(self, old_assignee, new_assignee, post_type):
        exchange = f"{old_assignee} donne {post_type} à {new_assignee}"
        self.exchange_history.append(exchange)

        cursor = self.exchange_history_widget.textCursor()
        format = QTextCharFormat()
        format.setForeground(QBrush(QColor(0, 0, 0)))  # Noir pour tous les échanges
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertText(exchange + "\n", format)

       
 

    def update_post_balance(self, old_assignee, new_assignee, post_type):
        if old_assignee not in self.post_balance:
            self.post_balance[old_assignee] = {"posts": {}, "groups": {}}
        if new_assignee not in self.post_balance:
            self.post_balance[new_assignee] = {"posts": {}, "groups": {}}

        # Mise à jour des postes individuels
        self.post_balance[old_assignee]["posts"][post_type] = self.post_balance[old_assignee]["posts"].get(post_type, 0) - 1
        self.post_balance[new_assignee]["posts"][post_type] = self.post_balance[new_assignee]["posts"].get(post_type, 0) + 1

        # Mise à jour des groupes de postes
        for group, posts in self.post_groups.items():
            if post_type in posts:
                self.post_balance[old_assignee]["groups"][group] = self.post_balance[old_assignee]["groups"].get(group, 0) - 1
                self.post_balance[new_assignee]["groups"][group] = self.post_balance[new_assignee]["groups"].get(group, 0) + 1

        self.post_balance_widget.clear()
        for assignee, balance in self.post_balance.items():
            non_zero_posts = {post: count for post, count in balance["posts"].items() if count != 0}
            non_zero_groups = {group: count for group, count in balance["groups"].items() if count != 0}
            
            if non_zero_posts or non_zero_groups:
                post_text = ", ".join([f"{count:+d}{post}" for post, count in non_zero_posts.items()])
                group_text = ", ".join([f"{count:+d}{group}" for group, count in non_zero_groups.items()])
                
                self.post_balance_widget.append(f"{assignee}:")
                self.post_balance_widget.append(f"  Postes: {post_text}")
                self.post_balance_widget.append(f"  Groupes: {group_text}")
                self.post_balance_widget.append("")  # Ligne vide pour séparer les entrées
                
    def reset_view(self):
        self.exchange_history = []
        self.post_balance = {}
        self.exchange_history_widget.clear()
        self.post_balance_widget.clear()
        self.table1.clear()
        self.table2.clear()
        self.table1.setRowCount(0)
        self.table1.setColumnCount(0)
        self.table2.setRowCount(0)
        self.table2.setColumnCount(0)
        self.selector1.setCurrentIndex(0)
        self.selector2.setCurrentIndex(0)

class FullPlanningTable(QTableWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.colors = {
            "primary": {
                "weekend": QColor(255, 150, 150),     # Rouge plus foncé pour weekend
                "normal": QColor(255, 200, 200)       # Rouge clair pour jours normaux
            },
            "secondary": {
                "weekend": QColor(150, 200, 255),     # Bleu plus foncé pour weekend
                "normal": QColor(180, 220, 255)       # Bleu clair pour jours normaux
            },
            "base": {
                "weekend": QColor(220, 220, 220),    # Gris pour weekend
                "normal": QColor(255, 255, 255)      # Blanc pour jours normaux
            }
        }
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.verticalHeader().setVisible(False)
        
        self.itemClicked.connect(self.on_item_clicked)
        self.cellDoubleClicked.connect(self.on_item_double_clicked)

    def get_cell_color(self, date, is_weekend, person, slot):
        """Détermine la couleur de la cellule en fonction des desiderata"""
        if not person:
            return self.colors["base"]["weekend" if is_weekend else "normal"]

        for desiderata in person.desiderata:
            if (desiderata.start_date <= date <= desiderata.end_date and
                desiderata.overlaps_with_slot(slot)):
                priority = getattr(desiderata, 'priority', 'primary')
                return self.colors[priority]["weekend" if is_weekend else "normal"]

        return self.colors["base"]["weekend" if is_weekend else "normal"]


    def populate_table(self, selected):
        """Remplit le tableau avec les données du planning"""
        if not self.parent.planning or not self.parent.planning.days:
            return

        self.clear()

        start_date = self.parent.planning.start_date
        end_date = self.parent.planning.end_date
        
        # Calcul du nombre de mois
        total_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

        # Configuration du tableau
        self.setRowCount(31)
        self.setColumnCount(total_months * 4 + 1)

        # Création des en-têtes
        headers = ["Jour"]
        current_date = start_date.replace(day=1)
        for _ in range(total_months):
            month_name = current_date.strftime("%b")
            headers.extend([f"{month_name}\nJ", f"{month_name}\nM", f"{month_name}\nAM", f"{month_name}\nS"])
            current_date = (current_date.replace(day=28) + timedelta(days=4)).replace(day=1)
        self.setHorizontalHeaderLabels(headers)

        # Définition des couleurs
        colors = {
            "primary": {
                "weekend": QColor(255, 150, 150),     # Rouge plus foncé pour weekend
                "normal": QColor(255, 200, 200)       # Rouge clair pour jours normaux
            },
            "secondary": {
                "weekend": QColor(150, 200, 255),     # Bleu plus foncé pour weekend
                "normal": QColor(180, 220, 255)       # Bleu clair pour jours normaux
            },
            "base": {
                "weekend": WEEKEND_COLOR,
                "normal": WEEKDAY_COLOR
            }
        }

        # Remplissage des données
        current_date = start_date
        while current_date <= end_date:
            day_row = current_date.day - 1
            month_col = (current_date.year - start_date.year) * 12 + current_date.month - start_date.month
            col_offset = month_col * 4 + 1

            # Configuration du jour et du jour de la semaine
            day_item = QTableWidgetItem(str(current_date.day))
            day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.setItem(day_row, 0, day_item)
            
            weekday_item = QTableWidgetItem(self.get_weekday_abbr(current_date.weekday()))
            weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            weekday_item.setForeground(QBrush(WEEKDAY_TEXT_COLOR))
            font = QFont()
            font.setPointSize(8)
            weekday_item.setFont(font)
            self.setItem(day_row, col_offset, weekday_item)

            # Traitement du planning du jour
            day_planning = next((day for day in self.parent.planning.days if day.date == current_date), None)
            if day_planning:
                is_weekend_or_holiday = day_planning.is_weekend or day_planning.is_holiday_or_bridge

                # Récupération des posts
                posts = [slot for slot in day_planning.slots if (selected == "Non attribué" and slot.assignee is None) or slot.assignee == selected]
                
                # Tri par période
                morning_posts = [p for p in posts if get_post_period(p) == 0]
                afternoon_posts = [p for p in posts if get_post_period(p) == 1]
                evening_posts = [p for p in posts if get_post_period(p) == 2]

                # Création des cellules pour chaque période
                for i, post_list in enumerate([morning_posts, afternoon_posts, evening_posts]):
                    posts_text = ", ".join([p.abbreviation for p in post_list])
                    if selected == "Non attribué":
                        unassigned_posts = [slot.abbreviation for slot in day_planning.slots 
                                        if slot.assignee is None and self.get_post_period(slot.abbreviation) == i]
                        posts_text = ", ".join(unassigned_posts)
                    
                    item = QTableWidgetItem(posts_text)
                    item.setData(Qt.ItemDataRole.UserRole, day_planning)
                    
                    # Couleur de base
                    base_color = colors["base"]["weekend" if is_weekend_or_holiday else "normal"]
                    item.setBackground(QBrush(base_color))
                    
                    # Vérification des desiderata
                    selected_person = next((p for p in self.parent.doctors + self.parent.cats if p.name == selected), None)
                    if selected_person:
                        for desiderata in selected_person.desiderata:
                            if desiderata.start_date <= current_date <= desiderata.end_date:
                                if desiderata.period == i + 1:
                                    priority = getattr(desiderata, 'priority', 'primary')
                                    color = colors[priority]["weekend" if is_weekend_or_holiday else "normal"]
                                    item.setBackground(QBrush(color))
                    
                    self.setItem(day_row, col_offset + i + 1, item)

            current_date += timedelta(days=1)

        # Ajustement de la taille des cellules
        for row in range(self.rowCount()):
            self.setRowHeight(row, 20)

        for col in range(self.columnCount()):
            if col == 0:
                self.setColumnWidth(col, 30)
            elif (col - 1) % 4 == 0:
                self.setColumnWidth(col, 30)
            else:
                self.setColumnWidth(col, 40)

        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                
    def toggle_cell(self, item):
        current_color = item.background().color()
        is_weekend_or_holiday = current_color == WEEKEND_COLOR
        
        if current_color == WEEKEND_COLOR:
            new_color = WEEKEND_DESIDERATA_COLOR
        elif current_color == WEEKEND_DESIDERATA_COLOR:
            new_color = WEEKEND_COLOR
        elif current_color == WEEKDAY_COLOR:
            new_color = DESIDERATA_COLOR
        else:
            new_color = WEEKDAY_COLOR
        
        item.setBackground(QBrush(new_color))

    def get_weekday_abbr(self, weekday):
        return ["L", "M", "M", "J", "V", "S", "D"][weekday]


    def get_post_period(self, post):
        if post in ["ML","MC","MM", "CM", "HM", "SM", "RM"]:
            return 0  # Matin
        elif post in ["CA", "HA", "SA", "RA", "AL", "AC"]:
            return 1  # Après-midi
        else:
            return 2  # Soir


    def on_item_clicked(self, item):
        if item.column() > 1:  # Ignorer les colonnes Jour et Sem
            row = item.row()
            column = item.column()

            if self == self.parent.table1:
                other_table = self.parent.table2
            else:
                other_table = self.parent.table1
            
            other_table.setCurrentCell(row, column)

    def on_item_double_clicked(self, row, column):
        if column > 1 and (column - 1) % 4 != 0:
            item = self.item(row, column)
            if item and item.data(Qt.ItemDataRole.UserRole):
                day = item.data(Qt.ItemDataRole.UserRole)
                
                if self == self.parent.table1:
                    current_assignee = self.parent.selector1.currentText()
                    compared_assignee = self.parent.selector2.currentText()
                else:
                    current_assignee = self.parent.selector2.currentText()
                    compared_assignee = self.parent.selector1.currentText()

                # Vérifier si un échange est possible
                if current_assignee == compared_assignee:
                    QMessageBox.warning(self, "Échange impossible", "Impossible d'échanger avec le même assigné.")
                    return

                period = ((column - 1) % 4) - 1
                period_names = ["Matin", "Après-midi", "Soir"]
                period_name = period_names[period]

                if current_assignee == "Non attribué":
                    available_posts = [slot.abbreviation for slot in day.slots 
                                    if slot.assignee is None and self.get_post_period(slot.abbreviation) == period]
                else:
                    available_posts = [slot.abbreviation for slot in day.slots 
                                    if slot.assignee == current_assignee and self.get_post_period(slot.abbreviation) == period]

                if not available_posts:
                    QMessageBox.warning(self, "Échange impossible", "Aucun poste disponible pour l'échange.")
                    return

                dialog = PostAssignmentDialog(day, current_assignee, self.parent.doctors, self.parent.cats, compared_assignee, available_posts, period_name)
                if dialog.exec() == QDialog.DialogCode.Accepted:
                    new_assignee = dialog.get_selected_assignee()
                    selected_post = dialog.get_selected_post()
                    self.update_assignment(day, current_assignee, new_assignee, selected_post)

    def update_assignment(self, day, current_assignee, new_assignee, selected_post):
        if current_assignee == new_assignee:
            return  # Pas de changement nécessaire

        changes_made = False
        for slot in day.slots:
            if slot.abbreviation == selected_post:
                if current_assignee == "Non attribué" and slot.assignee is None:
                    slot.assignee = new_assignee
                    changes_made = True
                elif current_assignee != "Non attribué" and slot.assignee == current_assignee:
                    slot.assignee = None if new_assignee == "Non attribué" else new_assignee
                    changes_made = True
        if changes_made:
            self.parent.on_assignment_changed(current_assignee, new_assignee, selected_post)

class PostAssignmentDialog(QDialog):
    def __init__(self, day, current_assignee, doctors, cats, compared_assignee, available_posts, period_name):
        super().__init__()
        self.day = day
        self.current_assignee = current_assignee
        self.doctors = doctors
        self.cats = cats
        self.compared_assignee = compared_assignee
        self.available_posts = available_posts
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Affichage du nom de l'assigné par défaut (comparé)
        layout.addWidget(QLabel(f"Nouvel assigné pour le {self.day.date}:"))
        
        # Sélecteur pour l'assigné (docteurs et CAT)
        self.assignee_selector = QComboBox()
        options = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        options = [option for option in options if option != self.current_assignee]  # Exclure l'assigné actuel
        self.assignee_selector.addItems(options)
        
        # Définir l'assigné par défaut comme celui comparé, sauf s'il est identique à l'actuel
        if self.compared_assignee != self.current_assignee:
            self.assignee_selector.setCurrentText(self.compared_assignee)

        # Sélecteur pour les postes disponibles (seulement les postes présents dans la case)
        layout.addWidget(QLabel("Choisir les postes à échanger :"))
        self.post_selector = QComboBox()
        self.post_selector.addItems(self.available_posts)
        layout.addWidget(self.post_selector)

        # Boutons d'action
        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addLayout(buttons)

        
        
        layout.addWidget(self.assignee_selector)

    def get_selected_assignee(self):
        return self.assignee_selector.currentText()

    def get_selected_post(self):
        return self.post_selector.currentText()

    

# gui/__init__.py

# © 2024 HILAL Arkane. Tous droits réservés.


# gui/splash_screen.py

# gui/splash_screen.py

from PyQt6.QtWidgets import QSplashScreen
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from core.utils import resource_path

class SplashScreen(QSplashScreen):
    def __init__(self):
        super().__init__()
        pixmap = QPixmap(resource_path("icons/logo_SOSplanning.png"))
        
        # Réduire la taille de l'image à un tiers de sa taille originale
        scaled_size = pixmap.size() / 3
        scaled_pixmap = pixmap.scaled(scaled_size, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        
        self.setPixmap(scaled_pixmap)
        self.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.FramelessWindowHint)

    def update_message(self, message):
        self.showMessage(message, Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, Qt.GlobalColor.black)

# gui/personnel_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/personnel_management.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                             QFormLayout, QLineEdit, QSpinBox, QMessageBox, QSizePolicy,
                             QLabel, QFrame, QTableWidget, QTableWidgetItem, QDialog, QGridLayout)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont, QColor, QIcon
from core.Constantes.models import Doctor, CAT, ALL_POST_TYPES, Desiderata
from core.Constantes.data_persistence import DataPersistence
from .post_configuration import PostConfigurationWidget
from .styles import EDIT_DELETE_BUTTON_STYLE


class PersonnelManagementWidget(QWidget):
    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.data_persistence = DataPersistence()
        self.init_ui()
        
    

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        tab_widget = QTabWidget()
        
        # Onglet des médecins
        doctors_tab = QWidget()
        doctors_layout = QVBoxLayout(doctors_tab)

        grid_container = QWidget()
        grid_container.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        self.doctors_grid = QGridLayout(grid_container)
        self.doctors_grid.setSpacing(0)
        self.doctors_grid.setContentsMargins(1, 1, 1, 1)

        doctors_layout.addWidget(grid_container)

        add_doctor_button = QPushButton("Ajouter un médecin")
        add_doctor_button.clicked.connect(lambda: self.add_personnel("Médecin"))
        add_doctor_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        doctors_layout.addWidget(add_doctor_button)

        tab_widget.addTab(doctors_tab, "Médecins")

        # Onglet des CAT
        cats_tab = QWidget()
        cats_layout = QVBoxLayout(cats_tab)
        
        self.cats_grid = QWidget()
        self.cats_grid.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        cats_layout.addWidget(self.cats_grid)
        
        add_cat_button = QPushButton("Ajouter un CAT")
        add_cat_button.clicked.connect(lambda: self.add_personnel("CAT"))
        add_cat_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        cats_layout.addWidget(add_cat_button)
        
        tab_widget.addTab(cats_tab, "CAT")

        # Nouvel onglet pour la configuration des postes
        self.post_config_tab = PostConfigurationWidget(self.post_configuration, self.main_window)
        tab_widget.addTab(self.post_config_tab, "Configuration des postes")

        layout.addWidget(tab_widget)
        self.update_tables()

    def update_tables(self):
        self.update_doctors_table()
        self.update_cats_table()

    def update_doctors_table(self):
        for i in reversed(range(self.doctors_grid.count())): 
            self.doctors_grid.itemAt(i).widget().setParent(None)

        sorted_doctors = sorted(self.doctors, key=lambda x: x.name.lower())

        for index, doctor in enumerate(sorted_doctors):
            row = index // 2
            col = index % 2 * 4

            doctor_frame = QFrame()
            doctor_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                }
            """)
            doctor_layout = QHBoxLayout(doctor_frame)
            doctor_layout.setContentsMargins(5, 5, 5, 5)
            doctor_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            doctor_layout.addWidget(number_label)

            name_label = QLabel(doctor.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            doctor_layout.addWidget(name_label)

            half_parts_label = QLabel(f"Demi-parts: {doctor.half_parts}")
            doctor_layout.addWidget(half_parts_label)

            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier")
            edit_button.clicked.connect(lambda _, p=doctor: self.edit_personnel(p))
            edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer")
            delete_button.clicked.connect(lambda _, p=doctor: self.delete_personnel(p))

            delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 3px 8px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 1px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                doctor_layout.addWidget(button)

            if doctor.half_parts == 1:
                doctor_frame.setStyleSheet("""
                    QFrame {
                        border: 1px solid #ddd;
                        background-color: #FFFFD0;
                    }
                """)

            self.doctors_grid.addWidget(doctor_frame, row, col, 1, 4)

        for i in range(8):
            self.doctors_grid.setColumnStretch(i, 1)
            
    def update_cats_table(self):
        if self.cats_grid.layout():
            QWidget().setLayout(self.cats_grid.layout())

        cats_layout = QVBoxLayout(self.cats_grid)
        cats_layout.setSpacing(0)
        cats_layout.setContentsMargins(0, 0, 0, 0)

        sorted_cats = sorted(self.cats, key=lambda x: x.name.lower())

        for index, cat in enumerate(sorted_cats):
            cat_frame = QFrame()
            cat_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                    padding: 2px;
                }
            """)
            cat_layout = QHBoxLayout(cat_frame)
            cat_layout.setContentsMargins(5, 5, 5, 5)
            cat_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            number_label.setFixedWidth(20)
            cat_layout.addWidget(number_label)

            name_label = QLabel(cat.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            cat_layout.addWidget(name_label)

            cat_layout.addStretch(1)

            edit_button = QPushButton("Modifier")
            edit_button.clicked.connect(lambda _, c=cat: self.edit_personnel(c))
            delete_button = QPushButton("Supprimer")
            delete_button.clicked.connect(lambda _, c=cat: self.delete_personnel(c))
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 2px 5px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 0px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                button.setFixedSize(70, 25)
                cat_layout.addWidget(button)

            cats_layout.addWidget(cat_frame)

        cats_layout.addStretch(1)

    def add_personnel(self, personnel_type):
        if personnel_type == "Médecin":
            dialog = PersonnelDialog(self, personnel_type=personnel_type)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                self.doctors.append(Doctor(name, half_parts))
        else:  # CAT
            dialog = CATDialog(self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()
                new_cat = CAT(name)
                self.cats.append(new_cat)
        self.update_tables()
        self.save_data()

    def delete_personnel(self, person):
        print(f"Tentative de suppression de : {person.name}")
        confirm = QMessageBox.question(self, "Confirmer la suppression", 
                                    f"Êtes-vous sûr de vouloir supprimer {person.name} ?",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            print("Confirmation de suppression.")
            if isinstance(person, Doctor):
                self.doctors.remove(person)
            else:
                self.cats.remove(person)
            self.update_tables()
            self.save_data()

    def edit_personnel(self, person):
        print(f"Tentative de modification de : {person.name}")
        if isinstance(person, Doctor):
            dialog = PersonnelDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                person.name = name
                person.half_parts = half_parts
                print(f"Médecin modifié : {person.name}, demi-parts : {person.half_parts}")
        else:  # CAT
            dialog = CATDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()
                person.name = name
                print(f"CAT modifié : {person.name}")
        self.update_tables()
        self.save_data()


    def save_data(self):
        print("Sauvegarde des données...")
        if hasattr(self, 'data_persistence'):
            self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        else:
            print("Attention : Aucun mécanisme de persistance des données n'est configuré.")

class PersonnelDialog(QDialog):
    def __init__(self, parent=None, person=None, personnel_type=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier personnel")
        self.person = person
        self.personnel_type = personnel_type if person is None else ("Médecin" if isinstance(person, Doctor) else "CAT")
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        if self.personnel_type == "Médecin":
            self.half_parts_input = QSpinBox()
            self.half_parts_input.setRange(1, 2)
            layout.addRow("Demi-parts:", self.half_parts_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.person:
            self.name_input.setText(self.person.name)
            if isinstance(self.person, Doctor):
                self.half_parts_input.setValue(self.person.half_parts)

    def get_personnel_info(self):
        half_parts = self.half_parts_input.value() if self.personnel_type == "Médecin" else 0
        return self.name_input.text(), self.personnel_type, half_parts
    

    
class CATDialog(QDialog):
    def __init__(self, parent=None, cat=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier CAT")
        self.cat = cat
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.cat:
            self.name_input.setText(self.cat.name)

    def get_cat_info(self):
        return self.name_input.text()




# gui/planning_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/planning_view.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QLabel,
                             QTableWidget, QTableWidgetItem, QDateEdit, QMessageBox, QProgressBar)
from PyQt6.QtCore import Qt, QDate, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QColor, QBrush, QFont
from core.Generator.planning_generator import PlanningGenerator
from core.Constantes.models import ALL_POST_TYPES, WEEKDAY_COMBINATIONS, WEEKEND_COMBINATIONS
from datetime import date, timedelta
from .doctor_planning_view import DoctorPlanningView
from PyQt6.QtCore import pyqtSignal
from PyQt6.QtCore import pyqtSignal


# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class PlanningGenerationThread(QThread):
    progress_update = pyqtSignal(int)
    planning_generated = pyqtSignal(object)

    def __init__(self, planning_generator, start_date, end_date, existing_planning=None):
        super().__init__()
        self.planning_generator = planning_generator
        self.start_date = start_date
        self.end_date = end_date
        self.existing_planning = existing_planning

    def run(self):
        if self.existing_planning:
            planning = self.planning_generator.generate_planning(self.start_date, self.end_date)
        else:
            planning = self.planning_generator.generate_planning(self.start_date, self.end_date)
        self.planning_generated.emit(planning)

class PlanningViewWidget(QWidget):
    dates_changed = pyqtSignal(date, date)

    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        self.planning = None
        self.weekend_validated = False
        self.init_ui()
        self.weekend_color = QColor(255, 200, 200)
        self.update_timer = QTimer(self)
        self.update_timer.setSingleShot(True)
        self.update_timer.timeout.connect(self._delayed_update)
        self.pending_update = None


    def init_ui(self):
        layout = QVBoxLayout(self)

        # Contrôles de date et bouton de génération
        date_layout = QHBoxLayout()
        
        self.start_date = QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setCalendarPopup(True)

        # Définir les dates par défaut
        today = date.today()
        end_date = today + timedelta(days=4*30)  # Environ 4 mois plus tard
        self.start_date.setDate(QDate(today.year, today.month, today.day))
        self.end_date.setDate(QDate(end_date.year, end_date.month, end_date.day))

        date_layout.addWidget(QLabel("Du:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("Au:"))
        date_layout.addWidget(self.end_date)
        
        # Bouton de génération
        generate_button = QPushButton("Générer le planning")
        generate_button.clicked.connect(self.generate_planning)
        generate_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #e8e8e8;
            }
        """)
        self.generate_button = QPushButton("Générer le planning")
        self.generate_button.clicked.connect(self.generate_planning)
        date_layout.addWidget(self.generate_button)
        self.validate_weekends_button = QPushButton("Valider les weekends")
        self.validate_weekends_button.clicked.connect(self.validate_weekends)
        self.validate_weekends_button.setEnabled(False)  # Désactivé par défaut
        date_layout.addWidget(self.validate_weekends_button)

        date_layout.setStretchFactor(self.start_date, 2)
        date_layout.setStretchFactor(self.end_date, 2)
        date_layout.setStretchFactor(generate_button, 1)
        
        layout.addLayout(date_layout)

        # Ajout du nouveau bouton de réinitialisation
        self.reset_planning_button = QPushButton("Réinitialiser le planning")
        self.reset_planning_button.clicked.connect(self.reset_planning)
        self.reset_planning_button.setEnabled(True)  # Activez le bouton
        date_layout.addWidget(self.reset_planning_button)

        # Barre de progression
        self.progress_bar = QProgressBar(self)
        layout.addWidget(self.progress_bar)

        # Créer un widget avec des onglets
        tab_widget = QTabWidget()
        
        # Vue globale du planning
        self.global_view = QTableWidget(self)
        tab_widget.addTab(self.global_view, "Vue globale")

        # Nouvelle vue du planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        tab_widget.addTab(self.doctor_planning_view, "Planning par médecin")

        layout.addWidget(tab_widget)
        
        self.start_date.dateChanged.connect(self.on_date_changed)
        self.end_date.dateChanged.connect(self.on_date_changed)

    def update_data(self, doctors, cats, post_configuration):
        # Stocker les données à mettre à jour et démarrer le timer
        self.pending_update = (doctors, cats, post_configuration)
        if not self.update_timer.isActive():
            self.update_timer.start(100)

    def _delayed_update(self):
        if self.pending_update:
            doctors, cats, post_configuration = self.pending_update
            self.doctors = doctors
            self.cats = cats
            self.post_configuration = post_configuration
            self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
            if self.planning:
                self.update_table()
                self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
            self.pending_update = None
            
    def update_dates(self, start_date, end_date):
        self.start_date.setDate(QDate(start_date))
        self.end_date.setDate(QDate(end_date))
        self.on_date_changed()  # Ceci émettra le signal dates_changed
        
    def on_date_changed(self):
        start_date = self.start_date.date().toPyDate()
        end_date = self.end_date.date().toPyDate()
        self.dates_changed.emit(start_date, end_date)

    def generate_planning(self, existing_planning=None):
        start_date = self.start_date.date().toPyDate()
        end_date = self.end_date.date().toPyDate()

        if start_date > end_date:
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return

        self.progress_bar.setValue(0)
        self.generation_thread = PlanningGenerationThread(self.planning_generator, start_date, end_date, existing_planning)
        self.generation_thread.progress_update.connect(self.progress_bar.setValue)
        self.generation_thread.planning_generated.connect(self.planning_generated)
        self.generation_thread.start()


    def planning_generated(self, planning):
        if planning is None:
            QMessageBox.warning(self, "Erreur", "Impossible de générer le planning. Veuillez vérifier les desideratas des médecins.")
            self.progress_bar.setValue(0)
        else:
            self.planning = planning
            self.update_table()
            self.doctor_planning_view.update_view(planning, self.doctors, self.cats)
            self.progress_bar.setValue(100)
            self.validate_weekends_button.setEnabled(True)  # Activer le bouton après la génération
            self.main_window.update_data()
            
            # Afficher les desideratas non respectés
            # unrespected_desiderata = self.planning_generator.get_unrespected_desiderata()
            
    def validate_weekends(self):
        if self.planning:
            self.weekend_validated = True
            self.generate_button.setText("Générer planning semaine")
            self.generate_button.clicked.disconnect()
            self.generate_button.clicked.connect(self.generate_weekday_planning)
            self.validate_weekends_button.setEnabled(False)
            QMessageBox.information(self, "Validation", "Les weekends ont été validés. Vous pouvez maintenant générer le planning de la semaine.")
        else:
            QMessageBox.warning(self, "Erreur", "Aucun planning n'a été généré. Veuillez d'abord générer un planning.")

    def generate_weekday_planning(self):
        if self.weekend_validated:
            # Appeler la méthode pour générer le planning de la semaine
            self.planning = self.planning_generator.generate_weekday_planning(self.planning)
            self.update_table()
            self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
            self.main_window.update_data()
            QMessageBox.information(self, "Génération terminée", "Le planning de la semaine a été généré avec succès.")
        else:
            QMessageBox.warning(self, "Erreur", "Veuillez d'abord valider les weekends avant de générer le planning de la semaine.")
            
    def display_constraint_analysis(self):
            if hasattr(self.planning_generator, 'pre_analyzer'):
                analysis = self.planning_generator.pre_analyzer.analyze()
                if analysis is not None and 'constraint_analysis' in analysis:
                    constraint_analysis = analysis['constraint_analysis']
                    
                    message = f"Analyse des contraintes :\n"
                    message += f"Conflits potentiels : {constraint_analysis.get('potential_conflicts', 'N/A')}\n"
                    # Ajoutez d'autres informations sur les contraintes ici
                    
                    QMessageBox.information(self, "Analyse des contraintes", message)
                else:
                    QMessageBox.warning(self, "Erreur", "L'analyse des contraintes n'est pas disponible.")
            else:
                QMessageBox.warning(self, "Erreur", "L'analyseur de pré-planning n'est pas disponible.")
                
 

    def update_table(self):
        if not self.planning:
            return

        self.global_view.clear()
        self.global_view.setRowCount(0)
        self.global_view.setColumnCount(5)
        self.global_view.setHorizontalHeaderLabels(["Date", "Créneau", "Type", "Site", "Assigné à"])

        # Définition des couleurs pour les desiderata
        colors = {
            "primary": {
                "weekend": QColor(255, 150, 150),     # Rouge plus foncé pour weekend
                "normal": QColor(255, 200, 200)       # Rouge clair pour jours normaux
            },
            "secondary": {
                "weekend": QColor(150, 200, 255),     # Bleu plus foncé pour weekend
                "normal": QColor(180, 220, 255)       # Bleu clair pour jours normaux
            }
        }

        for day_planning in self.planning.days:
            for slot in day_planning.slots:
                row = self.global_view.rowCount()
                self.global_view.insertRow(row)
                
                date_item = QTableWidgetItem(day_planning.date.strftime("%d-%m-%y"))
                self.global_view.setItem(row, 0, date_item)
                self.global_view.setItem(row, 1, QTableWidgetItem(f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}"))
                self.global_view.setItem(row, 2, QTableWidgetItem(slot.abbreviation))
                self.global_view.setItem(row, 3, QTableWidgetItem(slot.site))
                self.global_view.setItem(row, 4, QTableWidgetItem(slot.assignee or "Non attribué"))

                # Coloration selon le type de jour et les desiderata
                is_weekend = day_planning.is_weekend or day_planning.is_holiday_or_bridge
                base_color = WEEKEND_COLOR if is_weekend else WEEKDAY_COLOR

                # Vérifier les desiderata de l'assigné
                if slot.assignee:
                    assignee = next((d for d in self.doctors + self.cats if d.name == slot.assignee), None)
                    if assignee:
                        for desiderata in assignee.desiderata:
                            if (desiderata.start_date <= day_planning.date <= desiderata.end_date and
                                desiderata.overlaps_with_slot(slot)):
                                priority = getattr(desiderata, 'priority', 'primary')
                                color_key = "weekend" if is_weekend else "normal"
                                base_color = colors[priority][color_key]
                                break

                # Appliquer la couleur
                for col in range(self.global_view.columnCount()):
                    self.global_view.item(row, col).setBackground(QBrush(base_color))

        self.global_view.resizeColumnsToContents()
        
        # Fixer la hauteur des lignes
        for row in range(self.global_view.rowCount()):
            self.global_view.setRowHeight(row, 25)

        # Empêcher l'édition des cellules
        self.global_view.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        
    def update_post_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        self.planning_generator = PlanningGenerator(self.doctors, self.cats, self.post_configuration)
        if self.planning:
            self.generate_planning(self.planning)  # Passez le planning existant
        else:
            self.generate_planning()  # Créez un nouveau planning si aucun n'existe
            
    def update_data(self, doctors, cats, post_configuration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        if self.planning:
            self.update_table()
            self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)

    def update_planning(self, updated_planning):
        self.planning = updated_planning
        self.update_table()
        self.doctor_planning_view.update_view(updated_planning, self.doctors, self.cats)
        self.main_window.update_data()


    def reset_planning(self):
        confirm = QMessageBox.question(self, "Confirmation", 
                                    "Êtes-vous sûr de vouloir réinitialiser le planning ? Toutes les données de planning seront perdues.",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                    QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            # Réinitialiser le planning
            self.planning = None
            self.weekend_validated = False

            # Réinitialiser l'état des boutons
            self.generate_button.setText("Générer le planning")
            self.generate_button.setEnabled(True)
            self.validate_weekends_button.setEnabled(False)

            # Déconnecter et reconnecter le signal pour s'assurer qu'il n'y a qu'une seule connexion
            self.generate_button.clicked.disconnect()
            self.generate_button.clicked.connect(self.generate_planning)

            # Réinitialiser les compteurs et attributs des médecins et CAT
            for doctor in self.doctors:
                doctor.night_shifts = {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0}
                doctor.nm_shifts = {'NMs': 0, 'NMd': 0, 'total': 0}
                doctor.combo_counts = {combo: 0 for combo in WEEKEND_COMBINATIONS}
                doctor.group_counts = {group: 0 for group in ["CmS", "CmD", "CaS", "CaD", "CsSD", "VmS", "VmD", "VaSD"]}
                doctor.weekday_night_shifts = {'NL': 0, 'total': 0}
                doctor.weekday_nm_shifts = {'NM': 0, 'total': 0}
                doctor.weekday_combo_counts = {combo: 0 for combo in WEEKDAY_COMBINATIONS}
                doctor.weekday_post_counts = {post_type: 0 for post_type in ALL_POST_TYPES}

            for cat in self.cats:
                cat.posts = {}
                cat.weekday_posts = {}

            # Effacer les vues
            self.global_view.setRowCount(0)
            self.global_view.setColumnCount(0)
            self.doctor_planning_view.clear_view()

            # Réinitialiser le générateur de planning
            self.planning_generator = PlanningGenerator(self.doctors, self.cats, self.post_configuration)

            # Réinitialiser la barre de progression
            self.progress_bar.setValue(0)

            # Mettre à jour les données dans la fenêtre principale
            self.main_window.reset_all_views()

            QMessageBox.information(self, "Réinitialisation", "Le planning a été réinitialisé avec succès. Vous pouvez maintenant générer un nouveau planning.")

# gui/detached_stats_window.py

# © 2024 HILAL Arkane. Tous droits réservés.
from PyQt6.QtWidgets import QMainWindow
from .stats_view import StatsView

class DetachedStatsWindow(QMainWindow):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.setWindowTitle("Statistiques détachées")
        self.stats_view = StatsView(planning=main_window.planning_tab.planning, 
                                    doctors=main_window.doctors, 
                                    cats=main_window.cats)
        self.setCentralWidget(self.stats_view)
        self.setGeometry(200, 200, 800, 600)

    def closeEvent(self, event):
        self.main_window.reattach_stats()
        event.accept()

    def update_stats(self):
        if hasattr(self.main_window.planning_tab, 'planning'):
            self.stats_view.update_stats(self.main_window.planning_tab.planning,
                                         self.main_window.doctors,
                                         self.main_window.cats)

# gui/post_configuration.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/post_configuration.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                            QTimeEdit, QLineEdit, QCheckBox, QGroupBox,
                            QTableWidget, QTableWidgetItem, QLabel, QSpinBox, QDateEdit, 
                            QHeaderView, QComboBox, QDialog, QFormLayout, QDialogButtonBox, 
                            QMessageBox, QRadioButton, QButtonGroup)
from PyQt6.QtCore import QDate, Qt, QTime
from PyQt6.QtGui import QColor, QBrush, QIcon, QFont
from datetime import time  # Ajout de l'import correct pour time
from core.Constantes.models import DailyPostConfiguration, PostConfig, SpecificPostConfig, ALL_POST_TYPES, PostManager, TimeSlot
from core.Constantes.custom_post import CustomPost
from typing import List, Dict, Optional, TYPE_CHECKING, Union
from .styles import EDIT_DELETE_BUTTON_STYLE
import logging

logger = logging.getLogger(__name__)


class CustomSpinBox(QSpinBox):
    def wheelEvent(self, event):
        event.ignore()

class SpecificConfigDialog(QDialog):
    def __init__(self, parent, start_date, end_date, default_weekday_config, default_saturday_config, default_sunday_config, existing_config=None):
        super().__init__(parent)
        self.start_date = start_date
        self.end_date = end_date
        self.default_weekday_config = default_weekday_config
        self.default_saturday_config = default_saturday_config
        self.default_sunday_config = default_sunday_config
        self.existing_config = existing_config
        self.setWindowTitle("Configuration spécifique")
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.start_date_edit = QDateEdit(self.start_date if not self.existing_config else self.existing_config.start_date)
        self.end_date_edit = QDateEdit(self.end_date if not self.existing_config else self.existing_config.end_date)

        form.addRow("Date de début:", self.start_date_edit)
        form.addRow("Date de fin:", self.end_date_edit)

        self.day_type_group = QButtonGroup(self)
        weekday_radio = QRadioButton("Jours de semaine")
        saturday_radio = QRadioButton("Samedis")
        sunday_radio = QRadioButton("Dimanches/Fériés")
        self.day_type_group.addButton(weekday_radio, 1)
        self.day_type_group.addButton(saturday_radio, 2)
        self.day_type_group.addButton(sunday_radio, 3)

        day_type_layout = QHBoxLayout()
        day_type_layout.addWidget(weekday_radio)
        day_type_layout.addWidget(saturday_radio)
        day_type_layout.addWidget(sunday_radio)
        form.addRow("Type de jours à configurer:", day_type_layout)

        # Ajouter un label explicatif
        explanation = QLabel("Note: Cette configuration ne s'appliquera qu'aux types de jours sélectionnés dans la plage de dates choisie.")
        explanation.setWordWrap(True)
        form.addRow(explanation)

        layout.addLayout(form)

        self.post_table = QTableWidget()
        self.post_table.setColumnCount(2)
        self.post_table.setHorizontalHeaderLabels(["Type de poste", "Nombre"])
        self.post_table.verticalHeader().setVisible(False)

        layout.addWidget(self.post_table)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self.day_type_group.buttonClicked.connect(self.update_table)
        weekday_radio.setChecked(True)
        self.update_table()

    def update_table(self):
        self.post_table.setRowCount(0)
        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            default_config = self.default_weekday_config
        elif day_type_id == 2:
            default_config = self.default_saturday_config
        else:
            default_config = self.default_sunday_config

        for post_type in ALL_POST_TYPES:
            row = self.post_table.rowCount()
            self.post_table.insertRow(row)
            self.post_table.setItem(row, 0, QTableWidgetItem(post_type))
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            if self.existing_config and post_type in self.existing_config.post_counts:
                spinbox.setValue(self.existing_config.post_counts[post_type])
            else:
                spinbox.setValue(default_config.get(post_type, PostConfig()).total)
            self.post_table.setCellWidget(row, 1, spinbox)
        self.post_table.resizeColumnsToContents()

    def get_config(self):
        post_counts = {}
        for row in range(self.post_table.rowCount()):
            post_type = self.post_table.item(row, 0).text()
            count = self.post_table.cellWidget(row, 1).value()
            if count > 0:
                post_counts[post_type] = count

        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            apply_to = "Semaine"
        elif day_type_id == 2:
            apply_to = "Samedi"
        else:
            apply_to = "Dimanche/Ferié"

        return SpecificPostConfig(
            start_date=self.start_date_edit.date().toPyDate(),
            end_date=self.end_date_edit.date().toPyDate(),
            apply_to=apply_to,
            post_counts=post_counts
        )
    
    def validate_config(self) -> bool:
        if self.start_date_edit.date() > self.end_date_edit.date():
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return False

        selected_config = None
        day_type_id = self.day_type_group.checkedId()
        if day_type_id == 1:
            selected_config = self.default_weekday_config
        elif day_type_id == 2:
            selected_config = self.default_saturday_config
        else:
            selected_config = self.default_sunday_config

        # Vérifier les valeurs par rapport à la configuration par défaut
        for row in range(self.post_table.rowCount()):
            post_type = self.post_table.item(row, 0).text()
            count = self.post_table.cellWidget(row, 1).value()
            default_count = selected_config.get(post_type, PostConfig()).total

            if count < 0:
                QMessageBox.warning(self, "Erreur", f"Le nombre de postes ne peut pas être négatif pour {post_type}")
                return False

        return True

    def accept(self):
        if self.validate_config():
            super().accept()

        
class SpecificConfigWidget(QWidget):
    def __init__(self, post_configuration, planning_start_date, planning_end_date, main_window):  # Ajout de main_window
        super().__init__()
        self.post_configuration = post_configuration
        self.planning_start_date = planning_start_date
        self.planning_end_date = planning_end_date
        self.main_window = main_window  # Stockage de la référence
        self.init_ui()


    def init_ui(self):
        layout = QVBoxLayout(self)
        
        self.table = QTableWidget()
        self.table.setColumnCount(6)
        self.table.setHorizontalHeaderLabels(["Date début", "Date fin", "Type de jour", "Types de postes", "Nombre", "Actions"])
        layout.addWidget(self.table)

        button_layout = QHBoxLayout()
        add_button = QPushButton("Ajouter une configuration")
        add_button.clicked.connect(self.add_specific_config)
        save_button = QPushButton("Enregistrer config spécifique")
        save_button.clicked.connect(self.save_specific_config)
        button_layout.addWidget(add_button)
        button_layout.addWidget(save_button)
        layout.addLayout(button_layout)

        self.update_table()

    def add_specific_config(self):
        dialog = SpecificConfigDialog(
            self, 
            self.planning_start_date, 
            self.planning_end_date, 
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            config = dialog.get_config()
            self.post_configuration.add_specific_config(config)
            self.update_table()
            print(f"Configuration ajoutée et table mise à jour")  # Pour le débogage

    def edit_specific_config(self, row):
        config = self.post_configuration.specific_configs[row]
        dialog = SpecificConfigDialog(
            self, 
            self.planning_start_date, 
            self.planning_end_date, 
            self.post_configuration.weekday,
            self.post_configuration.saturday,
            self.post_configuration.sunday_holiday,
            existing_config=config
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_config = dialog.get_config()
            self.post_configuration.specific_configs[row] = new_config
            self.update_table()

    def delete_specific_config(self, row):
        config_to_delete = self.post_configuration.specific_configs[row]
        self.post_configuration.remove_specific_config(config_to_delete)
        self.update_table()

    def update_table(self):
        self.table.setRowCount(len(self.post_configuration.specific_configs))
        for row, config in enumerate(self.post_configuration.specific_configs):
            self.table.setItem(row, 0, QTableWidgetItem(config.start_date.strftime("%d-%m-%y")))
            self.table.setItem(row, 1, QTableWidgetItem(config.end_date.strftime("%d-%m-%y")))
            self.table.setItem(row, 2, QTableWidgetItem(config.apply_to))

            # Fusionner les types de poste et leur nombre
            post_counts = ", ".join([f"{count}{post_type}" for post_type, count in config.post_counts.items()])
            post_counts_item = QTableWidgetItem(post_counts)
            post_counts_item.setTextAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
            self.table.setItem(row, 3, post_counts_item)
            
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            
            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier la configuration")
            edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer la configuration")
            delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
            
            actions_layout.addWidget(edit_button)
            actions_layout.addWidget(delete_button)
            actions_layout.setContentsMargins(2, 2, 2, 2)
            actions_layout.setSpacing(4)
            
            edit_button.clicked.connect(lambda _, r=row: self.edit_specific_config(r))
            delete_button.clicked.connect(lambda _, r=row: self.delete_specific_config(r))
            
            self.table.setCellWidget(row, 4, actions_widget)
        self.table.resizeColumnsToContents()
        self.table.resizeRowsToContents()

    def save_specific_config(self):
        try:
            specific_configs = []
            for row in range(self.table.rowCount()):
                # Création de la configuration comme avant
                specific_config = SpecificPostConfig(...)
                specific_configs.append(specific_config)
            
            self.post_configuration.specific_configs = specific_configs
            # Forcer la mise à jour complète
            if hasattr(self.parent(), 'main_window'):
                self.parent().main_window.update_post_configuration(self.post_configuration)
                self.parent().main_window.save_data()  # S'assurer que tout est sauvegardé
                QMessageBox.information(self, "Succès", "Configuration spécifique sauvegardée avec succès")
            else:
                QMessageBox.warning(self, "Erreur", "Impossible de sauvegarder la configuration")
                
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors de la sauvegarde : {str(e)}")
        
class PostConfigurationWidget(QWidget):
    
    # Ajoutez sync_scroll comme méthode statique pour la lisibilité
    @staticmethod
    def sync_scroll(tables):
        if not tables:
            return

        main_scrollbar = tables[0].verticalScrollBar()

        def update_scroll():
            for table in tables[1:]:
                table.verticalScrollBar().setValue(main_scrollbar.value())

        main_scrollbar.valueChanged.connect(update_scroll)

        for table in tables[1:]:
            table.verticalScrollBar().valueChanged.connect(lambda val: main_scrollbar.setValue(val))

    def __init__(self, post_configuration, main_window):
        super().__init__()
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.config_tables = {}
        self.custom_posts = {}
        self.load_custom_posts()
        self.clean_invalid_custom_posts()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        tab_widget = QTabWidget()

        
        # Onglet pour les médecins
        doctors_tab = QWidget()
        doctors_layout = QVBoxLayout(doctors_tab)
        doctors_config = self.create_config_tab(
            [("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday)],
            "Médecins"
        )
        doctors_layout.addWidget(doctors_config)
        
        # Boutons en ligne pour les médecins
        doctors_button_layout = QHBoxLayout()
        add_custom_post_button = QPushButton("Ajouter un poste")
        add_custom_post_button.clicked.connect(self.add_custom_post)
        save_doctors_button = QPushButton("Enregistrer la configuration des médecins")
        save_doctors_button.clicked.connect(lambda: self.save_configuration("Médecin"))
        
        doctors_button_layout.addWidget(add_custom_post_button)
        doctors_button_layout.addWidget(save_doctors_button)
        doctors_layout.addLayout(doctors_button_layout)
        
        tab_widget.addTab(doctors_tab, "Postes Médecins")

        # Onglet pour les CAT
        cats_tab = QWidget()
        cats_layout = QVBoxLayout(cats_tab)
        cats_config = self.create_config_tab(
            [("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)],
            "CAT"
        )
        cats_layout.addWidget(cats_config)
        
        # Bouton de sauvegarde pour les CAT
        cats_button_layout = QHBoxLayout()
        save_cats_button = QPushButton("Enregistrer la configuration des CAT")
        save_cats_button.clicked.connect(lambda: self.save_configuration("CAT"))
        cats_button_layout.addWidget(save_cats_button)
        cats_layout.addLayout(cats_button_layout)
        
        tab_widget.addTab(cats_tab, "Postes CAT")
        
        # Après avoir ajouté les tableaux au dictionnaire config_tables
        self.sync_scroll([
            self.config_tables["Semaine"],
            self.config_tables["Samedi"],
            self.config_tables["Dimanche/Férié"],
            self.config_tables["CAT_Semaine"],
            self.config_tables["CAT_Samedi"],
            self.config_tables["CAT_Dimanche/férié"]
        ])
        
        # Modification de l'initialisation de SpecificConfigWidget
        self.specific_config_tab = SpecificConfigWidget(
            self.post_configuration,
            self.start_date if hasattr(self, 'start_date') else None,
            self.end_date if hasattr(self, 'end_date') else None,
            self.main_window  # Passage de la référence main_window
        )
        tab_widget.addTab(self.specific_config_tab, "Jours spécifiques")
        
        layout.addWidget(tab_widget)

        # Dans init_ui, après la création du bouton
        add_custom_post_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)

    def update_dates(self, start_date, end_date):
        self.specific_config_tab.planning_start_date = start_date
        self.specific_config_tab.planning_end_date = end_date
        self.specific_config_tab.update_table()


    def create_config_tab(self, configs, title):
        """Crée un nouvel onglet de configuration"""
        tab = QWidget()
        tab_layout = QHBoxLayout(tab)
        
        for day_type, config in configs:
            column_layout = QVBoxLayout()
            column_layout.addWidget(QLabel(day_type))
            table = self.create_config_table(config, day_type)
            column_layout.addWidget(table)
            tab_layout.addLayout(column_layout)
        
        return tab
    
    def create_config_table(self, config, day_type):
        """Crée une nouvelle table de configuration"""
        table = QTableWidget(self)
        table.setObjectName(day_type)
        table.setColumnCount(3)  # Retour à 3 colonnes
        table.setHorizontalHeaderLabels(["Type de poste", "Nombre total", "Actions"])

        all_posts = self.get_posts_for_day_type(day_type)
        table.setRowCount(len(all_posts))
        
        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            if post_type in self.custom_posts:
                name_item.setBackground(QBrush(self.custom_posts[post_type].color))
                
            # Pour NL dans la config CAT en semaine, modifier le texte
            if post_type == "NL" and "CAT" in day_type and "Semaine" in day_type:
                name_item.setText("NL/NLv")
                
            table.setItem(row, 0, name_item)
            
            # Création du widget pour la colonne "Nombre total"
            if post_type == "NL" and "CAT" in day_type and "Semaine" in day_type:
                # Créer un widget conteneur pour les deux spinbox
                container = QWidget()
                layout = QHBoxLayout(container)
                layout.setContentsMargins(2, 2, 2, 2)
                layout.setSpacing(2)
                
                # Spinbox pour NL
                nl_spinbox = CustomSpinBox()
                nl_spinbox.setRange(0, 20)
                nl_spinbox.setValue(config.get(post_type, PostConfig()).total)
                nl_spinbox.setFixedWidth(50)  # Réduire la largeur
                
                # Spinbox pour NLv
                nlv_spinbox = CustomSpinBox()
                nlv_spinbox.setRange(0, 20)
                nlv_spinbox.setValue(config.get("NLv", PostConfig()).total)
                nlv_spinbox.setFixedWidth(50)  # Réduire la largeur
                
                layout.addWidget(nl_spinbox)
                layout.addWidget(nlv_spinbox)
                
                table.setCellWidget(row, 1, container)
            else:
                # SpinBox normal pour les autres postes
                spinbox = CustomSpinBox()
                spinbox.setRange(0, 20)
                spinbox.setValue(config.get(post_type, PostConfig()).total)
                table.setCellWidget(row, 1, spinbox)

            # Pour les postes personnalisés uniquement
            if post_type in self.custom_posts:
                actions_widget = QWidget()
                actions_layout = QHBoxLayout(actions_widget)
                actions_layout.setContentsMargins(2, 2, 2, 2)
                
                edit_button = QPushButton()
                edit_button.setIcon(QIcon("icons/edition.png"))
                edit_button.setToolTip("Modifier le poste personnalisé")
                edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                delete_button = QPushButton()
                delete_button.setIcon(QIcon("icons/supprimer.png"))
                delete_button.setToolTip("Supprimer le poste personnalisé")
                delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                
                edit_button.clicked.connect(lambda _, p=post_type: self.edit_custom_post(p))
                delete_button.clicked.connect(lambda _, p=post_type: self.remove_custom_post(p))
                
                actions_layout.addWidget(edit_button)
                actions_layout.addWidget(delete_button)
                table.setCellWidget(row, 2, actions_widget)
            else:
                empty_widget = QWidget()
                table.setCellWidget(row, 2, empty_widget)

        # Ajuster l'affichage de la table
        table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        table.setColumnWidth(2, 140)
        
        self.config_tables[day_type] = table
        return table
    
    def get_posts_for_day_type(self, day_type: str) -> list:
        """Obtient tous les postes (standards + personnalisés) pour un type de jour"""
        logger.debug(f"Récupération des postes pour {day_type}")
        
        day_type_mapping = {
            "Semaine": "weekday",
            "Samedi": "saturday",
            "Dimanche/Férié": "sunday_holiday",
            "CAT_Semaine": "weekday",
            "CAT_Samedi": "saturday",
            "CAT_Dimanche/férié": "sunday_holiday"
        }

        all_posts = list(ALL_POST_TYPES)
        real_day_type = day_type_mapping.get(day_type)
        is_cat = day_type.startswith("CAT_")

        # Debug logs
        logger.debug(f"Posts standard : {all_posts}")
        logger.debug(f"Posts personnalisés disponibles : {list(self.custom_posts.keys())}")

        if real_day_type:
            for name, post in self.custom_posts.items():
                logger.debug(f"Vérification du poste {name}:")
                logger.debug(f"- Types de jour: {post.day_types}")
                logger.debug(f"- Type d'assignation: {post.assignment_type}")
                
                if real_day_type in post.day_types:
                    is_eligible = False
                    if is_cat and post.assignment_type in ['cats', 'both']:
                        logger.debug(f"- Éligible pour CAT")
                        is_eligible = True
                    elif not is_cat and post.assignment_type in ['doctors', 'both']:
                        logger.debug(f"- Éligible pour médecins")
                        is_eligible = True
                    
                    if is_eligible and name not in all_posts:
                        all_posts.append(name)
                        logger.debug(f"- Poste {name} ajouté à la liste")

        logger.debug(f"Liste finale pour {day_type}: {all_posts}")
        return all_posts
    def add_custom_post(self):
        """Ajoute un nouveau poste personnalisé"""
        dialog = NewPostDialog(self, existing_posts=self.custom_posts,
                            statistic_groups=self.define_statistic_groups())
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_post = dialog.get_post()
            if new_post:
                logger.info(f"Nouveau poste créé : {new_post.name}")
                logger.debug(f"- Types de jour: {new_post.day_types}")
                logger.debug(f"- Type d'assignation: {new_post.assignment_type}")
                
                # Ajouter aux custom posts
                self.custom_posts[new_post.name] = new_post
                logger.debug(f"Poste ajouté au dictionnaire custom_posts")
                
                # Ajouter aux configurations appropriées
                for day_type in new_post.day_types:
                    if new_post.assignment_type in ["Médecin", "Les deux"]:
                        config = getattr(self.post_configuration, day_type)
                        config[new_post.name] = PostConfig(total=1)
                        logger.debug(f"Ajouté à la configuration {day_type} des médecins")
                    
                    if new_post.assignment_type in ["CAT", "Les deux"]:
                        cat_config = getattr(self.post_configuration, f"cat_{day_type}")
                        cat_config[new_post.name] = PostConfig(total=1)
                        logger.debug(f"Ajouté à la configuration {day_type} des CAT")
                
                # Sauvegarder et mettre à jour
                self.save_custom_posts()
                logger.debug("Custom posts sauvegardés")
                
                # Mise à jour des tables
                for day_type, table in self.config_tables.items():
                    logger.debug(f"Mise à jour de la table {day_type}")
                    self.refresh_table(table, day_type)
                
                logger.info(f"Poste {new_post.name} ajouté avec succès")
                QMessageBox.information(self, "Succès", f"Le poste {new_post.name} a été ajouté avec succès")
                
    def get_action_button_style(self):
        return """
            QPushButton {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 3px 8px;
                font-size: 11px;
                border-radius: 2px;
                margin: 1px;
                max-width: 60px;
            }
            QPushButton:hover {
                background-color: #e8e8e8;
            }
        """
        
    def _update_config_tables(self):
        """Met à jour les tables de configuration avec tous les postes"""
        configs = [
            ("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday),
            ("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
        ]

        for day_type, config in configs:
            table = self.config_tables.get(day_type)
            if table:
                # Sauvegarder la position du scroll actuelle
                current_scroll = table.verticalScrollBar().value()
                
                # Récupérer tous les postes pour ce type de jour
                all_posts = self.get_posts_for_day_type(day_type)
                
                # Mettre à jour la table
                table.setRowCount(0)  # Effacer d'abord la table
                table.setRowCount(len(all_posts))
                table.setColumnCount(3)
                table.setHorizontalHeaderLabels(["Type de poste", "Nombre total", "Actions"])
                
                for row, post_type in enumerate(all_posts):
                    # Création et ajout du nom du poste
                    name_item = QTableWidgetItem(post_type)
                    if post_type in self.custom_posts:
                        name_item.setBackground(QBrush(self.custom_posts[post_type].color))
                    table.setItem(row, 0, name_item)
                    
                    # SpinBox pour le nombre
                    spinbox = CustomSpinBox()
                    spinbox.setRange(0, 20)
                    spinbox.setValue(config.get(post_type, PostConfig()).total)
                    table.setCellWidget(row, 1, spinbox)
                    
                    # Ajouter les boutons d'action pour les postes personnalisés
                    if post_type in self.custom_posts:
                        actions_widget = QWidget()
                        actions_layout = QHBoxLayout(actions_widget)
                        actions_layout.setContentsMargins(2, 2, 2, 2)
                        actions_layout.setSpacing(4)
                        
                        edit_button = QPushButton()
                        edit_button.setIcon(QIcon("icons/edition.png"))
                        edit_button.setToolTip("Modifier le poste personnalisé")
                        edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                        delete_button = QPushButton()
                        delete_button.setIcon(QIcon("icons/supprimer.png"))
                        delete_button.setToolTip("Supprimer le poste personnalisé")
                        delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                        
                        edit_button.clicked.connect(lambda _, p=post_type: self.edit_custom_post(p))
                        delete_button.clicked.connect(lambda _, p=post_type: self.remove_custom_post(p))
                        
                        actions_layout.addWidget(edit_button)
                        actions_layout.addWidget(delete_button)
                        
                        actions_widget.setLayout(actions_layout)
                        table.setCellWidget(row, 2, actions_widget)
                    else:
                        # Pour les postes standards, on met une cellule vide
                        empty_widget = QWidget()
                        table.setCellWidget(row, 2, empty_widget)
                
                # Restaurer la position du scroll
                table.verticalScrollBar().setValue(current_scroll)
                
                # Ajuster la taille des colonnes
                table.resizeColumnsToContents()
                
                # Optimiser la largeur des colonnes
                header = table.horizontalHeader()
                header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
                header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
                header.setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
                
                # Définir une largeur minimale pour la colonne des actions
                table.setColumnWidth(2, 140)
            else:
                print(f"Table non trouvée pour {day_type}")
    
    
    def add_post_to_configurations(self, post):
        """Ajoute un nouveau poste à toutes les configurations appropriées"""
        # Pour les médecins
        if post.assignment_type in ['doctors', 'both']:
            for day_type in post.day_types:
                config = getattr(self.post_configuration, day_type)
                config[post.name] = PostConfig(total=1)
        
        # Pour les CAT
        if post.assignment_type in ['cats', 'both']:
            for day_type in post.day_types:
                config = getattr(self.post_configuration, f'cat_{day_type}')
                config[post.name] = PostConfig(total=1)
                
    def remove_custom_post(self, post_name: str):
        """Supprime un poste personnalisé"""
        if post_name in self.custom_posts:
            confirm = QMessageBox.question(
                self,
                "Confirmation",
                f"Êtes-vous sûr de vouloir supprimer le poste {post_name} ?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm == QMessageBox.StandardButton.Yes:
                # Supprimer le poste de la configuration
                post = self.custom_posts[post_name]
                for day_type in post.day_types:
                    if post.assignment_type in ["Médecin", "Les deux"]:
                        if day_type == "weekday":
                            self.post_configuration.weekday.pop(post_name, None)
                        elif day_type == "saturday":
                            self.post_configuration.saturday.pop(post_name, None)
                        elif day_type == "sunday_holiday":
                            self.post_configuration.sunday_holiday.pop(post_name, None)
                    
                    if post.assignment_type in ["CAT", "Les deux"]:
                        if day_type == "weekday":
                            self.post_configuration.cat_weekday.pop(post_name, None)
                        elif day_type == "saturday":
                            self.post_configuration.cat_saturday.pop(post_name, None)
                        elif day_type == "sunday_holiday":
                            self.post_configuration.cat_sunday_holiday.pop(post_name, None)
                
                del self.custom_posts[post_name]
                self.save_custom_posts()
                self.update_all_tables()
                QMessageBox.information(self, "Succès", f"Le poste {post_name} a été supprimé")

    def save_custom_posts(self):
        """Sauvegarde les postes personnalisés"""
        print("Sauvegarde des postes personnalisés :")  # Debug
        for name, post in self.custom_posts.items():
            print(f"- {name}: {post.day_types}, {post.assignment_type}")  # Debug
        custom_posts_data = {name: post.to_dict() for name, post in self.custom_posts.items()}
        self.main_window.data_persistence.save_custom_posts(custom_posts_data)

    def load_custom_posts(self):
        """Charge les postes personnalisés depuis la persistance"""
        try:
            custom_posts_data = self.main_window.data_persistence.load_custom_posts()
            if custom_posts_data:
                self.custom_posts = {}
                for name, data in custom_posts_data.items():
                    try:
                        if isinstance(data, dict):
                            self.custom_posts[name] = CustomPost.from_dict(data)
                        else:
                            self.custom_posts[name] = data
                        logger.info(f"Poste personnalisé chargé: {name}")
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement du poste {name}: {e}")
            self.update_all_tables()
        except Exception as e:
            logger.error(f"Erreur lors du chargement des postes personnalisés: {e}")

    def refresh_custom_posts(self):
        """Rafraîchit la liste des postes personnalisés"""
        new_custom_posts = self.main_window.data_persistence.load_custom_posts()
        if new_custom_posts:
            has_changes = False
            # Vérifier les modifications
            for name, data in new_custom_posts.items():
                if name not in self.custom_posts:
                    try:
                        if isinstance(data, dict):
                            self.custom_posts[name] = CustomPost.from_dict(data)
                        else:
                            self.custom_posts[name] = data
                        has_changes = True
                        logger.info(f"Nouveau poste personnalisé détecté: {name}")
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement du poste {name}: {e}")
            
            # Vérifier les suppressions
            for name in list(self.custom_posts.keys()):
                if name not in new_custom_posts:
                    del self.custom_posts[name]
                    has_changes = True
                    logger.info(f"Poste personnalisé supprimé: {name}")
            
            if has_changes:
                self.update_all_tables()
        
    def update_table(self, table: QTableWidget, day_type: str):
        """Met à jour une table spécifique avec les postes standards et personnalisés"""
        current_scroll_position = table.verticalScrollBar().value()
        
        # Récupérer la configuration appropriée
        if "CAT" in day_type:
            config = getattr(self.post_configuration, f"cat_{day_type.lower().replace('cat_', '')}", {})
            assignation_filter = ["CAT", "Les deux"]
        else:
            config = getattr(self.post_configuration, day_type.lower(), {})
            assignation_filter = ["Médecin", "Les deux"]

        # Récupérer tous les postes (standards + personnalisés)
        all_posts = list(ALL_POST_TYPES)
        custom_posts_for_type = [
            post for post in self.custom_posts.values()
            if (day_type.lower().replace("cat_", "") in post.day_types and 
                post.assignment_type in assignation_filter)
        ]
        all_posts.extend([post.name for post in custom_posts_for_type])
        
        # Mettre à jour la table
        table.setRowCount(len(all_posts))
        
        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            table.setItem(row, 0, name_item)
            
            # Colorer les postes personnalisés
            if post_type in [p.name for p in custom_posts_for_type]:
                custom_post = next(p for p in custom_posts_for_type if p.name == post_type)
                name_item.setBackground(QBrush(custom_post.color))
            
            # SpinBox pour le nombre
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            spinbox.setValue(config.get(post_type, PostConfig()).total)
            table.setCellWidget(row, 1, spinbox)

        # Restaurer la position du scroll
        table.verticalScrollBar().setValue(current_scroll_position)
        table.resizeColumnsToContents()
        
    def update_all_tables(self):
        """Met à jour toutes les tables de configuration"""
        # Mettre à jour les tables des médecins
        for day_type in ["Semaine", "Samedi", "Dimanche/Férié"]:
            table = self.config_tables.get(day_type)
            if table:
                self.refresh_table(table, day_type)

        # Mettre à jour les tables des CAT
        for day_type in ["CAT_Semaine", "CAT_Samedi", "CAT_Dimanche/férié"]:
            table = self.config_tables.get(day_type)
            if table:
                self.refresh_table(table, day_type)


    def refresh_table(self, table: QTableWidget, day_type: str):
        """Rafraîchit une table spécifique"""
        current_scroll = table.verticalScrollBar().value()
        
        # Obtenir tous les postes pour ce type de jour
        all_posts = self.get_posts_for_day_type(day_type)
        
        # Mise à jour de la table
        table.setRowCount(len(all_posts))
        
        # Obtenir la configuration appropriée
        config_mapping = {
            "Semaine": self.post_configuration.weekday,
            "Samedi": self.post_configuration.saturday,
            "Dimanche/Férié": self.post_configuration.sunday_holiday,
            "CAT_Semaine": self.post_configuration.cat_weekday,
            "CAT_Samedi": self.post_configuration.cat_saturday,
            "CAT_Dimanche/férié": self.post_configuration.cat_sunday_holiday
        }
        config = config_mapping.get(day_type, {})

        for row, post_type in enumerate(all_posts):
            # Nom du poste
            name_item = QTableWidgetItem(post_type)
            if post_type in self.custom_posts:
                custom_post = self.custom_posts[post_type]
                name_item.setBackground(QBrush(custom_post.color))
                # Ajouter les boutons d'action
                actions_widget = QWidget()
                actions_layout = QHBoxLayout(actions_widget)
                actions_layout.setContentsMargins(2, 2, 2, 2)
                
                edit_button = QPushButton()
                edit_button.setIcon(QIcon("icons/edition.png"))
                edit_button.setToolTip("Modifier le poste personnalisé")
                edit_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)

                delete_button = QPushButton()
                delete_button.setIcon(QIcon("icons/supprimer.png"))
                delete_button.setToolTip("Supprimer le poste personnalisé")
                delete_button.setStyleSheet(EDIT_DELETE_BUTTON_STYLE)
                
                edit_button.clicked.connect(lambda _, n=post_type: self.edit_custom_post(n))
                delete_button.clicked.connect(lambda _, n=post_type: self.remove_custom_post(n))
                
                actions_layout.addWidget(edit_button)
                actions_layout.addWidget(delete_button)
                
                table.setCellWidget(row, 2, actions_widget)
            
            table.setItem(row, 0, name_item)
            
            # Spinbox pour le nombre
            spinbox = CustomSpinBox()
            spinbox.setRange(0, 20)
            spinbox.setValue(config.get(post_type, PostConfig()).total)
            table.setCellWidget(row, 1, spinbox)

        # Restaurer le scroll
        table.verticalScrollBar().setValue(current_scroll)
        table.resizeColumnsToContents()
    
    def save_configuration(self, config_type):
        if config_type == "Médecin":
            configs = [
                ("Semaine", self.post_configuration.weekday),
                ("Samedi", self.post_configuration.saturday),
                ("Dimanche/Férié", self.post_configuration.sunday_holiday)
            ]
        elif config_type == "CAT":
            configs = [
                ("CAT_Semaine", self.post_configuration.cat_weekday),
                ("CAT_Samedi", self.post_configuration.cat_saturday),
                ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
            ]
        else:
            return

        for day_type, config in configs:
            table = self.config_tables.get(day_type)
            if table:
                for row in range(table.rowCount()):
                    post_type = table.item(row, 0).text()
                    cell_widget = table.cellWidget(row, 1)
                    
                    # Cas spécial pour NL/NLv
                    if isinstance(cell_widget, QWidget) and cell_widget.layout() and cell_widget.layout().count() == 2:
                        nl_spinbox = cell_widget.layout().itemAt(0).widget()
                        nlv_spinbox = cell_widget.layout().itemAt(1).widget()
                        config["NL"] = PostConfig(total=nl_spinbox.value())
                        config["NLv"] = PostConfig(total=nlv_spinbox.value())
                    else:
                        if post_type == "NL/NLv":
                            post_type = "NL"
                        total_count = cell_widget.value()
                        config[post_type] = PostConfig(total=total_count)

        # Mise à jour et sauvegarde
        self.main_window.update_post_configuration(self.post_configuration)
        QMessageBox.information(self, "Sauvegarde", f"Configuration des {config_type} sauvegardée")
        
        # On peut ajouter un message suggérant de générer le planning manuellement
        QMessageBox.information(self, "Rappel", "N'oubliez pas de générer de nouveau le planning pour appliquer ces changements.")


    def update_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        for day_type, config in [
            ("Semaine", self.post_configuration.weekday),
            ("Samedi", self.post_configuration.saturday),
            ("Dimanche/Férié", self.post_configuration.sunday_holiday),
            ("CAT_Semaine", self.post_configuration.cat_weekday),
            ("CAT_Samedi", self.post_configuration.cat_saturday),
            ("CAT_Dimanche/férié", self.post_configuration.cat_sunday_holiday)
        ]:
            table = self.config_tables.get(day_type)
            if table:
                for row in range(table.rowCount()):
                    post_type = table.item(row, 0).text()
                    cell_widget = table.cellWidget(row, 1)
                    
                    # Vérifier si c'est le widget spécial NL/NLv
                    if isinstance(cell_widget, QWidget) and cell_widget.layout() and cell_widget.layout().count() == 2:
                        nl_spinbox = cell_widget.layout().itemAt(0).widget()
                        nlv_spinbox = cell_widget.layout().itemAt(1).widget()
                        nl_spinbox.setValue(config.get("NL", PostConfig()).total)
                        nlv_spinbox.setValue(config.get("NLv", PostConfig()).total)
                    else:
                        if post_type == "NL/NLv":
                            post_type = "NL"
                        if isinstance(cell_widget, QSpinBox):
                            cell_widget.setValue(config.get(post_type, PostConfig()).total)
    
    def update_custom_posts_list(self):
        """Met à jour la liste des postes personnalisés"""
        self.custom_posts_list.setRowCount(len(self.custom_posts))
        
        for row, (name, post) in enumerate(self.custom_posts.items()):
            # Nom
            self.custom_posts_list.setItem(row, 0, QTableWidgetItem(name))
            
            # Horaires
            horaires = f"{post.start_time.strftime('%H:%M')} - {post.end_time.strftime('%H:%M')}"
            self.custom_posts_list.setItem(row, 1, QTableWidgetItem(horaires))
            
            # Types de jour
            types_jour = ", ".join(post.day_types)
            self.custom_posts_list.setItem(row, 2, QTableWidgetItem(types_jour))
            
            # Assignation
            self.custom_posts_list.setItem(row, 3, QTableWidgetItem(post.assignment_type))
            
            # Actions
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            edit_button = QPushButton()
            edit_button.setIcon(QIcon("icons/edition.png"))
            edit_button.setToolTip("Modifier le poste personnalisé")

            delete_button = QPushButton()
            delete_button.setIcon(QIcon("icons/supprimer.png"))
            delete_button.setToolTip("Supprimer le poste personnalisé")
            
            edit_button.clicked.connect(lambda _, n=name: self.edit_custom_post(n))
            delete_button.clicked.connect(lambda _, n=name: self.remove_custom_post(n))
            
            actions_layout.addWidget(edit_button)
            actions_layout.addWidget(delete_button)
            self.custom_posts_list.setCellWidget(row, 4, actions_widget)
        
        self.custom_posts_list.resizeColumnsToContents()

    def define_statistic_groups(self):
        """
        Définit tous les groupes de postes possibles pour le menu déroulant.
        Cette méthode est utilisée par PostConfigurationWidget et NewPostDialog.
        """
        # Groupes Weekend
        weekend_groups = [
            ("Consultations Samedi", [
                "CmS",  # Consultation matin samedi
            ]),
            ("Consultations Dimanche/Férié", [
                "CmD",  # Consultation matin dimanche/férié
            ]),
            ("Consultations Weekend/Férié", [
                "CaSD",  # Consultation après-midi samedi + dimanche/férié
                "CsSD",  # Consultation soir samedi + dimanche/férié
            ]),
            ("Visites Samedi", [
                "VmS",  # Visites matin samedi
            ]),
            ("Visites Dimanche/Férié", [
                "VmD",  # Visites matin dimanche/férié
            ]),
            ("Visites Weekend/Férié", [
                "VaSD",  # Visites après-midi samedi + dimanche/férié
            ]),
            ("Gardes Weekend/Férié", [
                "NAMw",  # NA + NM weekends/férié
                "NLw",   # NL Weekend/férié + vendredi
            ])
        ]

        # Groupes Semaine
        weekday_groups = [
            ("Consultations Semaine", [
                "XmM",  # Consultation matin à partir de 7h
                "XM",   # Consultation matin à partir de 9h
                "XA",   # Consultation après-midi
                "XS",   # Consultation soir
            ]),
            ("Visites Semaine", [
                "Vm",   # Visites matin
                "VA"    # Visites après-midi
            ]),
            ("Gardes Semaine", [
                "NMC"   # NM + NC + NA de la semaine
            ])
        ]

        return {
            "Aucun": None,
            "Weekend": weekend_groups,
            "Semaine": weekday_groups
        }

    def edit_custom_post(self, post_name: str):
        """Modifie un poste personnalisé existant"""
        if post_name in self.custom_posts:
            dialog = NewPostDialog(
                self,
                existing_posts=self.custom_posts,
                statistic_groups=self.define_statistic_groups(),  # Utilisez define_statistic_groups ici
                post_to_edit=self.custom_posts[post_name]
            )
            
            if dialog.exec() == QDialog.DialogCode.Accepted:
                edited_post = dialog.get_post()
                if edited_post:
                    # Supprimer l'ancienne configuration
                    old_post = self.custom_posts[post_name]
                    self.remove_post_from_config(old_post)
                    
                    # Ajouter la nouvelle configuration
                    self.custom_posts[edited_post.name] = edited_post
                    self.add_post_to_config(edited_post)
                    
                    self.save_custom_posts()
                    self.update_all_tables()
                    QMessageBox.information(self, "Succès", f"Le poste {edited_post.name} a été modifié avec succès")

    def remove_post_from_config(self, post):
        """Supprime un poste de la configuration"""
        for day_type in post.day_types:
            if post.assignment_type in ["Médecin", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.weekday.pop(post.name, None)
                elif day_type == "saturday":
                    self.post_configuration.saturday.pop(post.name, None)
                elif day_type == "sunday_holiday":
                    self.post_configuration.sunday_holiday.pop(post.name, None)

            if post.assignment_type in ["CAT", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.cat_weekday.pop(post.name, None)
                elif day_type == "saturday":
                    self.post_configuration.cat_saturday.pop(post.name, None)
                elif day_type == "sunday_holiday":
                    self.post_configuration.cat_sunday_holiday.pop(post.name, None)

    def add_post_to_config(self, post):
        """Ajoute un poste à la configuration"""
        for day_type in post.day_types:
            if post.assignment_type in ["Médecin", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.weekday[post.name] = PostConfig(total=1)
                elif day_type == "saturday":
                    self.post_configuration.saturday[post.name] = PostConfig(total=1)
                elif day_type == "sunday_holiday":
                    self.post_configuration.sunday_holiday[post.name] = PostConfig(total=1)

            if post.assignment_type in ["CAT", "Les deux"]:
                if day_type == "weekday":
                    self.post_configuration.cat_weekday[post.name] = PostConfig(total=1)
                elif day_type == "saturday":
                    self.post_configuration.cat_saturday[post.name] = PostConfig(total=1)
                elif day_type == "sunday_holiday":
                    self.post_configuration.cat_sunday_holiday[post.name] = PostConfig(total=1)
              
              
    def clean_invalid_custom_posts(self):
        """Nettoie les postes personnalisés invalides"""
        invalid_posts = []
        
        # Identifier les postes invalides
        for name, post in self.custom_posts.items():
            if post.assignment_type not in ['doctors', 'cats', 'both']:
                logger.debug(f"Poste invalide trouvé: {name} avec assignment_type: {post.assignment_type}")
                invalid_posts.append(name)
                
            # Vérifier aussi la validité des types de jour
            for day_type in post.day_types:
                if day_type not in ['weekday', 'saturday', 'sunday_holiday']:
                    logger.debug(f"Poste avec type de jour invalide: {name} avec day_type: {day_type}")
                    if name not in invalid_posts:
                        invalid_posts.append(name)

        # Supprimer les postes invalides
        for name in invalid_posts:
            logger.info(f"Suppression du poste invalide: {name}")
            del self.custom_posts[name]
            
            # Supprimer des configurations
            for config in [self.post_configuration.weekday, 
                        self.post_configuration.saturday, 
                        self.post_configuration.sunday_holiday,
                        self.post_configuration.cat_weekday,
                        self.post_configuration.cat_saturday,
                        self.post_configuration.cat_sunday_holiday]:
                if name in config:
                    del config[name]

        # Sauvegarder les modifications
        if invalid_posts:
            self.save_custom_posts()
            self.update_all_tables()
            logger.info(f"Nettoyage terminé. Postes supprimés: {invalid_posts}")
            
          
class NewPostDialog(QDialog):
    def __init__(self, parent=None, existing_posts=None, statistic_groups=None, post_to_edit=None):
        super().__init__(parent)
        self.existing_posts = existing_posts or {}
        self.custom_post = post_to_edit
        self.statistic_groups = statistic_groups
        self.post_manager = PostManager()  # Ajout du PostManager ici
        self.init_ui()
        if post_to_edit:
            self.load_post_data(post_to_edit)

    def init_ui(self):
        self.setWindowTitle("Nouveau Poste")
        layout = QVBoxLayout(self)

        # Nom du poste
        name_layout = QHBoxLayout()
        self.name_input = QLineEdit()
        self.name_input.setMaxLength(4)
        self.name_input.setPlaceholderText("2-4 caractères")
        name_layout.addWidget(QLabel("Nom du poste:"))
        name_layout.addWidget(self.name_input)
        layout.addLayout(name_layout)

        # Horaires
        time_layout = QHBoxLayout()
        self.start_time = QTimeEdit()
        self.end_time = QTimeEdit()
        self.start_time.setDisplayFormat("HH:mm")
        self.end_time.setDisplayFormat("HH:mm")
        time_layout.addWidget(QLabel("De:"))
        time_layout.addWidget(self.start_time)
        time_layout.addWidget(QLabel("À:"))
        time_layout.addWidget(self.end_time)
        layout.addLayout(time_layout)

        # Types de jour
        days_group = QGroupBox("Types de jour")
        days_layout = QHBoxLayout()
        self.weekday_check = QCheckBox("Semaine")
        self.saturday_check = QCheckBox("Samedi")
        self.sunday_check = QCheckBox("Dimanche/Férié")
        days_layout.addWidget(self.weekday_check)
        days_layout.addWidget(self.saturday_check)
        days_layout.addWidget(self.sunday_check)
        days_group.setLayout(days_layout)
        layout.addWidget(days_group)

        # Type d'assignation
        assignment_layout = QHBoxLayout()
        self.assignment_combo = QComboBox()
        self.assignment_combo.addItems(["Médecin", "CAT", "Les deux"])  # Utiliser les mêmes valeurs que dans le code
        assignment_layout.addWidget(QLabel("Assignation:"))
        assignment_layout.addWidget(self.assignment_combo)
        layout.addLayout(assignment_layout)

        # Groupe statistique
        stats_layout = QHBoxLayout()
        self.stats_combo = QComboBox()
        
        # Ajouter "Aucun"
        self.stats_combo.addItem("Aucun")
        
        # Ajouter les groupes de weekend
        self.stats_combo.insertSeparator(self.stats_combo.count())
        self.stats_combo.addItem("--- WEEKEND ---")
        for category, subgroups in self.statistic_groups["Weekend"]:
            self.stats_combo.insertSeparator(self.stats_combo.count())
            self.stats_combo.addItem(category)  # En-tête de catégorie
            for group in subgroups:
                self.stats_combo.addItem("    " + group)  # Sous-groupes indentés
        
        # Ajouter les groupes de semaine
        self.stats_combo.insertSeparator(self.stats_combo.count())
        self.stats_combo.addItem("--- SEMAINE ---")
        for category, subgroups in self.statistic_groups["Semaine"]:
            self.stats_combo.insertSeparator(self.stats_combo.count())
            self.stats_combo.addItem(category)  # En-tête de catégorie
            for group in subgroups:
                self.stats_combo.addItem("    " + group)  # Sous-groupes indentés

        # Désactiver les séparateurs et en-têtes
        model = self.stats_combo.model()
        for i in range(self.stats_combo.count()):
            text = self.stats_combo.itemText(i)
            if "---" in text or not text.startswith("    "):
                item = model.item(i)
                if item:
                    item.setEnabled(False)

        stats_layout.addWidget(QLabel("Groupe statistique:"))
        stats_layout.addWidget(self.stats_combo)
        layout.addLayout(stats_layout)


        # Combinaisons possibles
        self.init_combinations_ui(layout)

        # Boutons
        button_layout = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        cancel_button = QPushButton("Annuler")
        save_button.clicked.connect(self.validate_and_save)
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(save_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)
        
        # Connecter les changements d'horaires à la mise à jour des combinaisons
        self.start_time.timeChanged.connect(self.update_available_combinations)
        self.end_time.timeChanged.connect(self.update_available_combinations)


    def init_combinations_ui(self, parent_layout):
        combinations_group = QGroupBox("Combinaisons possibles")
        self.combinations_layout = QVBoxLayout()

        explanation = QLabel("Les postes disponibles pour la combinaison seront affichés en fonction des horaires compatibles")
        explanation.setWordWrap(True)
        self.combinations_layout.addWidget(explanation)

        self.combination_widgets = {}  # Stocke les widgets pour pouvoir les montrer/cacher
        
        # Créer les checkboxes pour tous les postes mais les cacher initialement
        all_posts = list(ALL_POST_TYPES) + [post.name for post in self.existing_posts.values()]
        
        for post_name in all_posts:
            checkbox = QCheckBox(post_name)
            checkbox.hide()  # Caché par défaut
            self.combination_widgets[post_name] = checkbox
            self.combinations_layout.addWidget(checkbox)

        combinations_group.setLayout(self.combinations_layout)
        parent_layout.addWidget(combinations_group)

    def get_post_period(self, start_time: time, end_time: time) -> int:
        """
        Détermine la période d'un créneau horaire
        0: Matin (7h-13h)
        1: Après-midi (13h-18h)
        2: Soir (18h-7h)
        """
        print(f"Analyse du créneau : {start_time} - {end_time}")
        
        if end_time < start_time:
            hours_range = list(range(start_time.hour, 24)) + list(range(0, end_time.hour + 1))
        else:
            hours_range = list(range(start_time.hour, end_time.hour + 1))
        
        print(f"Heures à analyser : {hours_range}")
        
        morning_hours = sum(1 for h in hours_range if 7 <= (h % 24) < 13)
        afternoon_hours = sum(1 for h in hours_range if 13 <= (h % 24) < 18)
        evening_hours = sum(1 for h in hours_range if (h % 24) >= 18 or (h % 24) < 7)
        
        print(f"Heures du matin : {morning_hours}")
        print(f"Heures de l'après-midi : {afternoon_hours}")
        print(f"Heures du soir : {evening_hours}")
        
        max_hours = max(morning_hours, afternoon_hours, evening_hours)
        
        if max_hours == morning_hours:
            print("Assigné à la période du matin")
            return 0
        elif max_hours == afternoon_hours:
            print("Assigné à la période de l'après-midi")
            return 1
        else:
            print("Assigné à la période du soir")
            return 2

    def update_available_combinations(self):
        """Met à jour dynamiquement les postes disponibles pour la combinaison"""
        start_time = self.start_time.time().toPyTime()
        end_time = self.end_time.time().toPyTime()

        if start_time >= end_time and not end_time.hour < 7:  # Permettre les créneaux qui traversent minuit
            return

        # Déterminer la période du nouveau poste
        new_post_period = self.get_post_period(start_time, end_time)

        for post_name, widget in self.combination_widgets.items():
            is_compatible = False
            
            if post_name in ALL_POST_TYPES:
                # Obtenir les horaires des postes standards
                post_details = self.post_manager.get_post_details(post_name, "weekday")
                if post_details:
                    post_start = post_details['start_time']
                    post_end = post_details['end_time']
                    
                    # Vérifier la compatibilité horaire
                    if not (start_time < post_end and end_time > post_start):
                        # Vérifier la période du poste standard
                        standard_post_period = self.get_post_period(post_start, post_end)
                        # Les périodes doivent être différentes pour être compatibles
                        is_compatible = new_post_period != standard_post_period
                        
            elif post_name in self.existing_posts:
                # Vérifier la compatibilité avec les postes personnalisés existants
                custom_post = self.existing_posts[post_name]
                if not (start_time < custom_post.end_time and end_time > custom_post.start_time):
                    existing_post_period = self.get_post_period(custom_post.start_time, custom_post.end_time)
                    is_compatible = new_post_period != existing_post_period

            # Montrer ou cacher le checkbox selon la compatibilité
            widget.setVisible(is_compatible)
            if not is_compatible and widget.isChecked():
                widget.setChecked(False)

    def load_post_data(self, post):
        """Charge les données d'un poste existant pour l'édition"""
        self.name_input.setText(post.name)
        self.start_time.setTime(QTime(post.start_time.hour, post.start_time.minute))
        self.end_time.setTime(QTime(post.end_time.hour, post.end_time.minute))
        
        # Types de jour
        self.weekday_check.setChecked("weekday" in post.day_types)
        self.saturday_check.setChecked("saturday" in post.day_types)
        self.sunday_check.setChecked("sunday_holiday" in post.day_types)
        
        # Assignation
        index = self.assignment_combo.findText(post.assignment_type.title())
        if index >= 0:
            self.assignment_combo.setCurrentIndex(index)
            
        # Sélectionner le bon groupe statistique
        if post.statistic_group:
            for i in range(self.stats_combo.count()):
                if self.stats_combo.itemText(i).strip() == post.statistic_group:
                    self.stats_combo.setCurrentIndex(i)
                    break
                
        # Combinaisons
        for post_name, combo_name in post.possible_combinations.items():
            if post_name in self.combination_widgets:
                self.combination_widgets[post_name].setChecked(True)

    def validate_and_save(self):
        try:
            # Validation du nom
            name = self.name_input.text().upper()
            if not name:
                raise ValueError("Le nom du poste est requis")
            if len(name) < 2 or len(name) > 4:
                raise ValueError("Le nom du poste doit contenir entre 2 et 4 caractères")

            # Validation des horaires
            start_time = self.start_time.time().toPyTime()
            end_time = self.end_time.time().toPyTime()
            if start_time >= end_time:
                raise ValueError("L'heure de début doit être antérieure à l'heure de fin")
            
            # Validation des types de jour
            day_types = set()
            if self.weekday_check.isChecked():
                day_types.add("weekday")
            if self.saturday_check.isChecked():
                day_types.add("saturday")
            if self.sunday_check.isChecked():
                day_types.add("sunday_holiday")
            
            if not day_types:
                raise ValueError("Au moins un type de jour doit être sélectionné")

            # Récupération des combinaisons
            combinations = {}
            for post_name, checkbox in self.combination_widgets.items():
                if checkbox.isChecked():
                    # Le nom de la combinaison est automatiquement générée
                    # en concaténant les noms des postes dans l'ordre
                    combo_name = name + post_name
                    combinations[post_name] = combo_name

            # Création du CustomPost
                self.custom_post = CustomPost(
                name=name,
                start_time=start_time,
                end_time=end_time,
                day_types=day_types,
                assignment_type=self.assignment_combo.currentText(),  # Plus besoin de .lower()
                possible_combinations=combinations,
                statistic_group=None if self.stats_combo.currentText() == "Aucun" else self.stats_combo.currentText()
            )

            self.accept()

        except ValueError as e:
            QMessageBox.warning(self, "Erreur de validation", str(e))

    def get_post(self) -> Optional[CustomPost]:
        """
        Convertit le type d'assignation en valeur correcte pour le CustomPost
        """
        assignment_mapping = {
            "Médecin": "doctors",
            "CAT": "cats",
            "Les deux": "both"
        }

        # Nettoyer le groupe statistique sélectionné (enlever les espaces et vérifier si c'est un vrai groupe)
        selected_group = self.stats_combo.currentText().strip()
        if selected_group == "Aucun" or not selected_group.startswith("    "):
            statistic_group = None
        else:
            statistic_group = selected_group.strip()  # Enlever les espaces de début
            
        if hasattr(self, 'custom_post'):
            # Convertir le type d'assignation
            assignment = assignment_mapping.get(self.custom_post.assignment_type)
            if assignment:
                self.custom_post.assignment_type = assignment
            return self.custom_post
        return None
    

# gui/doctor_planning_view.py

# © 2024 HILAL Arkane. Tous droits réservés.
# .gui/doctor_planning_view
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QComboBox, QScrollArea
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QColor, QBrush, QFont
from datetime import date, timedelta
from typing import Union
from core.utils import get_post_period
from core.Constantes.models import TimeSlot



# Ajoutez ces constantes au début de chaque fichier
WEEKEND_COLOR = QColor(220, 220, 220)  # Gris clair pour les weekends et jours fériés
WEEKDAY_COLOR = QColor(255, 255, 255)  # Blanc pour les jours de semaine
DESIDERATA_COLOR = QColor(255, 200, 200)  # Rouge clair pour les desideratas
WEEKEND_DESIDERATA_COLOR = QColor(255, 150, 150)  # Rouge plus foncé pour les desideratas de weekend
WEEKDAY_TEXT_COLOR = QColor(100, 100, 100)  # Gris foncé pour le texte des jours de la semaine

class DoctorPlanningView(QWidget):
    def __init__(self, planning, doctors, cats):
        super().__init__()
        self.planning = planning
        self.doctors = sorted(doctors, key=lambda d: d.name.lower()) if doctors else []
        self.cats = sorted(cats, key=lambda c: c.name.lower()) if cats else []
        
        # Protection contre les accès concurrents
        self._is_updating = False
        self._update_pending = False
        
        # Timer pour le debounce des mises à jour
        self._update_timer = QTimer(self)
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._process_delayed_update)
        
        self.init_ui()


    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteur de médecin/CAT avec initialisation plus robuste
        selector_layout = QHBoxLayout()
        self.selector = QComboBox()
        self.selector.addItems([doctor.name for doctor in self.doctors])
        self.selector.addItems([cat.name for cat in self.cats])
        
        # S'assurer qu'il y a au moins un élément
        if self.selector.count() == 0:
            self.selector.addItem("Aucun médecin/CAT")
        
        # Configuration du sélecteur
        self.selector.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.selector.installEventFilter(self)
        self.selector.currentIndexChanged.connect(self._on_selection_changed)
        selector_layout.addWidget(self.selector)
        layout.addLayout(selector_layout)

        # Zone de défilement avec la table
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        
        # Table du planning
        self.table = QTableWidget()
        self.table.setAlternatingRowColors(True)
        scroll_area.setWidget(self.table)
        layout.addWidget(scroll_area)

        # Initialisation de la vue
        if self.planning:
            self.update_table()

    def update_selector(self):
        """Mise à jour sécurisée du sélecteur avec vérification de l'état"""
        if not hasattr(self, 'selector') or not self.selector:
            return
            
        current_text = self.selector.currentText()
        
        self.selector.blockSignals(True)
        try:
            self.selector.clear()
            
            # Ajout des médecins
            if self.doctors:
                for doctor in self.doctors:
                    self.selector.addItem(doctor.name)
                    
            # Ajout des CAT
            if self.cats:
                for cat in self.cats:
                    self.selector.addItem(cat.name)
            
            # S'assurer qu'il y a au moins un élément
            if self.selector.count() == 0:
                self.selector.addItem("Aucun médecin/CAT")
                return
                
            # Restaurer la sélection précédente si possible
            index = self.selector.findText(current_text)
            if index >= 0:
                self.selector.setCurrentIndex(index)
            else:
                self.selector.setCurrentIndex(0)  # Sélectionner le premier élément par défaut
                
        finally:
            self.selector.blockSignals(False)

    def _on_selection_changed(self, index):
        """Gestionnaire d'événement pour le changement de sélection"""
        if index >= 0:  # Vérifier que l'index est valide
            self.update_table()

    def update_view(self, planning, doctors, cats):
        """Mise à jour complète de la vue avec vérification des données"""
        if not planning or (not doctors and not cats):
            self.clear_view()
            return
            
        self.planning = planning
        self.doctors = sorted(doctors, key=lambda d: d.name.lower())
        self.cats = sorted(cats, key=lambda c: c.name.lower())
        
        # Mise à jour différée via le timer
        self._schedule_update()

    def _schedule_update(self):
        """Programme une mise à jour différée de l'interface"""
        self._update_timer.stop()  # Arrêter le timer précédent s'il existe
        self._update_timer.start(100)  # Démarrer un nouveau timer

    def _process_delayed_update(self):
        """Traite la mise à jour différée avec gestion des erreurs"""
        try:
            if not hasattr(self, 'selector') or not self.selector:
                return
                
            self.update_selector()  # Mettre à jour le sélecteur en premier
            self.update_table()     # Puis mettre à jour la table
            
        except Exception as e:
            print(f"Erreur lors de la mise à jour différée: {e}")
            
            
    def eventFilter(self, obj, event):
        if obj == self.selector and event.type() == event.Type.KeyPress:
            key = event.key()
            if key == Qt.Key.Key_Up or key == Qt.Key.Key_Down:
                current_index = self.selector.currentIndex()
                if key == Qt.Key.Key_Up and current_index > 0:
                    self.selector.setCurrentIndex(current_index - 1)
                elif key == Qt.Key.Key_Down and current_index < self.selector.count() - 1:
                    self.selector.setCurrentIndex(current_index + 1)
                return True
        return super().eventFilter(obj, event)

    def update_table(self):
        """Mise à jour sécurisée de la table"""
        if not hasattr(self, 'table') or not self.table:
            return
            
        if not self.planning or not self.planning.days:
            self.clear_table()
            return

        # Configuration des couleurs
        colors = {
            "primary": {
                "weekend": QColor(255, 150, 150),
                "normal": QColor(255, 200, 200)
            },
            "secondary": {
                "weekend": QColor(150, 200, 255),
                "normal": QColor(180, 220, 255)
            },
            "base": {
                "weekend": WEEKEND_COLOR,
                "normal": WEEKDAY_COLOR
            }
        }

        # Désactiver les mises à jour pendant le traitement
        self.table.setUpdatesEnabled(False)
        try:
            selected_name = self.selector.currentText()
            start_date = self.planning.start_date
            end_date = self.planning.end_date
            
            # Calcul des mois
            total_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

            # Configuration initiale
            self.table.clear()
            self.table.setRowCount(31)
            self.table.setColumnCount(total_months * 4 + 1)

            # En-têtes
            headers = ["Jour"]
            current_date = date(start_date.year, start_date.month, 1)
            for _ in range(total_months):
                month_name = current_date.strftime("%b")
                headers.extend([f"{month_name}\nJ", f"{month_name}\nM", f"{month_name}\nAM", f"{month_name}\nS"])
                current_date = (current_date.replace(day=28) + timedelta(days=4)).replace(day=1)
            
            self.table.setHorizontalHeaderLabels(headers)

            # Remplissage des données
            current_date = start_date
            while current_date <= end_date:
                self._populate_day_row(current_date, selected_name, colors)
                current_date += timedelta(days=1)

            # Ajustement final
            self._adjust_table_dimensions()
            
        except Exception as e:
            print(f"Erreur mise à jour table: {e}")
        finally:
            self.table.setUpdatesEnabled(True)

    def _populate_day_row(self, current_date, selected_name, colors):
        """Remplit une ligne du tableau pour un jour donné"""
        day_row = current_date.day - 1
        month_col = (current_date.year - self.planning.start_date.year) * 12 + current_date.month - self.planning.start_date.month
        col_offset = month_col * 4 + 1

        # Configuration de base de la ligne
        self._set_basic_row_items(day_row, col_offset, current_date)

        # Traitement des postes
        day_planning = next((day for day in self.planning.days if day.date == current_date), None)
        if day_planning:
            is_weekend_or_holiday = day_planning.is_weekend or day_planning.is_holiday_or_bridge
            background_color = colors["base"]["weekend" if is_weekend_or_holiday else "normal"]
            
            # Récupération et tri des slots par période
            slots = [slot for slot in day_planning.slots if slot.assignee == selected_name]
            periods = [[] for _ in range(3)]  # 3 périodes : matin, après-midi, soir
            
            for slot in slots:
                period_index = get_post_period(slot)  # Utilise la fonction existante
                if 0 <= period_index < 3:  # Vérifie que l'index est valide
                    periods[period_index].append(slot)

            # Obtention de la personne sélectionnée
            selected_person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
            
            # Remplissage des cellules pour chaque période
            for i in range(3):
                item = QTableWidgetItem()
                post_list = periods[i]
                
                # Texte de la cellule
                text = ", ".join(slot.abbreviation for slot in post_list)
                item.setText(text)
                
                # Coloration selon desiderata
                current_color = background_color
                
                if selected_person:
                    for desiderata in selected_person.desiderata:
                        if (desiderata.start_date <= current_date <= desiderata.end_date and 
                            desiderata.period == i + 1):  # +1 car les périodes de desiderata commencent à 1
                            priority = getattr(desiderata, 'priority', 'primary')
                            current_color = colors[priority]["weekend" if is_weekend_or_holiday else "normal"]
                            break
                
                item.setBackground(QBrush(current_color))
                self.table.setItem(day_row, col_offset + i + 1, item)



    def _set_basic_row_items(self, day_row, col_offset, current_date):
        """Configure les cellules de base d'une ligne (jour et jour de la semaine)"""
        # Jour
        day_item = QTableWidgetItem(str(current_date.day))
        day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        self.table.setItem(day_row, 0, day_item)
        
        # Jour de la semaine
        weekday_item = QTableWidgetItem(self.get_weekday_abbr(current_date.weekday()))
        weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        weekday_item.setForeground(QBrush(WEEKDAY_TEXT_COLOR))
        font = QFont()
        font.setPointSize(8)
        weekday_item.setFont(font)
        self.table.setItem(day_row, col_offset, weekday_item)

    def _get_cell_color(self, date, is_weekend, person, period, colors):
        """Détermine la couleur de la cellule basée sur les desideratas"""
        if not person:
            return colors["base"]["weekend" if is_weekend else "normal"]
            
        for desiderata in person.desiderata:
            if (desiderata.start_date <= date <= desiderata.end_date and 
                desiderata.period == period):
                priority = getattr(desiderata, 'priority', 'primary')
                return colors[priority]["weekend" if is_weekend else "normal"]
                
        return colors["base"]["weekend" if is_weekend else "normal"]

    def _adjust_table_dimensions(self):
        """Ajuste les dimensions finales du tableau"""
        for row in range(self.table.rowCount()):
            self.table.setRowHeight(row, 20)

        for col in range(self.table.columnCount()):
            if col == 0:
                self.table.setColumnWidth(col, 40)
            elif (col - 1) % 4 == 0:
                self.table.setColumnWidth(col, 30)
            else:
                self.table.setColumnWidth(col, 50)

        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)

    def get_weekday_abbr(self, weekday):
        return ["L", "M", "M", "J", "V", "S", "D"][weekday]

    def get_post_period(self, slot_or_abbrev: Union[TimeSlot, str]) -> int:
        """
        Détermine la période d'un poste (0: Matin, 1: Après-midi, 2: Soir)
        """
        # Si on reçoit un objet TimeSlot complet
        if isinstance(slot_or_abbrev, TimeSlot):
            start_hour = slot_or_abbrev.start_time.hour
            if 7 <= start_hour < 13:
                return 0  # Matin
            elif 13 <= start_hour < 18:
                return 1  # Après-midi
            else:
                return 2  # Soir
        
        # Si on reçoit juste l'abréviation (pour les postes standards)
        if isinstance(slot_or_abbrev, str):
            if slot_or_abbrev in ["ML", "MC", "MM", "CM", "HM", "SM", "RM"]:
                return 0
            elif slot_or_abbrev in ["CA", "HA", "SA", "RA", "AL", "AC"]:
                return 1
            else:
                return 2

        return 2  # Par défaut
        
    def clear_table(self):
        self.table.clear()
        self.table.setRowCount(1)
        self.table.setColumnCount(1)
        self.table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))
        
    def clear_view(self):
        self.planning = None
        self.table.clear()
        self.table.setRowCount(0)
        self.table.setColumnCount(0)
        self.selector.setCurrentIndex(0)

# gui/styles.py

# gui/styles.py

EDIT_DELETE_BUTTON_STYLE = """
    QPushButton {
        background-color: #f8f8f8;
        border: 1px solid #ddd;
        padding: 4px 8px;
        border-radius: 4px;
        min-width: 24px;
        max-width: 24px;
        min-height: 24px;
        max-height: 24px;
    }
    QPushButton:hover {
        background-color: #e8e8e8;
        border: 1px solid #ccc;
    }
    QPushButton:pressed {
        background-color: #d8d8d8;
    }
"""



# gui/desiderata_management.py

# © 2024 HILAL Arkane. Tous droits réservés.
# gui/desiderata_management.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QScrollArea, QGridLayout, QAbstractScrollArea,
                             QTableWidget, QTableWidgetItem, QComboBox, QMessageBox, QLabel, QDateEdit, QMessageBox,
                             QSplitter, QHeaderView,QDialog)
from PyQt6.QtCore import Qt, QDate, QEvent
from PyQt6.QtGui import QColor, QBrush, QFont
from core.Constantes.models import Desiderata, Doctor, CAT
from datetime import date, timedelta
from workalendar.europe import France
from PyQt6.QtWidgets import QFileDialog
from datetime import datetime
import csv
import os
import logging
# Au début du fichier desiderata_management.py, ajoutez ces imports
import csv
import codecs
from datetime import datetime
from PyQt6.QtWidgets import QFileDialog

logger = logging.getLogger(__name__)

class DesiderataCalendarWidget(QTableWidget):
    def __init__(self, start_date, end_date):
        super().__init__()
        self.start_date = start_date
        self.end_date = end_date
        self.cal = France()
        self.selections = {}
        self.is_selecting = False
        self.current_selection_priority = None
        self.is_deselecting = False  # Nouveau mode pour la désélection
        self.init_ui()

    def init_ui(self):
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.verticalHeader().setVisible(False)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        self.create_calendar()
        self.cellPressed.connect(self.on_cell_pressed)
        self.cellEntered.connect(self.on_cell_entered)
        self.setMouseTracking(True)
        self.viewport().installEventFilter(self)
        
    

    def create_calendar(self):
        self.clear()
        days_abbr = ["L", "M", "M", "J", "V", "S", "D"]
        months = (self.end_date.year - self.start_date.year) * 12 + self.end_date.month - self.start_date.month + 1

        total_columns = 5 * months  # 5 colonnes pour chaque mois (Jour, Mois, M, AM, S)
        self.setColumnCount(total_columns)
        self.setRowCount(31)

        current_date = self.start_date
        for i in range(months):
            base_col = i * 5
            month_name = current_date.strftime("%b")
            self.setHorizontalHeaderItem(base_col, QTableWidgetItem("Jour"))
            self.setHorizontalHeaderItem(base_col + 1, QTableWidgetItem(month_name))
            self.setHorizontalHeaderItem(base_col + 2, QTableWidgetItem("M"))
            self.setHorizontalHeaderItem(base_col + 3, QTableWidgetItem("AM"))
            self.setHorizontalHeaderItem(base_col + 4, QTableWidgetItem("S"))
            current_date += timedelta(days=32)
            current_date = current_date.replace(day=1)

        current_date = self.start_date
        while current_date <= self.end_date:
            row = current_date.day - 1
            month_col = (current_date.year - self.start_date.year) * 12 + current_date.month - self.start_date.month
            base_col = month_col * 5

            is_weekend = current_date.weekday() >= 5
            is_holiday = self.cal.is_holiday(current_date)
            background_color = QColor(220, 220, 220) if is_weekend or is_holiday else QColor(255, 255, 255)

            # Colonne de jour pour chaque mois
            day_item = QTableWidgetItem(str(current_date.day))
            day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            day_item.setBackground(QBrush(background_color))
            self.setItem(row, base_col, day_item)

            # Colonne du jour de la semaine
            weekday_item = QTableWidgetItem(days_abbr[current_date.weekday()])
            weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            weekday_item.setForeground(QBrush(QColor(150, 150, 150)))
            weekday_item.setBackground(QBrush(background_color))
            self.setItem(row, base_col + 1, weekday_item)

            # Colonnes M, AM, S
            for i in range(3):
                item = QTableWidgetItem()
                item.setBackground(QBrush(background_color))
                self.setItem(row, base_col + 2 + i, item)

            current_date += timedelta(days=1)

        # Réduire la hauteur des lignes et la largeur des colonnes
        for row in range(self.rowCount()):
            self.setRowHeight(row, int(self.rowHeight(row) * 4/6))
        for col in range(self.columnCount()):
            self.setColumnWidth(col, int(self.columnWidth(col) * 3/5))
            
    def update_dates(self, start_date, end_date):
        self.store_selections()  # Stocker les sélections avant de mettre à jour
        self.start_date = start_date
        self.end_date = end_date
        self.create_calendar()
        self.restore_selections()

    def store_selections(self):
        self.selections.clear()
        for row in range(self.rowCount()):
            for col in range(1, self.columnCount()):
                item = self.item(row, col)
                if item and item.background().color() in [QColor(255, 150, 150), QColor(255, 200, 200)]:
                    date = self.get_date_from_cell(row, col)
                    if date:
                        self.selections[date] = col - (((col - 1) // 4) * 4)

    def restore_selections(self):
        for date, period in self.selections.items():
            if self.start_date <= date <= self.end_date:
                row = date.day - 1
                month_col = (date.year - self.start_date.year) * 12 + date.month - self.start_date.month
                col = 1 + month_col * 4 + period
                item = self.item(row, col)
                if item:
                    self.toggle_cell(item, force_select=True)

    def get_date_from_cell(self, row, col):
        month_col = col // 5
        year = self.start_date.year + (self.start_date.month + month_col - 1) // 12
        month = (self.start_date.month + month_col - 1) % 12 + 1
        day = row + 1
        try:
            return date(year, month, day)
        except ValueError:
            return None


    def toggle_cell(self, item, force_select=False, priority="primary"):
        """Toggle une cellule avec la couleur appropriée selon la priorité"""
        current_color = item.background().color()
        
        # Vérifier si c'est un weekend ou férié en utilisant la date
        col = item.column()
        row = item.row()
        date = self.get_date_from_cell(row, col - (col % 5))
        is_weekend_or_holiday = date and (date.weekday() >= 5 or self.cal.is_holiday(date))
        
        # Définition des couleurs
        colors = {
            "primary": {
                "weekend": QColor(255, 150, 150),     # Rouge plus foncé pour weekend
                "normal": QColor(255, 200, 200)       # Rouge clair pour jours normaux
            },
            "secondary": {
                "weekend": QColor(150, 200, 255),     # Bleu plus foncé pour weekend
                "normal": QColor(180, 220, 255)       # Bleu clair pour jours normaux
            },
            "base": {
                "weekend": QColor(220, 220, 220),     # Gris pour weekend
                "normal": QColor(255, 255, 255)       # Blanc pour jours normaux
            }
        }

        if priority is None:  # Protection contre les valeurs None
            priority = "primary"

        if force_select:
            new_color = colors[priority]["weekend" if is_weekend_or_holiday else "normal"]
        elif self.is_selecting:
            if self.is_deselecting:
                # Mode désélection : restaurer la couleur de base
                new_color = colors["base"]["weekend" if is_weekend_or_holiday else "normal"]
            else:
                # Mode sélection : appliquer la nouvelle couleur selon le type de jour
                new_color = colors[priority]["weekend" if is_weekend_or_holiday else "normal"]
        else:
            # Clic simple : inverser l'état
            current_priority = self.get_cell_priority(item)
            if current_priority == priority:
                # Si même priorité, restaurer la couleur de base
                new_color = colors["base"]["weekend" if is_weekend_or_holiday else "normal"]
            else:
                # Sinon, appliquer la nouvelle couleur
                new_color = colors[priority]["weekend" if is_weekend_or_holiday else "normal"]

        item.setBackground(QBrush(new_color))

    def mousePressEvent(self, event):
        """Gère les clics de souris pour les deux types de desiderata"""
        item = self.itemAt(event.pos())
        if not item:
            return

        col = item.column()
        if col % 5 not in [2, 3, 4]:  # Uniquement pour les colonnes M, AM, S
            return

        self.is_selecting = True
        
        # Détermine la priorité selon le bouton de souris
        if event.button() == Qt.MouseButton.LeftButton:
            self.current_selection_priority = "primary"
        elif event.button() == Qt.MouseButton.RightButton:
            self.current_selection_priority = "secondary"
            event.accept()

        # Vérifie si on doit passer en mode désélection
        current_priority = self.get_cell_priority(item)
        self.is_deselecting = (current_priority == self.current_selection_priority)

        self.toggle_cell(item, priority=self.current_selection_priority)

    def mouseMoveEvent(self, event):
        """Gestion du glissement avec maintien du mode (sélection ou désélection)"""
        if not self.is_selecting:
            return

        item = self.itemAt(event.pos())
        if item and item.column() % 5 in [2, 3, 4]:
            self.toggle_cell(item, priority=self.current_selection_priority)

    def mouseReleaseEvent(self, event):
        """Réinitialisation des états de sélection"""
        self.is_selecting = False
        self.current_selection_priority = None
        self.is_deselecting = False

    def get_cell_priority(self, item) -> str:
        """Détermine la priorité d'une cellule selon sa couleur"""
        color = item.background().color()
        if color in [QColor(255, 150, 150), QColor(255, 200, 200)]:  # Rouge
            return "primary"
        elif color in [QColor(150, 200, 255), QColor(180, 220, 255)]:  # Bleu
            return "secondary"
        return None

    def get_selected_desiderata(self):
        """Retourne les desiderata sélectionnés avec leur priorité"""
        desiderata = []
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 5):
                date = self.get_date_from_cell(row, col - 2)
                if date is None or date > self.end_date:
                    continue

                for i in range(3):
                    item = self.item(row, col + i)
                    if item:
                        priority = self.get_cell_priority(item)
                        if priority:  # Si une couleur de desiderata est présente
                            desiderata.append((date, i + 1, priority))
        return desiderata


    def set_desiderata(self, desiderata):
        """Configure les desiderata avec rétrocompatibilité pour l'ancien format"""
        self.reset_to_initial_state()
        
        for d in desiderata:
            # Vérification du type de l'objet Desiderata
            if isinstance(d, Desiderata):
                date = d.start_date
                period = d.period
                priority = getattr(d, 'priority', 'primary')
            elif isinstance(d, tuple):
                if len(d) == 2:  # Ancien format
                    date, period = d
                    priority = 'primary'
                elif len(d) == 3:  # Nouveau format
                    date, period, priority = d
                else:
                    continue
            else:
                continue

            if self.start_date <= date <= self.end_date:
                row = date.day - 1
                month_col = (date.year - self.start_date.year) * 12 + date.month - self.start_date.month
                base_col = month_col * 5
                col = base_col + 2 + (period - 1)
                
                item = self.item(row, col)
                if item:
                    self.toggle_cell(item, force_select=True, priority=priority)


    def on_cell_pressed(self, row, column):
        if column % 5 in [2, 3, 4]:
            item = self.item(row, column)
            if item:
                self.is_selecting = True
                self.selection_state = item.background().color() != self.get_desiderata_color(item)
                self.toggle_cell(item)

    def on_cell_entered(self, row, column):
        if self.is_selecting and column % 5 in [2, 3, 4]:
            item = self.item(row, column)
            if item:
                self.toggle_cell(item)

    def eventFilter(self, obj, event):
        if obj == self.viewport():
            if event.type() == QEvent.Type.MouseButtonRelease:
                self.is_selecting = False
        return super().eventFilter(obj, event)


    def get_desiderata_color(self, item):
        is_weekend_or_holiday = item.background().color() == QColor(220, 220, 220)
        return QColor(255, 150, 150) if is_weekend_or_holiday else QColor(255, 200, 200)




    
    def reset_to_initial_state(self):
        for row in range(self.rowCount()):
            for col in range(1, self.columnCount()):
                item = self.item(row, col)
                if item:
                    date = self.get_date_from_cell(row, col)
                    if date:
                        is_weekend = date.weekday() >= 5
                        is_holiday = self.cal.is_holiday(date)
                        if is_weekend or is_holiday:
                            item.setBackground(QBrush(QColor(220, 220, 220)))
                        else:
                            item.setBackground(QBrush(QColor(255, 255, 255)))


    def clear_all_selections(self):
        self.reset_to_initial_state()

    


    def is_bridge_day(self, date):
        # 1) Lundi avant un mardi férié
        if date.weekday() == 0 and self.cal.is_holiday(date + timedelta(days=1)):
            return True
        
        # 2) Vendredi et samedi après un jeudi férié
        if date.weekday() in [4, 5] and self.cal.is_holiday(date - timedelta(days=1 if date.weekday() == 4 else 2)):
            return True
        
        # 3) Samedi après un vendredi férié
        if date.weekday() == 5 and self.cal.is_holiday(date - timedelta(days=1)):
            return True
        
        # 4) Jour de semaine entre deux jours fériés
        if 0 <= date.weekday() <= 4:  # Jours de semaine (lundi à vendredi)
            if (self.cal.is_holiday(date - timedelta(days=1)) and 
                self.cal.is_holiday(date + timedelta(days=1))):
                return True
        
        return False

 

    
class DesiderataManagementWidget(QWidget):
    def __init__(self, doctors, cats, planning_start_date, planning_end_date, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.planning_start_date = planning_start_date
        self.planning_end_date = planning_end_date
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)
        self.init_ui()

    def detect_file_encoding(self, file_path):
        """
        Détecte l'encodage d'un fichier CSV.
        
        Args:
            file_path (str): Chemin du fichier à analyser
            
        Returns:
            str: Encodage détecté ('utf-8-sig' ou 'utf-8')
        """
        try:
            with open(file_path, 'rb') as f:
                raw = f.read(4)
                if raw.startswith(b'\xef\xbb\xbf'):
                    self.logger.debug("Encodage détecté: UTF-8 avec BOM")
                    return 'utf-8-sig'
                elif raw.startswith(b'\xff\xfe') or raw.startswith(b'\xfe\xff'):
                    self.logger.debug("Encodage détecté: UTF-16")
                    return 'utf-16'
                else:
                    try:
                        raw.decode('utf-8')
                        self.logger.debug("Encodage détecté: UTF-8 sans BOM")
                        return 'utf-8'
                    except UnicodeDecodeError:
                        self.logger.warning("Encodage non détecté, utilisation UTF-8 par défaut")
                        return 'utf-8'
        except Exception as e:
            self.logger.error(f"Erreur lors de la détection de l'encodage: {str(e)}")
            return 'utf-8'

    def init_ui(self):
        self.layout = QVBoxLayout(self)

        # Modifier les champs de date pour utiliser un calendrier
        date_layout = QHBoxLayout()
        self.start_date = QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setCalendarPopup(True)
        self.start_date.setDate(QDate(self.planning_start_date))
        self.end_date.setDate(QDate(self.planning_end_date))

        self.apply_dates_button = QPushButton("Appliquer les dates")
        self.apply_dates_button.clicked.connect(self.apply_dates)

        date_layout.addWidget(QLabel("Date de début:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("Date de fin:"))
        date_layout.addWidget(self.end_date)
        date_layout.addWidget(self.apply_dates_button)

        self.layout.addLayout(date_layout)

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        self.person_selector = QComboBox()
        self.update_person_selector()
        self.person_selector.currentIndexChanged.connect(self.update_calendar)
        self.person_selector.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.person_selector.installEventFilter(self)
        left_layout.addWidget(self.person_selector)

        self.calendar_widget = DesiderataCalendarWidget(self.planning_start_date, self.planning_end_date)
        self.calendar_widget.setMinimumSize(800, 600)
        left_layout.addWidget(self.calendar_widget)

        # Création du layout des boutons
        button_layout = QHBoxLayout()
        
        # Bouton de sauvegarde
        save_button = QPushButton("Enregistrer les desiderata")
        save_button.clicked.connect(self.save_desiderata)
        button_layout.addWidget(save_button)

        # Bouton de réinitialisation
        reset_button = QPushButton("Réinitialiser les desiderata")
        reset_button.clicked.connect(self.reset_desiderata)
        button_layout.addWidget(reset_button)

        # Bouton de réinitialisation globale
        reset_all_button = QPushButton("Réinitialiser tous les desiderata")
        reset_all_button.clicked.connect(self.reset_all_desiderata)
        button_layout.addWidget(reset_all_button)

        # Ajout du nouveau bouton d'import CSV
        import_button = QPushButton("Importer depuis CSV")
        import_button.clicked.connect(self.import_multiple_desiderata)
        button_layout.addWidget(import_button)

        left_layout.addLayout(button_layout)

        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)

        self.stats_label = QLabel("Statistiques d'indisponibilité:")
        right_layout.addWidget(self.stats_label)
        
        self.stats_table = QTableWidget()
        self.stats_table.setColumnCount(2)
        self.stats_table.setHorizontalHeaderLabels(["Médecin/CAT", "% d'indisponibilité"])
        right_layout.addWidget(self.stats_table)
        
        # Ajouter le bouton des périodes critiques
        self.show_critical_periods_button = QPushButton("Afficher les périodes critiques")
        self.show_critical_periods_button.clicked.connect(self.show_critical_periods)
        right_layout.addWidget(self.show_critical_periods_button)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)
        splitter.setSizes([int(self.width() * 0.7), int(self.width() * 0.3)])

        self.layout.addWidget(splitter)

        self.update_stats()
        self.update_calendar()
        
    def apply_dates(self):
        new_start_date = self.start_date.date().toPyDate()
        new_end_date = self.end_date.date().toPyDate()
        
        if new_start_date > new_end_date:
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return

        self.planning_start_date = new_start_date
        self.planning_end_date = new_end_date
        
        self.calendar_widget.update_dates(new_start_date, new_end_date)
        
        # Mettre à jour les dates dans le planning principal
        self.main_window.planning_tab.start_date.setDate(QDate(new_start_date))
        self.main_window.planning_tab.end_date.setDate(QDate(new_end_date))
        
        self.update_stats()
        self.update_calendar()
        
        QMessageBox.information(self, "Succès", "Les dates ont été appliquées avec succès.")

    def sync_dates_from_planning(self, start_date, end_date):
        self.start_date.setDate(QDate(start_date))
        self.end_date.setDate(QDate(end_date))
        self.planning_start_date = start_date
        self.planning_end_date = end_date
        self.calendar_widget.update_dates(start_date, end_date)
        self.update_stats()
        self.update_calendar()

     # Ajouter la méthode pour afficher la fenêtre des périodes critiques
    def show_critical_periods(self):
            self.critical_periods_window = CriticalPeriodsWindow(
                self.doctors,
                self.cats,
                self.planning_start_date,
                self.planning_end_date,
                self
            )
            self.critical_periods_window.show()
            
    def update_person_selector(self):
        self.person_selector.clear()
        sorted_doctors = sorted(self.doctors, key=lambda x: x.name.lower())
        sorted_cats = sorted(self.cats, key=lambda x: x.name.lower())
        
        for doctor in sorted_doctors:
            self.person_selector.addItem(doctor.name)
        
        if sorted_cats:
            self.person_selector.insertSeparator(len(sorted_doctors))
        
        for cat in sorted_cats:
            self.person_selector.addItem(cat.name)
            
    def update_calendar(self):
        """Met à jour le calendrier avec les desiderata de la personne sélectionnée"""
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            # Convertir les desiderata en tuples avec priorité
            desiderata_tuples = [
                (d.start_date, d.period, getattr(d, 'priority', 'primary'))
                for d in person.desiderata
            ]
            self.calendar_widget.set_desiderata(desiderata_tuples)
        else:
            self.calendar_widget.clear_all_selections()
    
    def eventFilter(self, obj, event):
        if obj == self.person_selector and event.type() == QEvent.Type.KeyPress:
            key = event.key()
            if key == Qt.Key.Key_Up:
                index = self.person_selector.currentIndex()
                if index > 0:
                    self.person_selector.setCurrentIndex(index - 1)
                return True
            elif key == Qt.Key.Key_Down:
                index = self.person_selector.currentIndex()
                if index < self.person_selector.count() - 1:
                    self.person_selector.setCurrentIndex(index + 1)
                return True
        return super().eventFilter(obj, event)

    def save_desiderata(self):
        """Sauvegarde les desiderata avec leur priorité"""
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            new_desiderata = self.calendar_widget.get_selected_desiderata()
            person.desiderata = [
                Desiderata(date, date, "Indisponibilité", period, priority) 
                for date, period, priority in new_desiderata
            ]
            self.logger.info(f"Sauvegarde desiderata pour {person.name}")
            for d in person.desiderata:
                self.logger.debug(f"  - Date: {d.start_date}, Période: {d.period}, Priorité: {d.priority}")
            
            self.update_stats()
            self.main_window.save_data()
            QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été enregistrés avec succès.")
            
    def reset_desiderata(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            confirm = QMessageBox.question(self, "Confirmation", 
                                           f"Êtes-vous sûr de vouloir réinitialiser les desiderata de {person.name} ?",
                                           QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if confirm == QMessageBox.StandardButton.Yes:
                person.desiderata = []
                self.calendar_widget.clear_all_selections()
                self.update_stats()
                QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été réinitialisés.")

    def reset_all_desiderata(self):
        confirm = QMessageBox.question(self, "Confirmation", 
                                       "Êtes-vous sûr de vouloir réinitialiser tous les desiderata pour tous les médecins et CAT ?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            for person in self.doctors + self.cats:
                person.desiderata = []
            self.calendar_widget.clear_all_selections()
            self.update_stats()
            self.update_calendar()
            QMessageBox.information(self, "Succès", "Tous les desiderata ont été réinitialisés.")

    def update_stats(self):
        """
        Met à jour les statistiques d'indisponibilité pour chaque personne.
        Gère les cas où il n'y a pas de période ou de planning disponible.
        """
        self.stats_table.setRowCount(0)
        
        try:
            # Vérifier que les dates sont valides
            if not (self.planning_start_date and self.planning_end_date):
                logger.warning("Dates de planning non définies")
                return
                
            total_days = max(1, (self.planning_end_date - self.planning_start_date).days + 1)
            stats = []

            # Parcourir chaque personne (médecins et CAT)
            for person in self.doctors + self.cats:
                # Calculer les périodes d'indisponibilité
                unavailable_periods = 0
                for des in person.desiderata:
                    if des.type == "Indisponibilité":
                        # Compter uniquement les jours dans la période du planning
                        start = max(des.start_date, self.planning_start_date)
                        end = min(des.end_date, self.planning_end_date)
                        if start <= end:  # Vérifier que la période est valide
                            unavailable_periods += 1

                # Calculer le nombre total de périodes possibles (3 périodes par jour)
                total_periods = max(1, total_days * 3)
                
                # Calculer le pourcentage d'indisponibilité
                unavailability_percentage = (unavailable_periods / total_periods) * 100
                
                # Initialiser le pourcentage de postes non attribués
                unassigned_percentage = 0
                
                # Vérifier si le planning est disponible
                planning = None
                if (hasattr(self.main_window, 'planning_tab') and 
                    hasattr(self.main_window.planning_tab, 'planning_generator')):
                    planning = getattr(self.main_window.planning_tab.planning_generator, 'planning', None)

                if planning is not None:
                    # Calculer le pourcentage de postes non attribués
                    unassigned_shifts = self.main_window.planning_tab.planning_generator.analyze_unassigned_shifts(planning)
                    target_distribution = getattr(
                        self.main_window.planning_tab.planning_generator,
                        'target_distribution',
                        {}
                    )

                    if person.name in target_distribution:
                        expected_shifts = sum(
                            target_distribution[person.name][day_type][post_type] 
                            for day_type in target_distribution[person.name] 
                            for post_type in target_distribution[person.name][day_type]
                        )
                        if expected_shifts > 0:
                            unassigned_total = sum(unassigned_shifts.get(person.name, {}).values())
                            unassigned_percentage = (unassigned_total / expected_shifts) * 100

                # Ajouter les statistiques à la liste
                stats.append((person.name, unavailability_percentage, unassigned_percentage))

            # Trier par pourcentage d'indisponibilité décroissant
            stats.sort(key=lambda x: x[1], reverse=True)

            # Remplir le tableau des statistiques
            for row, (name, unavail_pct, unassigned_pct) in enumerate(stats):
                self.stats_table.insertRow(row)
                
                # Ajouter le nom avec style selon le type de personne
                name_item = QTableWidgetItem(name)
                if any(cat.name == name for cat in self.cats):
                    name_item.setBackground(QBrush(QColor(200, 255, 200)))  # Vert clair pour les CAT
                elif any(doc.name == name and doc.half_parts == 1 for doc in self.doctors):
                    name_item.setBackground(QBrush(QColor(255, 230, 230)))  # Rouge clair pour les mi-temps
                self.stats_table.setItem(row, 0, name_item)
                
                # Ajouter les pourcentages
                self.stats_table.setItem(row, 1, QTableWidgetItem(f"{unavail_pct:.2f}%"))
                self.stats_table.setItem(row, 2, QTableWidgetItem(f"{unassigned_pct:.2f}%"))

            # Mettre à jour les en-têtes et ajuster les colonnes
            self.stats_table.setHorizontalHeaderLabels([
                "Nom", "% d'indisponibilité", "% de postes non attribués"
            ])
            self.stats_table.resizeColumnsToContents()

        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour des statistiques: {str(e)}", exc_info=True)
            # Afficher un message d'erreur à l'utilisateur
            QMessageBox.warning(
                self,
                "Erreur de mise à jour",
                "Une erreur est survenue lors de la mise à jour des statistiques."
            )
        
        
        
    def import_multiple_desiderata(self):
        """
        Gère l'import de plusieurs fichiers CSV de desiderata simultanément.
        """
        try:
            # Ouvrir le dialogue de sélection multiple de fichiers
            file_paths, _ = QFileDialog.getOpenFileNames(
                self,
                "Sélectionner les fichiers CSV des desiderata",
                "",
                "Fichiers CSV (*.csv)"
            )
            
            if not file_paths:
                return
                
            # Variables pour le suivi global
            global_stats = {
                'files_processed': 0,
                'files_with_errors': 0,
                'total_rows': 0,
                'successful_imports': 0,
                'people_updated': set()
            }
            
            # Dictionnaire pour stocker tous les desiderata temporaires
            all_temp_desiderata = {}
            all_errors = {}

            # Traiter chaque fichier
            for file_path in file_paths:
                try:
                    self.logger.info(f"Traitement du fichier: {file_path}")
                    
                    # Détecter l'encodage et le séparateur
                    encoding = self.detect_file_encoding(file_path)
                    with open(file_path, 'r', encoding=encoding, errors='replace') as f:
                        sample = f.read(1024)
                        try:
                            dialect = csv.Sniffer().sniff(sample)
                            separator = dialect.delimiter
                        except csv.Error:
                            separator = ';' if ';' in sample else ','
                    
                    # Lecture du fichier
                    file_errors = []
                    temp_desiderata = {}
                    row_count = 0
                    
                    with open(file_path, 'r', encoding=encoding) as csvfile:
                        reader = csv.DictReader(csvfile, delimiter=separator)
                        
                        # Vérifier les colonnes
                        headers = {h.lower().strip() for h in reader.fieldnames} if reader.fieldnames else set()
                        required_columns = {'nom', 'date', 'periode', 'priorite'}
                        
                        if not required_columns.issubset(headers):
                            missing = required_columns - headers
                            raise ValueError(f"Colonnes manquantes: {', '.join(missing)}")
                        
                        # Traiter les lignes
                        for row in reader:
                            row_count += 1
                            try:
                                # Nettoyer les données
                                cleaned_row = {k.lower().strip(): v.strip() for k, v in row.items()}
                                
                                # Validation du nom
                                name = cleaned_row['nom']
                                person = next(
                                    (p for p in self.doctors + self.cats if p.name == name),
                                    None
                                )
                                if not person:
                                    file_errors.append(f"Ligne {row_count}: Personne non trouvée: {name}")
                                    continue
                                
                                # Validation et conversion des données
                                try:
                                    date_val = datetime.strptime(cleaned_row['date'], '%Y-%m-%d').date()
                                    period = int(cleaned_row['periode'])
                                    priority = cleaned_row['priorite'].lower()
                                    
                                    # Validations
                                    if period not in {1, 2, 3}:
                                        raise ValueError("Période invalide")
                                    if priority not in {'primary', 'secondary'}:
                                        raise ValueError("Priorité invalide")
                                    if not (self.planning_start_date <= date_val <= self.planning_end_date):
                                        raise ValueError("Date hors période")
                                        
                                    # Ajouter le desiderata
                                    if name not in temp_desiderata:
                                        temp_desiderata[name] = []
                                    temp_desiderata[name].append((date_val, period, priority))
                                    
                                except ValueError as ve:
                                    file_errors.append(f"Ligne {row_count}: {str(ve)}")
                                    continue
                                    
                            except Exception as e:
                                file_errors.append(f"Ligne {row_count}: Erreur - {str(e)}")
                    
                    # Mettre à jour les statistiques
                    global_stats['files_processed'] += 1
                    global_stats['total_rows'] += row_count
                    
                    if file_errors:
                        global_stats['files_with_errors'] += 1
                        all_errors[file_path] = file_errors
                    
                    # Fusionner les desiderata temporaires
                    for name, desiderata_list in temp_desiderata.items():
                        if name not in all_temp_desiderata:
                            all_temp_desiderata[name] = []
                        all_temp_desiderata[name].extend(desiderata_list)
                        global_stats['people_updated'].add(name)
                    
                except Exception as e:
                    all_errors[file_path] = [f"Erreur de traitement du fichier: {str(e)}"]
                    global_stats['files_with_errors'] += 1

            # Afficher le résumé des erreurs s'il y en a
            if all_errors:
                error_message = "Erreurs détectées:\n\n"
                for file_path, errors in all_errors.items():
                    error_message += f"\nFichier: {os.path.basename(file_path)}\n"
                    error_message += "\n".join(errors) + "\n"
                    
                reply = QMessageBox.warning(
                    self,
                    "Avertissement",
                    f"{error_message}\n\nVoulez-vous continuer avec les données valides?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.No:
                    return

            # Appliquer les desiderata valides
            for name, desiderata_list in all_temp_desiderata.items():
                person = next(p for p in self.doctors + self.cats if p.name == name)
                person.desiderata = [
                    Desiderata(date, date, "Indisponibilité", period, priority)
                    for date, period, priority in desiderata_list
                ]
                global_stats['successful_imports'] += 1

            # Mise à jour de l'interface
            self.update_calendar()
            self.update_stats()
            self.main_window.save_data()

            # Afficher le résumé
            summary = (
                f"Import terminé :\n\n"
                f"Fichiers traités : {global_stats['files_processed']}\n"
                f"Fichiers avec erreurs : {global_stats['files_with_errors']}\n"
                f"Lignes traitées : {global_stats['total_rows']}\n"
                f"Personnes mises à jour : {len(global_stats['people_updated'])}\n"
                f"Imports réussis : {global_stats['successful_imports']}"
            )

            QMessageBox.information(self, "Import terminé", summary)

        except Exception as e:
            self.logger.error(f"Erreur d'importation multiple : {str(e)}", exc_info=True)
            QMessageBox.critical(
                self,
                "Erreur",
                f"Une erreur est survenue lors de l'importation :\n{str(e)}"
            )


class CriticalPeriodsWindow(QDialog):
    def __init__(self, doctors, cats, start_date, end_date, parent=None):
        super().__init__(parent)
        self.doctors = doctors
        self.cats = cats
        self.start_date = start_date
        self.end_date = end_date
        self.cal = France()
        self.init_ui()
        self.update_critical_periods()

    def init_ui(self):
        self.setWindowTitle("Périodes critiques")
        self.setMinimumSize(1200, 600)
        main_layout = QVBoxLayout(self)

        # Layout horizontal pour le calendrier et la liste
        content_layout = QHBoxLayout()
        
        # Création du calendrier des périodes critiques
        self.calendar = CriticalPeriodsCalendar(self.start_date, self.end_date)
        self.calendar.cellClicked.connect(self.update_availability_list)
        content_layout.addWidget(self.calendar, stretch=2)

        # Création de la liste des disponibilités
        self.availability_list = QTableWidget()
        self.availability_list.setColumnCount(2)
        self.availability_list.setHorizontalHeaderLabels(["Médecin", "Statut"])
        self.availability_list.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        content_layout.addWidget(self.availability_list, stretch=1)

        main_layout.addLayout(content_layout)

        # Ajouter la légende
        legend_widget = self.calendar.add_legend(main_layout)
        main_layout.addWidget(legend_widget)

        # Ajuster les proportions
        self.calendar.setMinimumWidth(800)
        self.availability_list.setMinimumWidth(300)

        # Empêcher le redimensionnement des lignes
        self.calendar.verticalHeader().setDefaultSectionSize(25)
        self.availability_list.verticalHeader().setDefaultSectionSize(25)

    def update_critical_periods(self):
        # Calculer le nombre total de personnel (médecins + CAT)
        total_personnel = len(self.doctors) + len(self.cats)
        
        # Calculer le nombre de personnes indisponibles pour chaque période
        unavailability_map = {}
        for current_date in (self.start_date + timedelta(n) for n in range((self.end_date - self.start_date).days + 1)):
            for period in range(1, 4):  # 1: Matin, 2: Après-midi, 3: Soir
                unavailable_count = sum(
                    1 for person in (self.doctors + self.cats)
                    if any(
                        des.start_date <= current_date <= des.end_date and des.period == period
                        for des in person.desiderata
                    )
                )
                unavailability_map[(current_date, period)] = unavailable_count

        # Mettre à jour le calendrier avec les couleurs appropriées
        self.calendar.update_colors(unavailability_map, total_personnel)

    def update_availability_list(self, row, col):
        self.availability_list.setRowCount(0)
        date = self.calendar.get_date_from_cell(row, col - (col % 5))
        
        # Déterminer la période en fonction de la colonne
        if col % 5 == 2:
            period = 1  # Matin
            period_name = "Matin"
        elif col % 5 == 3:
            period = 2  # Après-midi
            period_name = "Après-midi"
        elif col % 5 == 4:
            period = 3  # Soir
            period_name = "Soir"
        else:
            return

        if not date:
            return

        # Ajouter une ligne d'en-tête avec la date et la période
        self.availability_list.insertRow(0)
        
        # Calculer le pourcentage d'indisponibilité
        total_personnel = len(self.doctors) + len(self.cats)
        unavailable_count = sum(
            1 for person in (self.doctors + self.cats)
            if any(des.start_date <= date <= des.end_date and des.period == period for des in person.desiderata)
        )
        percentage = (unavailable_count / total_personnel) * 100 if total_personnel > 0 else 0
        
        header_item = QTableWidgetItem(
            f"{date.strftime('%d/%m/%Y')} - {period_name}\n"
            f"{unavailable_count}/{total_personnel} ({percentage:.0f}% indisponibles)"
        )
        header_item.setBackground(QBrush(QColor(240, 240, 240)))
        header_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        self.availability_list.setSpan(0, 0, 1, 2)
        self.availability_list.setItem(0, 0, header_item)

        # Trier et afficher tous le personnel (médecins et CAT)
        all_personnel = self.doctors + self.cats
        sorted_personnel = sorted(all_personnel, key=lambda p: (
            not any(des.start_date <= date <= des.end_date and des.period == period for des in p.desiderata),
            isinstance(p, CAT),  # Trier les CAT après les médecins
            p.name
        ))

        for person in sorted_personnel:
            row = self.availability_list.rowCount()
            self.availability_list.insertRow(row)
            
            # Nom avec indication du type et des demi-parts pour les médecins
            name_text = person.name
            if isinstance(person, Doctor):
                if person.half_parts == 1:
                    name_text += " (½)"
            else:
                name_text += " (CAT)"
            name_item = QTableWidgetItem(name_text)
            self.availability_list.setItem(row, 0, name_item)
            
            # Statut de disponibilité
            is_available = not any(
                des.start_date <= date <= des.end_date and des.period == period
                for des in person.desiderata
            )
            status_item = QTableWidgetItem("Disponible" if is_available else "Indisponible")
            color = QColor(150, 255, 150) if is_available else QColor(255, 150, 150)
            status_item.setBackground(QBrush(color))
            status_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.availability_list.setItem(row, 1, status_item)

        self.availability_list.resizeColumnsToContents()
            
class CriticalPeriodsCalendar(DesiderataCalendarWidget):
    def __init__(self, start_date, end_date):
        super().__init__(start_date, end_date)
        self.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        # Définition des paliers et leurs couleurs
        self.color_ranges = {
            (0, 0): (QColor(255, 255, 255), "0% - Aucune indisponibilité"),
            (1, 25): (QColor(200, 255, 200), "1-25% - Indisponibilité faible"),
            (26, 50): (QColor(255, 255, 150), "26-50% - Indisponibilité modérée"),
            (51, 75): (QColor(255, 200, 150), "51-75% - Indisponibilité élevée"),
            (75, 99): (QColor(255, 0, 0), "76-99% - Indisponibilité critique"),
            (100, 100): (QColor(0, 0, 0), "100% - Indisponibilité totale")
        }

    def get_color_for_count(self, percentage):
        """
        Détermine la couleur en fonction du pourcentage d'indisponibilité
        """
        # Arrondir le pourcentage pour la comparaison
        percentage = round(percentage)
        
        for (min_val, max_val), (base_color, _) in self.color_ranges.items():
            if min_val <= percentage <= max_val:
                # Créer un dégradé subtil dans le palier
                if min_val != max_val:
                    ratio = (percentage - min_val) / (max_val - min_val)
                    base_h, base_s, base_v, _ = base_color.getHsvF()
                    # Ajuster légèrement la saturation pour le dégradé
                    new_s = min(1.0, base_s + (ratio * 0.2))
                    return QColor.fromHsvF(base_h, new_s, base_v)
                return base_color
                
        return self.color_ranges[(100, 100)][0]  # Noir pour 100%

    def update_colors(self, unavailability_map, total_personnel):
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 5):  # Colonnes M, AM, S
                date = self.get_date_from_cell(row, col - 2)
                if not date:
                    continue

                for i in range(3):  # Pour chaque période (M, AM, S)
                    period = i + 1
                    unavailable_count = unavailability_map.get((date, period), 0)
                    percentage = (unavailable_count / total_personnel) * 100 if total_personnel > 0 else 0
                    
                    item = self.item(row, col + i)
                    if item:
                        color = self.get_color_for_count(percentage)
                        item.setBackground(QBrush(color))
                        # Ajouter le pourcentage dans la cellule
                        item.setText(f"{percentage:.0f}%")
                        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

    def add_legend(self, parent_layout):
        legend_widget = QWidget()
        legend_layout = QHBoxLayout(legend_widget)
        legend_layout.setSpacing(10)
        legend_layout.setContentsMargins(10, 5, 10, 5)

        for (min_val, max_val), (color, description) in self.color_ranges.items():
            # Créer un carré de couleur
            color_label = QLabel()
            color_label.setFixedSize(20, 20)
            color_label.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            
            # Texte de description
            text_label = QLabel(description)
            text_label.setMinimumWidth(150)  # Assurer une largeur minimale pour la lisibilité
            
            # Conteneur pour chaque paire couleur-texte
            container = QWidget()
            container_layout = QHBoxLayout(container)
            container_layout.setSpacing(5)
            container_layout.addWidget(color_label)
            container_layout.addWidget(text_label)
            
            legend_layout.addWidget(container)

        return legend_widget

    def mousePressEvent(self, event):
        # Empêcher la modification des couleurs lors du clic
        item = self.itemAt(event.pos())
        if item:
            self.cellClicked.emit(item.row(), item.column())
            
            
            
            
    

# .vscode/settings.json

{
    "CodeGPT.apiKey": "CodeGPT Plus Beta",
    "CodeGPT.Autocomplete.enabled": false,
    "CodeGPT.Autocomplete.maxTokens": 240
}

