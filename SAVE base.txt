# ExportsTxt.py

import os

def combine_files(project_dir, output_file):
    excluded_items = {'appdata', '.DS_Store', 'exportsTxt.py', 'test.py','utils', '__pycache__','venv', 'planningt.txt', 'SAVE base.txt', 'SAV 2.txt','SAV3.txt'}
    
    with open(output_file, "w", encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(project_dir):
            # Remove excluded directories
            dirs[:] = [d for d in dirs if d not in excluded_items]
            
            for file in files:
                if file in excluded_items:
                    continue
                
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding='utf-8') as infile:
                        relative_path = os.path.relpath(file_path, project_dir)
                        outfile.write(f"# {relative_path}\n\n")
                        outfile.write(infile.read())
                        outfile.write("\n\n")
                except UnicodeDecodeError:
                    print(f"Skipping file due to encoding issues: {file_path}")

project_directory = "/Users/arkane/Documents/Planning"
output_file_path = "/Users/arkane/Documents/Planning/planningt.txt"
combine_files(project_directory, output_file_path)


# app_data.pkl

# main.py

# main.py

import sys
from PyQt6.QtWidgets import QApplication
from gui.main_window import MainWindow
from core.models import Doctor, CAT, create_default_post_configuration
from core.data_persistence import DataPersistence
import logging
import random

logging.basicConfig(level=logging.DEBUG, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    filename='app.log',
                    filemode='w')
def main():
    app = QApplication(sys.argv)

    data_persistence = DataPersistence()
    doctors, cats, post_configuration = data_persistence.load_data()
    
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    # Vérification du type de données
    print(f"Type of doctors: {type(doctors)}")
    if doctors:
        print(f"Type of first doctor: {type(doctors[0])}")

    # Si aucune donnée n'a été chargée, utilisez les données par défaut
    if not doctors and not cats:
        doctors = [
            Doctor("Dr. Smith", 2),
            Doctor("Dr. Johnson", 1),
            Doctor("Dr. Williams", 2),
        ]
        cats = [
            CAT("CAT 1"),
            CAT("CAT 2"),
        ]

    if post_configuration is None:
        post_configuration = create_default_post_configuration()

    window = MainWindow(doctors, cats, post_configuration)
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

# core/data_persistence.py

# core/data_persistence.py
import logging
import datetime
import pickle
import os
from core.models import Doctor, CAT, DailyPostConfiguration, PostConfig, create_default_post_configuration, Desiderata

logger = logging.getLogger(__name__)

class DataPersistence:
    def __init__(self, filename='app_data.pkl'):
        self.filename = filename

    def save_data(self, doctors, cats, post_configuration):
        logger.info("Starting save_data process")
        data = {
            'version': 1,
            'doctors': [{
                'name': d.name,
                'half_parts': d.half_parts,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period
                } for des in d.desiderata]
            } for d in doctors],
            'cats': [{
                'name': c.name,
                'desiderata': [{
                    'start_date': des.start_date.isoformat(),
                    'end_date': des.end_date.isoformat(),
                    'type': des.type,
                    'period': des.period
                } for des in c.desiderata]
            } for c in cats],
            'post_configuration': {
                'weekday': self._serialize_post_config(post_configuration.weekday),
                'saturday': self._serialize_post_config(post_configuration.saturday),
                'sunday_holiday': self._serialize_post_config(post_configuration.sunday_holiday),
                'cat_weekday': self._serialize_post_config(post_configuration.cat_weekday),
                'cat_saturday': self._serialize_post_config(post_configuration.cat_saturday),
                'cat_sunday_holiday': self._serialize_post_config(post_configuration.cat_sunday_holiday)
            }
        }
        logger.debug(f"Data to be saved: {data}")
        with open(self.filename, 'wb') as file:
            pickle.dump(data, file)
        logger.info("Data saved successfully")

    def load_data(self):
        logger.info("Starting load_data process")
        if os.path.exists(self.filename):
            with open(self.filename, 'rb') as file:
                data = pickle.load(file)
            
            logger.debug(f"Raw loaded data: {data}")
            
            data = self.migrate_data(data)
            
            doctors = [Doctor(d['name'], d['half_parts'], [
                Desiderata(
                    datetime.date.fromisoformat(des['start_date']),
                    datetime.date.fromisoformat(des['end_date']),
                    des['type'],
                    des['period']
                )
                for des in d.get('desiderata', [])
            ]) for d in data.get('doctors', [])]
            
            cats = [CAT(c['name'], [
                Desiderata(
                    datetime.date.fromisoformat(des['start_date']),
                    datetime.date.fromisoformat(des['end_date']),
                    des['type'],
                    des['period']
                )
                for des in c.get('desiderata', [])
            ]) for c in data.get('cats', [])]
            
            logger.debug(f"Loaded doctors: {doctors}")
            logger.debug(f"Loaded cats: {cats}")
            
            post_config_data = data.get('post_configuration', {})
            post_configuration = DailyPostConfiguration()
            
            if isinstance(post_config_data, dict):
                post_configuration.weekday = self._deserialize_post_config(post_config_data.get('weekday', {}))
                post_configuration.saturday = self._deserialize_post_config(post_config_data.get('saturday', {}))
                post_configuration.sunday_holiday = self._deserialize_post_config(post_config_data.get('sunday_holiday', {}))
                post_configuration.cat_weekday = self._deserialize_post_config(post_config_data.get('cat_weekday', {}))
                post_configuration.cat_saturday = self._deserialize_post_config(post_config_data.get('cat_saturday', {}))
                post_configuration.cat_sunday_holiday = self._deserialize_post_config(post_config_data.get('cat_sunday_holiday', {}))
            
            logger.info("Data loaded successfully")
            return doctors, cats, post_configuration
        logger.warning("No data file found, returning default values")
        return [], [], create_default_post_configuration()

    def parse_date(self, date_input):
        if isinstance(date_input, datetime.date):
            return date_input
        elif isinstance(date_input, str):
            try:
                return datetime.date.fromisoformat(date_input)
            except ValueError:
                try:
                    return datetime.date.fromtimestamp(float(date_input))
                except ValueError:
                    print(f"Impossible de parser la date: {date_input}. Utilisation de la date actuelle.")
                    return datetime.date.today()
        else:
            print(f"Type de date inattendu: {type(date_input)}. Utilisation de la date actuelle.")
            return datetime.date.today()
            
    def migrate_data(self, data):
        version = data.get('version', 0)
        if version < 1:
            # Migration vers la version 1
            for doctor in data.get('doctors', []):
                for des in doctor.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            for cat in data.get('cats', []):
                for des in cat.get('desiderata', []):
                    if 'period' not in des:
                        des['period'] = 1  # Valeur par défaut
            data['version'] = 1
        return data
    
    

    def _serialize_post_config(self, config):
        return {post_type: post_config.total for post_type, post_config in config.items()}

    def _deserialize_post_config(self, data):
        return {post_type: PostConfig(total=total) for post_type, total in data.items()}

    def debug_dates(self, doctors, cats):
        print("Debugging dates:")
        for doctor in doctors:
            for des in doctor.desiderata:
                print(f"{doctor.name}: {des}")
        for cat in cats:
            for des in cat.desiderata:
                print(f"{cat.name}: {des}")

# core/models.py


# core/models.py
from dataclasses import dataclass, field
from datetime import date, datetime, time
from enum import Enum
from typing import List, Dict, Optional, TYPE_CHECKING
import logging
import datetime

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from .models import TimeSlot

ALL_POST_TYPES = [
    "ML", "MM", "CM", "CA", "HM", "HA", "CS", "HS", "SS", "RS", "NC", "NM", "NL",
    "CT", "AL", "MC", "AC", "SA", "RA", "SM", "RM", "NA"
]

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

class DesiderataPeriod(Enum):
    MORNING = 1
    AFTERNOON = 2
    NIGHT = 3



class Desiderata:
    def __init__(self, start_date, end_date, type: str, period: int):
        logger.info(f"Creating new Desiderata with start_date: {start_date}, end_date: {end_date}, type: {type}, period: {period}")
        self.start_date = self._ensure_date(start_date)
        self.end_date = self._ensure_date(end_date)
        self.type = type
        self.period = period
        logger.debug(f"Desiderata created: {self}")

    @staticmethod
    def _ensure_date(date_input):
        logger.debug(f"Ensuring date for input: {date_input}")
        if isinstance(date_input, datetime.date):
            logger.debug(f"Input is already a date: {date_input}")
            return date_input
        elif isinstance(date_input, str):
            try:
                date = datetime.date.fromisoformat(date_input)
                logger.debug(f"Converted string to date: {date}")
                return date
            except ValueError:
                try:
                    date = datetime.datetime.strptime(date_input, "%Y-%m-%d").date()
                    logger.debug(f"Converted string to date using strptime: {date}")
                    return date
                except ValueError:
                    logger.error(f"Invalid date: {date_input}. Using current date.")
                    return datetime.date.today()
        else:
            logger.error(f"Unexpected date type: {type(date_input)}. Using current date.")
            return datetime.date.today()

    def __repr__(self):
        return f"Desiderata(start_date={self.start_date}, end_date={self.end_date}, type='{self.type}', period={self.period})"
    def overlaps_with_slot(self, slot: 'TimeSlot') -> bool:
        if self.start_date <= slot.start_time.date() <= self.end_date:
            if slot.abbreviation == "CT":
                # Pour CT, vérifier si le desiderata couvre soit le matin soit l'après-midi
                return self.period in [1, 2]  # 1 pour matin, 2 pour après-midi
            else:
                slot_period = self.get_slot_period(slot)
                return self.period == slot_period
        return False

    @staticmethod
    def get_slot_period(slot: 'TimeSlot') -> int:
        if slot.abbreviation == "CT":
            return 4  # Période spéciale pour CT
        start_hour = slot.start_time.hour
        if 7 <= start_hour < 13:
            return 1  # Matin
        elif 13 <= start_hour < 18:
            return 2  # Après-midi
        else:
            return 3  # Soir/Nuit
        
@dataclass
class Doctor:
    name: str
    half_parts: int
    desiderata: List[Desiderata] = field(default_factory=list)
    night_shifts: int = 0
    min_nlw: int = 0
    max_nlw: int = 0
    nm_shifts: Dict[str, int] = field(default_factory=lambda: {'NMs': 0, 'NMd': 0, 'total': 0})
    combo_counts: Dict[str, int] = field(default_factory=lambda: {
        combo: 0 for combo in [
            "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA",
            "CMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS", "CMAC", "CMAL", "HMAL", "HMAC", "RMMAL", "RMAC", "SMAL", "SMAC"
        ]
    })
    group_counts: Dict[str, int] = field(default_factory=lambda: {
        group: 0 for group in ["CmS", "CmD", "CaS", "CaD", "CsSD", "VmS", "VmD", "VaSD"]
    })


    def can_work_shift(self, date: date, shift: 'TimeSlot') -> bool:
        if shift.abbreviation == "CT":
            # Pour CT, vérifier s'il y a des desiderata pour le matin ou l'après-midi
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.period in [1, 2]:  # Matin ou après-midi
                        return False
            return True
        else:
            # Pour les autres types de shifts, utiliser la logique existante
            for desiderata in self.desiderata:
                if desiderata.start_date <= date <= desiderata.end_date:
                    if desiderata.overlaps_with_slot(shift):
                        return False
            return True
    
@dataclass
class CAT:
    name: str
    posts: Dict[str, int] = field(default_factory=lambda: {post_type: 0 for post_type in ALL_POST_TYPES})
    desiderata: List[Desiderata] = field(default_factory=list)

class SlotType(Enum):
    CONSULTATION = "Consultation"
    VISITE = "Visite"

class Site(Enum):
    CENON = "Cenon"
    BEYCHAC_ET_CAILLAU = "Beychac et Caillau"
    ST_ANDRE_DE_CUBZAC = "St André de Cubzac"
    CREON = "Créon"
    VISITES = "Visites"

@dataclass
class TimeSlot:
    start_time: datetime
    end_time: datetime
    site: str
    slot_type: str
    abbreviation: str
    assignee: str = None

@dataclass
class DayPlanning:
    date: date
    slots: List[TimeSlot] = field(default_factory=list)
    is_weekend: bool = False
    is_holiday_or_bridge: bool = False

@dataclass
class Planning:
    def __init__(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.days: List[DayPlanning] = []
        self.pre_analysis_results = None

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def set_pre_analysis_results(self, results):
        self.pre_analysis_results = results

    def get_day(self, date: date) -> Optional[DayPlanning]:
        return next((day for day in self.days if day.date == date), None)
    
@dataclass
class PostConfig:
    total: int = 0

@dataclass
class CATPostConfiguration:
    weekday: Dict[str, int] = field(default_factory=dict)
    saturday: Dict[str, int] = field(default_factory=dict)
    sunday_holiday: Dict[str, int] = field(default_factory=dict)

@dataclass
class DailyPostConfiguration:
    weekday: Dict[str, PostConfig] = field(default_factory=dict)
    saturday: Dict[str, PostConfig] = field(default_factory=dict)
    sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_weekday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_saturday: Dict[str, PostConfig] = field(default_factory=dict)
    cat_sunday_holiday: Dict[str, PostConfig] = field(default_factory=dict)

    def get_config_for_day_type(self, day_type: str) -> Dict[str, PostConfig]:
        if day_type == "weekday":
            return self.weekday
        elif day_type == "saturday":
            return self.saturday
        elif day_type == "sunday_holiday":
            return self.sunday_holiday
        else:
            raise ValueError(f"Invalid day type: {day_type}")
        
def create_default_post_configuration():
    weekday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RS": PostConfig(total=1),
        "NC": PostConfig(total=1),
        "CT": PostConfig(total=1)
    }

    saturday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "AL": PostConfig(total=2),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "HM": PostConfig(total=1),
        "HA": PostConfig(total=1),
        "HS": PostConfig(total=1),
        "SM": PostConfig(total=1),
        "SA": PostConfig(total=1),
        "RM": PostConfig(total=1),
        "RA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RS": PostConfig(total=1),
        "NA": PostConfig(total=1),
        "MC": PostConfig(total=1),
        "AC": PostConfig(total=1)
    }

    sunday_holiday_config = {
        "NL": PostConfig(total=2),
        "NM": PostConfig(total=2),
        "ML": PostConfig(total=2),
        "AL": PostConfig(total=2),
        "MM": PostConfig(total=1),
        "CM": PostConfig(total=1),
        "CA": PostConfig(total=2),
        "CS": PostConfig(total=1),
        "SM": PostConfig(total=1),
        "SA": PostConfig(total=1),
        "RM": PostConfig(total=1),
        "RA": PostConfig(total=1),
        "SS": PostConfig(total=1),
        "RS": PostConfig(total=1),
        "NA": PostConfig(total=1),
        "MC": PostConfig(total=1),
        "AC": PostConfig(total=1)
    }

    # Configuration par défaut pour les CAT
    cat_weekday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NC": PostConfig(total=1)
    }

    cat_saturday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    cat_sunday_holiday_config = {
        "NL": PostConfig(total=1),
        "NM": PostConfig(total=1),
        "ML": PostConfig(total=1),
        "AL": PostConfig(total=1),
        "CA": PostConfig(total=1),
        "CS": PostConfig(total=1),
        "NA": PostConfig(total=1)
    }

    return DailyPostConfiguration(
        weekday=weekday_config,
        saturday=saturday_config,
        sunday_holiday=sunday_holiday_config,
        cat_weekday=cat_weekday_config,
        cat_saturday=cat_saturday_config,
        cat_sunday_holiday=cat_sunday_holiday_config
    )



class PostManager:
    """Classe pour gérer les différents types de postes et leurs horaires en fonction du jour de la semaine."""
    
    def __init__(self):
        # Dictionnaire contenant les types de poste pour la semaine
        self.weekday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "MM": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RS": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Créon"},
            "NC": {"start_time": time(20, 0), "end_time": time(23, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
        }

        # Dictionnaire pour les postes du samedi
        self.saturday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

        # Dictionnaire pour les postes du dimanche et jours fériés
        self.sunday_holiday_posts = {
            "ML": {"start_time": time(7, 0), "end_time": time(12, 59), "site": "Visites"},
            "AL": {"start_time": time(13, 0), "end_time": time(19, 59), "site": "Visites"},
            "MC": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Visites"},
            "AC": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Visites"},
            "NA": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Visites"},
            "NM": {"start_time": time(20, 0), "end_time": time(1, 59), "site": "Visites"},
            "NL": {"start_time": time(20, 0), "end_time": time(6, 59), "site": "Visites"},
            "CM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Cenon"},
            "CA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Cenon"},
            "CS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Cenon"},
            "HM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Beychac et Caillau"},
            "HA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Beychac et Caillau"},
            "HS": {"start_time": time(18, 0), "end_time": time(22, 59), "site": "Beychac et Caillau"},
            "SM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "St André de Cubzac"},
            "SA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "St André de Cubzac"},
            "SS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "St André de Cubzac"},
            "RM": {"start_time": time(9, 0), "end_time": time(12, 59), "site": "Créon"},
            "RA": {"start_time": time(13, 0), "end_time": time(17, 59), "site": "Créon"},
            "RS": {"start_time": time(18, 0), "end_time": time(23, 59), "site": "Créon"},
        }

    def get_post_details(self, post_type, day_type):
        """Retourne les détails d'un poste spécifique en fonction du jour (weekday, samedi, dimanche)."""
        if day_type == "weekday":
            return self.weekday_posts.get(post_type, None)
        elif day_type == "saturday":
            return self.saturday_posts.get(post_type, None)
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts.get(post_type, None)

    def get_posts_for_day(self, day_type):
        """Retourne tous les postes disponibles pour un jour donné (semaine, samedi, ou dimanche/jour férié)."""
        if day_type == "weekday":
            return self.weekday_posts
        elif day_type == "saturday":
            return self.saturday_posts
        elif day_type == "sunday_holiday":
            return self.sunday_holiday_posts


# core/pre_analyzer.py

# core/pre_analyzer.py

from datetime import date, timedelta
from typing import List, Dict
from core.models import Doctor, CAT, DailyPostConfiguration, Desiderata
from workalendar.europe import France
import logging
import math

class PlanningPreAnalyzer:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration: DailyPostConfiguration, start_date: date = None, end_date: date = None):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.start_date = start_date
        self.end_date = end_date
        self.total_days = self.calculate_total_days()
        self.cal = France()
        self.logger = logging.getLogger(__name__)

    def calculate_total_days(self):
        if self.start_date and self.end_date:
            return (self.end_date - self.start_date).days + 1
        return 0

    def set_date_range(self, start_date: date, end_date: date):
        self.start_date = start_date
        self.end_date = end_date
        self.total_days = self.calculate_total_days()

    def analyze(self) -> Dict:
        if not self.start_date or not self.end_date or self.start_date > self.end_date:
            raise ValueError("Invalid date range. Please set valid start and end dates.")

        posts_analysis = self.analyze_posts()
        return {
            "personnel": self.analyze_personnel(),
            "posts": posts_analysis,
            "unavailability": self.analyze_unavailability(),
            "ideal_distribution": self.analyze_ideal_distribution(posts_analysis),
            "ideal_combinations": self.analyze_ideal_combinations(posts_analysis)
        }

    def analyze_personnel(self) -> Dict:
        total_doctors = len(self.doctors)
        doctors_one_half_part = sum(1 for doctor in self.doctors if doctor.half_parts == 1)
        doctors_two_half_parts = sum(1 for doctor in self.doctors if doctor.half_parts == 2)
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        total_cats = len(self.cats)

        self.logger.info(f"Personnel analysis: {total_doctors} doctors ({doctors_one_half_part} with 1 half-part, {doctors_two_half_parts} with 2 half-parts), {total_half_parts} total half-parts, {total_cats} CATs")

        return {
            "total_doctors": total_doctors,
            "doctors_one_half_part": doctors_one_half_part,
            "doctors_two_half_parts": doctors_two_half_parts,
            "total_half_parts": total_half_parts,
            "total_cats": total_cats
        }

 
    def analyze_posts(self) -> Dict:
        total_posts = {
            "weekday": {post_type: 0 for post_type in self.post_configuration.weekday},
            "saturday": {post_type: 0 for post_type in self.post_configuration.saturday},
            "sunday_holiday": {post_type: 0 for post_type in self.post_configuration.sunday_holiday}
        }
        friday_nl_count = 0
        weekend_groups = {
            "CmS": 0, "CmD": 0, "CaSD": 0, "CsSD": 0,
            "VmS": 0, "VmD": 0, "VaSD": 0, "NAMw": 0, "NLw": 0,
        }
        weekday_groups = {
            "XM": 0, "XA": 0, "XS": 0, "MM": 0, "NM": 0, "NC": 0, "ML": 0
        }

        current_date = self.start_date
        while current_date <= self.end_date:
            day_type = self.get_day_type(current_date)
            config = self.post_configuration.get_config_for_day_type(day_type)
            
            for post_type, post_config in config.items():
                total_posts[day_type][post_type] += post_config.total

            if day_type == "weekday":
                weekday_groups["XM"] += config.get("CM", 0).total + config.get("HM", 0).total
                weekday_groups["XA"] += config.get("CA", 0).total + config.get("HA", 0).total
                weekday_groups["XS"] += config.get("CS", 0).total + config.get("HS", 0).total + config.get("RS", 0).total + config.get("SS", 0).total
                weekday_groups["MM"] += config.get("MM", 0).total
                weekday_groups["NM"] += config.get("NM", 0).total
                weekday_groups["NC"] += config.get("NC", 0).total
                weekday_groups["ML"] += config.get("ML", 0).total

            elif day_type == "saturday":
                weekend_groups["CmS"] += config.get("CM", 0).total + config.get("HM", 0).total
                weekend_groups["CaSD"] += config.get("CA", 0).total + config.get("HA", 0).total + config.get("RA", 0).total + config.get("SA", 0).total
                weekend_groups["CsSD"] += config.get("CS", 0).total + config.get("HS", 0).total + config.get("RS", 0).total + config.get("SS", 0).total
                weekend_groups["VmS"] += config.get("ML", 0).total
                weekend_groups["VaSD"] += config.get("AL", 0).total + config.get("AC", 0).total
                weekend_groups["NAMw"] += config.get("NM", 0).total + config.get("NA", 0).total
                weekend_groups["NLw"] += config.get("NL", 0).total

            elif day_type == "sunday_holiday":
                weekend_groups["CmD"] += config.get("CM", 0).total + config.get("HM", 0).total + config.get("SM", 0).total + config.get("RM", 0).total
                weekend_groups["CaSD"] += config.get("CA", 0).total + config.get("HA", 0).total + config.get("RA", 0).total + config.get("SA", 0).total
                weekend_groups["CsSD"] += config.get("CS", 0).total + config.get("HS", 0).total + config.get("RS", 0).total + config.get("SS", 0).total
                weekend_groups["VmD"] += config.get("ML", 0).total + config.get("MC", 0).total
                weekend_groups["VaSD"] += config.get("AL", 0).total + config.get("AC", 0).total
                weekend_groups["NAMw"] += config.get("NM", 0).total + config.get("NA", 0).total
                weekend_groups["NLw"] += config.get("NL", 0).total

            if current_date.weekday() == 4:  # Friday
                friday_nl_count += config.get("NL", 0).total
                weekend_groups["NLw"] += config.get("NL", 0).total
            
            current_date += timedelta(days=1)

        self.logger.info(f"Posts analysis: {total_posts}")
        self.logger.info(f"Friday NL count: {friday_nl_count}")
        self.logger.info(f"Weekend groups analysis: {weekend_groups}")
        self.logger.info(f"Weekday groups analysis: {weekday_groups}")

        return {
            "total_posts": total_posts,
            "friday_nl_count": friday_nl_count,
            "weekend_groups": weekend_groups,
            "weekday_groups": weekday_groups
        }
        
    def get_day_type(self, date: date) -> str:
        if date.weekday() == 5:
            return "saturday"
        elif date.weekday() == 6 or self.cal.is_holiday(date):
            return "sunday_holiday"
        else:
            return "weekday"

    def analyze_unavailability(self) -> Dict:
        unavailability = {}
        daily_availability = {(self.start_date + timedelta(days=i)): 0 for i in range((self.end_date - self.start_date).days + 1)}
        total_days = (self.end_date - self.start_date).days + 1
        total_periods = total_days * 3  # 3 périodes par jour

        for doctor in self.doctors:
            unavailable_periods = 0
            for desiderata in doctor.desiderata:
                if self.overlaps(desiderata, self.start_date, self.end_date):
                    start = max(desiderata.start_date, self.start_date)
                    end = min(desiderata.end_date, self.end_date)
                    for day in (start + timedelta(n) for n in range((end - start).days + 1)):
                        daily_availability[day] += 1
                    days = (end - start).days + 1
                    unavailable_periods += days * desiderata.period

            unavailability_percentage = (unavailable_periods / total_periods) * 100
            unavailability[doctor.name] = unavailability_percentage

        least_available_days = sorted(daily_availability.items(), key=lambda x: x[1], reverse=True)[:5]

        self.logger.info(f"Unavailability analysis: {unavailability}")
        self.logger.info(f"Least available days: {least_available_days}")
        return {
            "doctor_unavailability": unavailability,
            "least_available_days": least_available_days
        }
    
    def overlaps(self, desiderata: Desiderata, start: date, end: date) -> bool:
        return max(desiderata.start_date, start) <= min(desiderata.end_date, end)

    import math

    def analyze_ideal_distribution(self, posts_analysis: Dict) -> Dict:
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        ideal_distribution = {}

        for doctor in self.doctors:
            doctor_ratio = doctor.half_parts / total_half_parts
            ideal_distribution[doctor.name] = {
                "weekend_posts": {},
                "weekend_groups": {},
                "weekday_posts": {},
                "weekday_groups": {}
            }

            # 1) Nombre idéal de chaque type de poste du week-end
            for day_type in ["saturday", "sunday_holiday"]:
                for post_type, count in posts_analysis["total_posts"][day_type].items():
                    ideal = count * doctor_ratio
                    ideal_distribution[doctor.name]["weekend_posts"][post_type] = self.round_ideal(ideal, doctor.half_parts)

            # 2) Nombre idéal de chaque type de poste de la semaine
            for post_type, count in posts_analysis["total_posts"]["weekday"].items():
                ideal = count * doctor_ratio
                ideal_distribution[doctor.name]["weekday_posts"][post_type] = self.round_ideal(ideal, doctor.half_parts)

            # 3) Nombre idéal de chaque groupe de poste du week-end
            for group, count in posts_analysis["weekend_groups"].items():
                ideal = count * doctor_ratio
                ideal_distribution[doctor.name]["weekend_groups"][group] = self.round_ideal(ideal, doctor.half_parts)

            # 4) Nombre idéal de chaque groupe de poste de la semaine
            for group, count in posts_analysis["weekday_groups"].items():
                ideal = count * doctor_ratio
                ideal_distribution[doctor.name]["weekday_groups"][group] = self.round_ideal(ideal, doctor.half_parts)

        self.logger.info(f"Ideal distribution analysis: {ideal_distribution}")
        return ideal_distribution

    def round_ideal(self, value: float, half_parts: int) -> Dict[str, float]:
        if half_parts == 2:
            return {
                "min": math.floor(value),
                "max": math.ceil(value)
            }
        else:  # For half-time doctors
            full_time_value = value * 2  # Calculate what it would be for a full-time doctor
            rounded_full_time = round(full_time_value * 2) / 2  # Round to nearest 0.5
            half_time_value = rounded_full_time / 2
            return {
                "min": max(0, math.floor(half_time_value)),
                "max": math.ceil(half_time_value)
            }

        
    
    def analyze_ideal_combinations(self, posts_analysis: Dict) -> Dict:
        combinations = [
            "MLCA", "MLHA", "MLSA", "MLRA", "MCCA", "MCHA", "MCRA", "MCSA",
            "CMCA", "CACS", "HMHA", "HAHS", "SMSA", "SASS", "RMRA", "RARS",
            "CMAC", "CMAL", "CMAC", "CMAL", "HMAL", "HMAC", "RMMAL", "RMAC", "SMAL", "SMAC"
        ]
        
        total_half_parts = sum(doctor.half_parts for doctor in self.doctors)
        ideal_combinations = {doctor.name: {} for doctor in self.doctors}

        for combo in combinations:
            first_post, second_post = combo[:2], combo[2:]
            total_possible = min(
                posts_analysis["total_posts"]["weekday"].get(first_post, 0) +
                posts_analysis["total_posts"]["saturday"].get(first_post, 0) +
                posts_analysis["total_posts"]["sunday_holiday"].get(first_post, 0),
                posts_analysis["total_posts"]["weekday"].get(second_post, 0) +
                posts_analysis["total_posts"]["saturday"].get(second_post, 0) +
                posts_analysis["total_posts"]["sunday_holiday"].get(second_post, 0)
            )

            for doctor in self.doctors:
                doctor_ratio = doctor.half_parts / total_half_parts
                ideal_count = round(total_possible * doctor_ratio, 2)
                ideal_combinations[doctor.name][combo] = ideal_count

        self.logger.info(f"Ideal combinations analysis: {ideal_combinations}")
        return ideal_combinations

    def run_test_analysis(self):
        self.logger.info("Running test analysis...")
        analysis_result = self.analyze()
        self.logger.info("Test analysis result:")
        self.logger.info(f"Personnel: {analysis_result['personnel']}")
        self.logger.info(f"Posts: {analysis_result['posts']}")
        self.logger.info(f"Unavailability: {analysis_result['unavailability']}")
        self.logger.info(f"Ideal distribution: {analysis_result['ideal_distribution']}")
        return analysis_result


# core/__init__.py



# core/planning_generator.py


# core/planning_generator.py

from datetime import date, datetime, time, timedelta
from typing import List, Dict, Optional
from workalendar.europe import France
from core.models import Doctor, CAT, TimeSlot, Planning, DayPlanning, Site, SlotType, DailyPostConfiguration, ALL_POST_TYPES, PostManager, PostConfig
import random
import logging
import math
from core.pre_analyzer import PlanningPreAnalyzer
from core.constraints import PlanningConstraints
from itertools import cycle


class PlanningGenerator:
    def __init__(self, doctors: List[Doctor], cats: List[CAT], post_configuration: DailyPostConfiguration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.post_manager = PostManager()
        self.cal = France()
        self.pre_analyzer = PlanningPreAnalyzer(doctors, cats, post_configuration, None, None)
        self.constraints = PlanningConstraints()
        self.logger = logging.getLogger(__name__)
        self.weekend_night_posts = ["NL", "NM"]

    def generate_planning(self, start_date: date, end_date: date) -> Optional[Planning]:
        self.pre_analyzer.set_date_range(start_date, end_date)
        pre_analysis_results = self.pre_analyzer.analyze()
        
        planning = Planning(start_date, end_date)
        self.initialize_planning(planning)
        
        self.distribute_weekend_nl(planning, pre_analysis_results)
        self.distribute_weekend_nm(planning, pre_analysis_results)
        self.distribute_weekend_posts(planning, pre_analysis_results)
        
        # Distribution des postes restants aux CAT
        self.distribute_remaining_posts_to_cats(planning, pre_analysis_results)
        
        # Nouvelle étape : post-traitement pour les postes de weekend non attribués
        self.post_process_weekend_distribution(planning, pre_analysis_results)
        
        planning.set_pre_analysis_results(pre_analysis_results)
        
        return planning

    def initialize_planning(self, planning: Planning):
        current_date = planning.start_date
        while current_date <= planning.end_date:
            day_planning = self.generate_daily_slots(current_date)
            planning.days.append(day_planning)
            current_date += timedelta(days=1)

    def generate_daily_slots(self, date: date) -> DayPlanning:
        is_weekend = date.weekday() >= 5
        is_holiday_or_bridge = self.cal.is_holiday(date) or self.is_bridge_day(date)

        if is_weekend or is_holiday_or_bridge:
            config = self.post_configuration.sunday_holiday if date.weekday() == 6 or is_holiday_or_bridge else self.post_configuration.saturday
        else:
            config = self.post_configuration.weekday

        slots = []
        day_type = "sunday_holiday" if date.weekday() == 6 or is_holiday_or_bridge else "saturday" if date.weekday() == 5 else "weekday"
        
        for post_type, post_config in config.items():
            post_details = self.post_manager.get_post_details(post_type, day_type)
            if post_details:
                for _ in range(post_config.total):
                    slot = TimeSlot(
                        start_time=datetime.combine(date, post_details['start_time']),
                        end_time=datetime.combine(date, post_details['end_time']),
                        site=post_details['site'],
                        slot_type="Consultation" if post_type[0] in ['C', 'H', 'S', 'R'] else "Visite",
                        abbreviation=post_type
                    )
                    slots.append(slot)

        return DayPlanning(date=date, slots=slots, is_weekend=is_weekend, is_holiday_or_bridge=is_holiday_or_bridge)

    def is_bridge_day(self, day: date) -> bool:
        if day.weekday() == 4 and self.cal.is_holiday(day + timedelta(days=1)):
            return True
        if day.weekday() == 0 and self.cal.is_holiday(day - timedelta(days=1)):
            return True
        return False


    def distribute_weekend_nl(self, planning: Planning, pre_analysis_results: Dict):
        ideal_distribution = pre_analysis_results.get('ideal_distribution', {})
        
        weekend_days = [day for day in planning.days if day.is_weekend or day.is_holiday_or_bridge or day.date.weekday() == 4]
        
        for doctor in self.doctors:
            ideal_nlw = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get('NLw', {})
            doctor.min_nlw = math.floor(ideal_nlw.get('min', 0))
            doctor.max_nlw = math.ceil(ideal_nlw.get('max', 0)) + 1
            doctor.night_shifts = {'NLv': 0, 'NLs': 0, 'NLd': 0, 'total': 0}

        # Trier les jours pour s'assurer que les vendredis sont traités en premier
        weekend_days.sort(key=lambda day: (day.date.weekday() != 4, day.date))

        for day in weekend_days:
            nl_slots = [slot for slot in day.slots if slot.abbreviation == 'NL']
            day_type = self.get_day_type(day.date)
            
            for slot in nl_slots:
                eligible_doctors = self.get_eligible_doctors(day, slot, planning)
                if eligible_doctors:
                    chosen_doctor = self.choose_doctor(eligible_doctors, day_type)
                    slot.assignee = chosen_doctor.name
                    chosen_doctor.night_shifts[day_type] += 1
                    chosen_doctor.night_shifts['total'] += 1
                    self.logger.info(f"Assigned NL on {day.date} ({day_type}) to {chosen_doctor.name} "
                                     f"(Total: {chosen_doctor.night_shifts['total']}, "
                                     f"NLv: {chosen_doctor.night_shifts['NLv']}, "
                                     f"NLs: {chosen_doctor.night_shifts['NLs']}, "
                                     f"NLd: {chosen_doctor.night_shifts['NLd']}, "
                                     f"Half-parts: {chosen_doctor.half_parts})")
                else:
                    self.logger.warning(f"No eligible doctor for NL on {day.date}")

        self.log_nl_distribution()

    def get_day_type(self, date):
        if date.weekday() == 4:
            return 'NLv'
        elif date.weekday() == 5:
            return 'NLs'
        else:
            return 'NLd'

    def get_eligible_doctors(self, day, slot, planning):
        return [d for d in self.doctors 
                if d.night_shifts['total'] < d.max_nlw 
                and self.constraints.can_assign_to_assignee(d, day.date, slot, planning)]

    def choose_doctor(self, eligible_doctors, day_type):
        random.shuffle(eligible_doctors)
        return min(eligible_doctors, key=lambda d: (
            -int(d.night_shifts['total'] < d.min_nlw),  # Priorité 1: Médecins sous leur minimum total
            d.night_shifts[day_type],                   # Priorité 2: Médecins avec moins de gardes de ce type
            -d.half_parts,                              # Priorité 3: Médecins avec plus de demi-parts
            d.night_shifts['total']                     # Priorité 4: Médecins avec moins de gardes au total
        ))

    def log_nl_distribution(self):
        nl_distribution = {doctor.name: {
            'shifts': doctor.night_shifts,
            'min': doctor.min_nlw,
            'max': doctor.max_nlw,
            'half_parts': doctor.half_parts
        } for doctor in self.doctors}
        self.logger.info(f"NL weekend distribution: {nl_distribution}")
            
    def distribute_weekend_nm(self, planning: Planning, pre_analysis_results: Dict):
        ideal_distribution = pre_analysis_results.get('ideal_distribution', {})
        
        weekend_days = [day for day in planning.days if day.is_weekend or day.is_holiday_or_bridge]
        
        for doctor in self.doctors:
            ideal_namw = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get('NAMw', {})
            doctor.min_namw = math.floor(ideal_namw.get('min', 0))
            doctor.max_namw = math.ceil(ideal_namw.get('max', 0)) + 1
            doctor.nam_shifts = {'NMs': 0, 'NMd': 0, 'NAs': 0, 'NAd': 0, 'total': 0}

        for day in weekend_days:
            nam_slots = [slot for slot in day.slots if slot.abbreviation in ['NM', 'NA']]
            day_type = self.get_day_type_nam(day.date)
            
            for slot in nam_slots:
                eligible_doctors = self.get_eligible_doctors_nam(day, slot, planning)
                if eligible_doctors:
                    chosen_doctor = self.choose_doctor_nam(eligible_doctors, day_type)
                    slot.assignee = chosen_doctor.name
                    chosen_doctor.nam_shifts[f"{slot.abbreviation}{day_type}"] += 1
                    chosen_doctor.nam_shifts['total'] += 1
                    self.logger.info(f"Assigned {slot.abbreviation} on {day.date} ({day_type}) to {chosen_doctor.name} "
                                     f"(Total: {chosen_doctor.nam_shifts['total']}, "
                                     f"NMs: {chosen_doctor.nam_shifts['NMs']}, "
                                     f"NMd: {chosen_doctor.nam_shifts['NMd']}, "
                                     f"NAs: {chosen_doctor.nam_shifts['NAs']}, "
                                     f"NAd: {chosen_doctor.nam_shifts['NAd']}, "
                                     f"Half-parts: {chosen_doctor.half_parts})")
                else:
                    self.logger.warning(f"No eligible doctor for {slot.abbreviation} on {day.date}")

        self.log_nam_distribution()

    def get_day_type_nam(self, date):
        return 's' if date.weekday() == 5 else 'd'

    def get_eligible_doctors_nam(self, day, slot, planning):
        return [d for d in self.doctors 
                if d.nam_shifts['total'] < d.max_namw 
                and self.constraints.can_assign_to_assignee(d, day.date, slot, planning)]

    def choose_doctor_nam(self, eligible_doctors, day_type):
        random.shuffle(eligible_doctors)
        return min(eligible_doctors, key=lambda d: (
            -int(d.nam_shifts['total'] < d.min_namw),  # Priorité 1: Médecins sous leur minimum total
            d.nam_shifts[f"NM{day_type}"] + d.nam_shifts[f"NA{day_type}"],  # Priorité 2: Médecins avec moins de gardes de ce type
            -d.half_parts,  # Priorité 3: Médecins avec plus de demi-parts
            d.nam_shifts['total']  # Priorité 4: Médecins avec moins de gardes au total
        ))

    def log_nam_distribution(self):
        nam_distribution = {doctor.name: {
            'shifts': doctor.nam_shifts,
            'min': doctor.min_namw,
            'max': doctor.max_namw,
            'half_parts': doctor.half_parts
        } for doctor in self.doctors}
        self.logger.info(f"NAM weekend distribution: {nam_distribution}")

    def distribute_weekend_posts(self, planning: Planning, pre_analysis_results: Dict):
        ideal_distribution = pre_analysis_results.get('ideal_distribution', {})
        ideal_combinations = pre_analysis_results.get('ideal_combinations', {})
        
        weekend_days = [day for day in planning.days if day.is_weekend or day.is_holiday_or_bridge]
        
        for doctor in self.doctors:
            doctor.group_counts = {group: 0 for group in ["CmS", "CmD", "CaS", "CaD", "CsSD", "VmS", "VmD", "VaSD"]}
            doctor.combo_counts = {combo: 0 for combo in ideal_combinations.get(doctor.name, {})}

        # Étape 1: Distribution des combinaisons
        self.distribute_weekend_combinations(planning, weekend_days, ideal_combinations, ideal_distribution)
        
        # Étape 2: Distribution des postes restants
        self.distribute_remaining_weekend_posts(planning, weekend_days, ideal_distribution)


    def distribute_weekend_combinations(self, planning: Planning, weekend_days: List[DayPlanning], ideal_combinations: Dict, ideal_distribution: Dict):
        # Créer une liste de toutes les combinaisons possibles pour tous les jours
        all_combinations = []
        for day in weekend_days:
            for combo in ideal_combinations.get(self.doctors[0].name, {}):
                first_post, second_post = combo[:2], combo[2:]
                first_slot = next((slot for slot in day.slots if slot.abbreviation == first_post and not slot.assignee), None)
                second_slot = next((slot for slot in day.slots if slot.abbreviation == second_post and not slot.assignee), None)
                if first_slot and second_slot:
                    all_combinations.append((day, combo, first_slot, second_slot))
        
        # Mélanger aléatoirement toutes les combinaisons
        random.shuffle(all_combinations)

        # Distribuer les combinaisons dans l'ordre aléatoire
        for day, combo, first_slot, second_slot in all_combinations:
            eligible_doctors = self.get_eligible_doctors_for_combo(day, first_slot, second_slot, planning, combo, ideal_distribution)
            if eligible_doctors:
                chosen_doctor = self.choose_doctor_for_combo(eligible_doctors, combo, ideal_combinations, ideal_distribution)
                first_slot.assignee = chosen_doctor.name
                second_slot.assignee = chosen_doctor.name
                chosen_doctor.combo_counts[combo] = chosen_doctor.combo_counts.get(combo, 0) + 1
                self.update_group_counts(chosen_doctor, first_slot.abbreviation, second_slot.abbreviation)
                self.logger.info(f"Assigned combination {combo} on {day.date} to {chosen_doctor.name}")
            else:
                self.logger.warning(f"No eligible doctor for combination {combo} on {day.date}")

    def get_eligible_doctors_for_combo(self, day, first_slot, second_slot, planning, combo, ideal_distribution):
        return [d for d in self.doctors 
                if self.constraints.can_assign_to_assignee(d, day.date, first_slot, planning)
                and self.constraints.can_assign_to_assignee(d, day.date, second_slot, planning)
                and self.is_within_group_ideal_range(d, first_slot.abbreviation, second_slot.abbreviation, ideal_distribution)]

    def get_eligible_doctors_for_group(self, day, slot, planning, group, ideal_distribution):
        return [d for d in self.doctors 
                if self.constraints.can_assign_to_assignee(d, day.date, slot, planning)
                and self.is_within_group_ideal_range(d, slot.abbreviation, slot.abbreviation, ideal_distribution)]

    def would_exceed_group_ideal(self, doctor, first_post, second_post, ideal_distribution):
        for post in [first_post, second_post]:
            group = self.get_group_for_post(post)
            ideal = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {}).get('max', 0)
            if doctor.group_counts.get(group, 0) + 1 > math.ceil(ideal):
                return True
        return False
    def is_within_group_ideal_range(self, doctor, first_post, second_post, ideal_distribution):
        for post in [first_post, second_post]:
            group = self.get_group_for_post(post)
            ideal = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {})
            min_ideal = math.floor(ideal.get('min', 0))
            max_ideal = math.ceil(ideal.get('max', 0))
            current_count = doctor.group_counts.get(group, 0)
            if current_count + 1 > max_ideal:
                return False
            if current_count < min_ideal:
                return True
        return True

    
    def get_group_for_post(self, post):
        group_mappings = {
            "CmS": ["CM", "HM"],
            "CmD": ["CM", "HM", "SM", "RM"],
            "CaSD": ["CA", "HA", "RA", "SA"],
            "CsSD": ["CS", "HS", "RS", "SS"],
            "VmS": ["ML"],
            "VmD": ["ML", "MC"],
            "VaSD": ["AL", "AC"],
            "NAMw": ["NM", "NA"],
            "NLw": ["NL"]
        }
        return next((group for group, posts in group_mappings.items() if post in posts), None)



    def choose_doctor_for_combo(self, eligible_doctors, combo, ideal_combinations, ideal_distribution):
        random.shuffle(eligible_doctors)
        return min(eligible_doctors, key=lambda d: (
            -int(any(d.group_counts.get(self.get_group_for_post(post), 0) < math.floor(ideal_distribution.get(d.name, {}).get('weekend_groups', {}).get(self.get_group_for_post(post), {}).get('min', 0)) for post in combo[:2])),  # Priorité 1: Médecins n'ayant pas atteint le minimum pour un groupe
            -d.half_parts,  # Priorité 2: Médecins avec plus de demi-parts
            abs(d.combo_counts.get(combo, 0) - ideal_combinations.get(d.name, {}).get(combo, 0))  # Priorité 3: Écart par rapport à l'idéal de combinaison
        ))

    def update_group_counts(self, doctor, first_post, second_post):
        for post in [first_post, second_post]:
            group = self.get_group_for_post(post)
            if group:
                doctor.group_counts[group] = doctor.group_counts.get(group, 0) + 1

    def distribute_remaining_weekend_posts(self, planning: Planning, weekend_days: List[DayPlanning], ideal_distribution: Dict):
        weekend_groups = ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD"]
        
        for doctor in self.doctors:
            doctor.post_type_counts = {post_type: 0 for post_type in ALL_POST_TYPES}

        for day in weekend_days:
            for group in weekend_groups:
                slots = [slot for slot in day.slots if not slot.assignee and self.slot_belongs_to_group(slot.abbreviation, group)]
                random.shuffle(slots)  # Mélanger les slots pour une distribution aléatoire
                
                eligible_doctors = self.get_eligible_doctors_for_group(day, group, planning, ideal_distribution)
                
                for slot in slots:
                    if not eligible_doctors:
                        self.logger.warning(f"No eligible doctor for {slot.abbreviation} ({group}) on {day.date}")
                        continue

                    # Trier les médecins par leur score de déséquilibre pour ce type de poste
                    eligible_doctors.sort(key=lambda d: (
                        d.post_type_counts[slot.abbreviation],
                        -d.half_parts,
                        d.group_counts.get(group, 0) / d.half_parts
                    ))

                    # Sélectionner un médecin parmi les 3 premiers (ajoute de la variété)
                    chosen_doctor = random.choice(eligible_doctors[:min(3, len(eligible_doctors))])

                    slot.assignee = chosen_doctor.name
                    chosen_doctor.post_type_counts[slot.abbreviation] += 1
                    chosen_doctor.group_counts[group] = chosen_doctor.group_counts.get(group, 0) + 1

                    self.logger.info(f"Assigned {slot.abbreviation} ({group}) on {day.date} to {chosen_doctor.name} "
                                     f"(Group count: {chosen_doctor.group_counts[group]}, "
                                     f"Post type count: {chosen_doctor.post_type_counts[slot.abbreviation]}, "
                                     f"Half-parts: {chosen_doctor.half_parts})")

                    # Vérifier si le médecin est toujours éligible pour ce groupe
                    if not self.is_doctor_eligible_for_group(chosen_doctor, group, ideal_distribution):
                        eligible_doctors.remove(chosen_doctor)

    def get_eligible_doctors_for_group(self, day, group, planning, ideal_distribution):
        return [d for d in self.doctors 
                if self.is_doctor_eligible_for_group(d, group, ideal_distribution)
                and all(self.constraints.can_assign_to_assignee(d, day.date, slot, planning)
                        for slot in day.slots if self.slot_belongs_to_group(slot.abbreviation, group))]

    def is_doctor_eligible_for_group(self, doctor, group, ideal_distribution):
        ideal = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {})
        max_ideal = math.ceil(ideal.get('max', 0))
        return doctor.group_counts.get(group, 0) < max_ideal


    def choose_doctor_for_group(self, eligible_doctors, group, ideal_distribution):
        random.shuffle(eligible_doctors)
        return min(eligible_doctors, key=lambda d: (
            -int(d.group_counts.get(group, 0) < math.floor(ideal_distribution.get(d.name, {}).get('weekend_groups', {}).get(group, {}).get('min', 0))),  # Priorité 1: Médecins n'ayant pas atteint le minimum pour ce groupe
            -d.half_parts,  # Priorité 2: Médecins avec plus de demi-parts
            d.group_counts.get(group, 0) / d.half_parts,  # Priorité 3: Nombre de postes du groupe par demi-part
            sum(d.group_counts.values()) / d.half_parts  # Priorité 4: Nombre total de postes par demi-part
        ))
        
    def slot_belongs_to_group(self, abbreviation, group):
        group_mappings = {
            "CmS": ["CM", "HM"],
            "CmD": ["CM", "HM", "SM", "RM"],
            "CaSD": ["CA", "HA", "RA", "SA"],
            "CsSD": ["CS", "HS", "RS", "SS"],
            "VmS": ["ML"],
            "VmD": ["ML", "MC"],
            "VaSD": ["AL", "AC"]
        }
        return abbreviation in group_mappings.get(group, [])
    
    def distribute_remaining_posts_to_cats(self, planning: Planning, pre_analysis_results: Dict):
        cat_cycle = cycle(self.cats)  # Crée un cycle pour la rotation des CAT
        
        for day in planning.days:
            if day.is_weekend or day.is_holiday_or_bridge:
                day_type = "sunday_holiday" if day.is_holiday_or_bridge or day.date.weekday() == 6 else "saturday"
                cat_config = getattr(self.post_configuration, f"cat_{day_type}")
                
                for slot in day.slots:
                    if not slot.assignee:
                        for _ in range(len(self.cats)):  # Essayer tous les CAT une fois
                            cat = next(cat_cycle)

                            # Forcer `cat.posts` à être un dictionnaire si ce n'est pas le cas
                            if not isinstance(cat.posts, dict):
                                self.logger.error(f"Expected cat.posts to be a dictionary but got {type(cat.posts)} for CAT {cat.name}. Reinitializing to an empty dictionary.")
                                cat.posts = {post_type: 0 for post_type in ALL_POST_TYPES}  # Réinitialisation correcte

                            max_posts = cat_config.get(slot.abbreviation, PostConfig()).total
                            if cat.posts.get(slot.abbreviation, 0) < max_posts:
                                if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                                    slot.assignee = cat.name
                                    cat.posts[slot.abbreviation] = cat.posts.get(slot.abbreviation, 0) + 1
                                    self.logger.info(f"Assigned {slot.abbreviation} on {day.date} to CAT {cat.name}")
                                    break

                        if not slot.assignee:
                            self.logger.warning(f"Could not assign {slot.abbreviation} on {day.date} to any CAT")
                            
                            
    def post_process_weekend_distribution(self, planning: Planning, pre_analysis_results: Dict):
        if not planning or not planning.days or not pre_analysis_results:
            self.logger.warning("No planning data or pre-analysis results available")
            return

        weekend_days = [day for day in planning.days if day.is_weekend or day.is_holiday_or_bridge]
        ideal_distribution = pre_analysis_results.get('ideal_distribution', {})

        weekend_groups = ["CmS", "CmD", "CaSD", "CsSD", "VmS", "VmD", "VaSD", "NAMw", "NLw"]

        # Calculer la moyenne des totaux des médecins à temps plein
        full_time_totals = [sum(d.group_counts.values()) for d in self.doctors if d.half_parts == 2]
        avg_full_time_total = sum(full_time_totals) / len(full_time_totals) if full_time_totals else 0

        def calculate_doctor_score(doctor):
            score = 0
            total_posts = sum(doctor.group_counts.values())
            target_total = avg_full_time_total if doctor.half_parts == 2 else avg_full_time_total / 2

            for group in weekend_groups:
                count = doctor.group_counts.get(group, 0)
                ideal = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {}).get('max', 0)
                
                if doctor.half_parts == 1:
                    ideal = max(0, ideal / 2)  # Ajuster l'idéal pour les demi-parts
                
                if count > ideal:
                    score += (count - ideal) * (3 if doctor.half_parts == 1 else 2)  # Pénalité plus forte pour les demi-parts
                else:
                    score += ideal - count

            # Augmenter la pénalité pour l'écart par rapport au total cible
            score += abs(total_posts - target_total) * (4 if doctor.half_parts == 1 else 3)

            return score
        def is_valid_exchange(doc1: Doctor, doc2: Doctor, slot1: TimeSlot, slot2: TimeSlot) -> bool:
            group1, group2 = self.get_group_for_post(slot1.abbreviation), self.get_group_for_post(slot2.abbreviation)
            
            if not self.constraints.can_assign_to_assignee(doc1, slot2.start_time.date(), slot2, planning):
                return False
            if not self.constraints.can_assign_to_assignee(doc2, slot1.start_time.date(), slot1, planning):
                return False

            before_score = calculate_doctor_score(doc1) + calculate_doctor_score(doc2)
            
            # Simuler l'échange
            doc1.group_counts[group1] = doc1.group_counts.get(group1, 0) - 1
            doc1.group_counts[group2] = doc1.group_counts.get(group2, 0) + 1
            doc2.group_counts[group2] = doc2.group_counts.get(group2, 0) - 1
            doc2.group_counts[group1] = doc2.group_counts.get(group1, 0) + 1
            
            after_score = calculate_doctor_score(doc1) + calculate_doctor_score(doc2)
            
            # Annuler la simulation
            doc1.group_counts[group1] = doc1.group_counts.get(group1, 0) + 1
            doc1.group_counts[group2] = doc1.group_counts.get(group2, 0) - 1
            doc2.group_counts[group2] = doc2.group_counts.get(group2, 0) + 1
            doc2.group_counts[group1] = doc2.group_counts.get(group1, 0) - 1
            
            return after_score < before_score

        def redistribute_to_cat(doctor, cat, group, planning):
            for day in weekend_days:
                for slot in day.slots:
                    if slot.assignee == doctor.name and self.get_group_for_post(slot.abbreviation) == group:
                        cat_config = self.post_configuration.cat_saturday if day.date.weekday() == 5 else self.post_configuration.cat_sunday_holiday
                        if cat.posts.get(slot.abbreviation, 0) < cat_config.get(slot.abbreviation, PostConfig()).total:
                            if self.constraints.can_assign_to_assignee(cat, day.date, slot, planning):
                                slot.assignee = cat.name
                                doctor.group_counts[group] = doctor.group_counts.get(group, 0) - 1
                                cat.posts[slot.abbreviation] = cat.posts.get(slot.abbreviation, 0) + 1
                                self.logger.info(f"Redistributed {slot.abbreviation} from {doctor.name} to CAT {cat.name}")
                                return True
            return False

        # Processus principal de rééquilibrage
        for _ in range(100):  # Nombre maximum d'itérations
            improvements = False
            for day in weekend_days:
                for slot in day.slots:
                    doc1 = next((d for d in self.doctors if d.name == slot.assignee), None)
                    if not doc1:
                        continue

                    # Chercher un échange bénéfique
                    potential_exchanges = [(d, s) for d in self.doctors if d != doc1 
                                        for s in day.slots if s.assignee == d.name and s != slot]
                    random.shuffle(potential_exchanges)

                    for doc2, slot2 in potential_exchanges:
                        if is_valid_exchange(doc1, doc2, slot, slot2):
                            # Effectuer l'échange
                            slot.assignee, slot2.assignee = doc2.name, doc1.name
                            group1, group2 = self.get_group_for_post(slot.abbreviation), self.get_group_for_post(slot2.abbreviation)
                            doc1.group_counts[group1] = doc1.group_counts.get(group1, 0) - 1
                            doc1.group_counts[group2] = doc1.group_counts.get(group2, 0) + 1
                            doc2.group_counts[group2] = doc2.group_counts.get(group2, 0) - 1
                            doc2.group_counts[group1] = doc2.group_counts.get(group1, 0) + 1
                            improvements = True
                            self.logger.info(f"Exchanged {slot.abbreviation} and {slot2.abbreviation} between {doc1.name} and {doc2.name}")
                            break

                    if improvements:
                        break
                if improvements:
                    break
            
            if not improvements:
                break  # Arrêter si aucune amélioration n'a été trouvée dans cette itération

        # Redistribution des postes aux CAT pour équilibrer
        doctors_sorted = sorted(self.doctors, key=lambda d: sum(d.group_counts.values()) / d.half_parts, reverse=True)
        for doctor in doctors_sorted:
            for group in weekend_groups:
                while doctor.group_counts.get(group, 0) > ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {}).get('max', 0):
                    for cat in self.cats:
                        if redistribute_to_cat(doctor, cat, group, planning):
                            break
                    else:
                        break  # Si aucun CAT ne peut prendre le poste, on passe au groupe suivant

        # Vérification finale
        for doctor in self.doctors:
            total_posts = sum(doctor.group_counts.values())
            target_total = avg_full_time_total if doctor.half_parts == 2 else avg_full_time_total / 2
            
            for group in weekend_groups:
                count = doctor.group_counts.get(group, 0)
                ideal = ideal_distribution.get(doctor.name, {}).get('weekend_groups', {}).get(group, {}).get('max', 0)
                
                if doctor.half_parts == 1:
                    ideal = max(0, ideal - 1)
                
                if count > ideal:
                    self.logger.warning(f"{doctor.name} has excess in {group}: {count} vs ideal {ideal}")
                elif count < ideal - 1:
                    self.logger.warning(f"{doctor.name} has deficit in {group}: {count} vs ideal {ideal}")

            if abs(total_posts - target_total) > 2:
                self.logger.warning(f"{doctor.name} total posts ({total_posts}) deviate significantly from target ({target_total})")

        # Vérification des postes attribués aux CAT
        for cat in self.cats:
            for post_type, count in cat.posts.items():
                cat_config = self.post_configuration.cat_saturday  # Utiliser la configuration appropriée
                max_posts = cat_config.get(post_type, PostConfig()).total
                if count > max_posts:
                    self.logger.warning(f"CAT {cat.name} exceeds max posts for {post_type}: {count} vs max {max_posts}")


# core/constraints.py

from datetime import datetime, timedelta, date, time
from typing import List, Optional, Union
from core.models import Doctor, CAT, TimeSlot, DayPlanning, Planning
import logging

class PlanningConstraints:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def can_assign_to_assignee(self, assignee: Union[Doctor, CAT], date: date, slot: TimeSlot, planning: Planning) -> bool:
        day = planning.get_day(date)
        if day:
            existing_posts = sum(1 for s in day.slots if s.assignee == assignee.name)
            if existing_posts >= 2:
                self.logger.warning(f"Cannot assign: {assignee.name} already has {existing_posts} posts on {date}")
                return False
            return self.apply_constraints(assignee, day, slot, planning)
        return True

    def apply_constraints(self, assignee: Union[Doctor, CAT], day: DayPlanning, new_slot: TimeSlot, planning: Planning) -> bool:
        if self.check_time_overlap(assignee, day, new_slot):
            return False
        if self.check_max_posts_per_day(assignee, day):
            return False
        if self.check_night_shift_constraints(assignee, day, new_slot, planning):
            return False
        if isinstance(assignee, Doctor) and self.check_weekend_free_count(assignee, day, new_slot, planning):
            return False
        return True

    def check_time_overlap(self, assignee: Union[Doctor, CAT], day: DayPlanning, new_slot: TimeSlot) -> bool:
        for existing_slot in day.slots:
            if existing_slot.assignee == assignee.name:
                if (new_slot.start_time < existing_slot.end_time and 
                    new_slot.end_time > existing_slot.start_time):
                    self.logger.warning(f"Time overlap detected for {assignee.name} on {day.date}")
                    return True
        return False

    def check_max_posts_per_day(self, assignee: Union[Doctor, CAT], day: DayPlanning) -> bool:
        assigned_posts = sum(1 for slot in day.slots if slot.assignee == assignee.name)
        if assigned_posts >= 2:
            self.logger.warning(f"{assignee.name} already has 2 posts on {day.date}")
            return True
        return False

    def check_night_shift_constraints(self, assignee: Union[Doctor, CAT], day: DayPlanning, new_slot: TimeSlot, planning: Planning) -> bool:
        # Vérifier si l'assigné a une NM ou NL le même jour
        if any(slot.assignee == assignee.name and slot.abbreviation in ["NM", "NL"] for slot in day.slots):
            return True

        # Vérifier si l'assigné a une NL le jour précédent
        previous_day = planning.get_day(day.date - timedelta(days=1))
        if previous_day:
            if any(slot.assignee == assignee.name and slot.abbreviation == "NL" for slot in previous_day.slots):
                return True

        return False

    def check_weekend_free_count(self, doctor: Doctor, day: DayPlanning, new_slot: TimeSlot, planning: Planning) -> bool:
        if day.is_weekend or day.is_holiday_or_bridge:
            start_date = planning.start_date
            end_date = planning.end_date
            total_weekends = self.count_total_weekends(start_date, end_date)
            free_weekends = self.count_free_weekends(doctor, start_date, end_date, planning)
            
            required_free_weekends = total_weekends // 4  # Au moins 1 weekend libre sur 4

            if free_weekends <= required_free_weekends:
                self.logger.warning(f"{doctor.name} needs more free weekends")
                return True

        return False

    def count_total_weekends(self, start_date: date, end_date: date) -> int:
        total_weekends = 0
        current_date = start_date
        while current_date <= end_date:
            if current_date.weekday() == 5:  # Samedi
                total_weekends += 1
            current_date += timedelta(days=1)
        return total_weekends

    def count_free_weekends(self, doctor: Doctor, start_date: date, end_date: date, planning: Planning) -> int:
        free_weekends = 0
        current_date = start_date
        while current_date <= end_date:
            if current_date.weekday() == 5:  # Samedi
                if self.is_weekend_free(doctor, current_date, planning):
                    free_weekends += 1
            current_date += timedelta(days=1)
        return free_weekends

    def is_weekend_free(self, doctor: Doctor, saturday: date, planning: Planning) -> bool:
        saturday_day = planning.get_day(saturday)
        sunday_day = planning.get_day(saturday + timedelta(days=1))

        if not saturday_day or not sunday_day:
            return True

        saturday_slots = [slot for slot in saturday_day.slots if slot.assignee == doctor.name]
        sunday_slots = [slot for slot in sunday_day.slots if slot.assignee == doctor.name]

        return not (saturday_slots or sunday_slots)

# tests/test_pre_analyzer.py

# tests/test_pre_analyzer.py

import sys
import os
from datetime import date as dt_date, timedelta
import logging

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.models import Doctor, CAT, DailyPostConfiguration, PostConfig
from core.pre_analyzer import PlanningPreAnalyzer

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

def create_sample_data():
    doctors = [
        Doctor("AVIT", 2),
        Doctor("BASCOU", 2),
        Doctor("BEGUE", 2),
        Doctor("BERGOUGNAN", 2),
        Doctor("CHANTELOT", 2),
        Doctor("CHALVIGNAC", 2),
        Doctor("DALLAY", 2),
        Doctor("DALE", 2),
        Doctor("DARTY", 2),
        Doctor("DIARA", 2),
        Doctor("DUBAYLE", 2),
        Doctor("DUPRE", 2),
        Doctor("EPAILLY", 2),
        Doctor("FAIZ", 2),
        Doctor("FRIOT", 2),
        Doctor("GARIN", 2),
        Doctor("GRAMON", 2),
        Doctor("HILAL", 2),
        Doctor("HUGUENIN", 1),
        Doctor("JOUANOULOU", 1),
        Doctor("LEPAULT", 2),
        Doctor("MASSEYS", 1),
        Doctor("NEHME", 2),
        Doctor("NTAMI", 2),
        Doctor("OWANA", 2),
        Doctor("ROUGIER", 1),
        Doctor("VERVOUX", 1),
        Doctor("VILARD", 2),
        Doctor("WAKIEUX", 2)
    ]

    
    cats = [
        CAT("BRUNEAU"),
        CAT("JOACHIM"),
        CAT("PIQUART")
    ]

    post_configuration = DailyPostConfiguration()
    
    # Configuration pour les jours de semaine
    post_configuration.weekday = {
        "ML": PostConfig(total=2), "MM": PostConfig(total=1), "CM": PostConfig(total=1),
        "CA": PostConfig(total=2), "CS": PostConfig(total=1), "HM": PostConfig(total=1),
        "HA": PostConfig(total=1), "HS": PostConfig(total=1), "SS": PostConfig(total=1),
        "RS": PostConfig(total=1), "NC": PostConfig(total=1), "NM": PostConfig(total=2),
        "NL": PostConfig(total=2)
    }

    # Configuration pour le samedi
    post_configuration.saturday = {
        "ML": PostConfig(total=2), "AL": PostConfig(total=2), "CM": PostConfig(total=1),
        "AC": PostConfig(total=1), "CA": PostConfig(total=2), "CS": PostConfig(total=1), "HM": PostConfig(total=1),
        "HA": PostConfig(total=1), "HS": PostConfig(total=1), "SA": PostConfig(total=1),
        "SS": PostConfig(total=1), "RA": PostConfig(total=1), "RS": PostConfig(total=1),
        "NA": PostConfig(total=1), "NM": PostConfig(total=2), "NL": PostConfig(total=2)
    }

    # Configuration pour le dimanche et jours fériés
    post_configuration.sunday_holiday = {
        "ML": PostConfig(total=2), "AL": PostConfig(total=2), "MC": PostConfig(total=1),
        "AC": PostConfig(total=1), "CM": PostConfig(total=1), "CA": PostConfig(total=2),
        "CS": PostConfig(total=1), "HM": PostConfig(total=1), "HA": PostConfig(total=1),
        "HS": PostConfig(total=1), "SM": PostConfig(total=1), "SA": PostConfig(total=1),
        "SS": PostConfig(total=1), "RM": PostConfig(total=1), "RA": PostConfig(total=1),
        "RS": PostConfig(total=1), "NA": PostConfig(total=1), "NM": PostConfig(total=2),
        "NL": PostConfig(total=2)
    }

    return doctors, cats, post_configuration

def test_pre_analyzer():
    doctors, cats, post_configuration = create_sample_data()
    pre_analyzer = PlanningPreAnalyzer(doctors, cats, post_configuration)
    
    # Définir une période de 4 mois glissants
    end_date = dt_date.today().replace(day=1) + timedelta(days=32)  # Premier jour du mois suivant
    end_date = end_date.replace(day=1) - timedelta(days=1)  # Dernier jour du mois en cours
    start_date = end_date - timedelta(days=121)  # 4 mois avant (en comptant 30 jours par mois)
    
    pre_analyzer.set_date_range(start_date, end_date)
    
    results = pre_analyzer.run_test_analysis()
    
    
    print("\nDétails de l'analyse:")
    print(f"Période d'analyse: du {start_date} au {end_date}")
    print(f"\nPersonnel:")
    print(f"  Nombre total de médecins: {results['personnel']['total_doctors']}")
    print(f"  Médecins avec 1 demi-part: {results['personnel']['doctors_one_half_part']}")
    print(f"  Médecins avec 2 demi-parts: {results['personnel']['doctors_two_half_parts']}")
    print(f"  Nombre total de demi-parts: {results['personnel']['total_half_parts']}")
    print(f"  Nombre total de CATs: {results['personnel']['total_cats']}")
    
    print("\nAnalyse des postes:")
    for day_type, posts in results['posts']['total_posts'].items():
        print(f"  {day_type.capitalize()}:")
        for post_type, count in posts.items():
            print(f"    {post_type}: {count}")
    
    print(f"\nNombre de NL du vendredi: {results['posts']['friday_nl_count']}")
    
    print("\nAnalyse des groupes de postes du weekend:")
    for group, count in results['posts']['weekend_groups'].items():
        print(f"  {group}: {count}")
        
    print("\nAnalyse des groupes de postes de la semaine:")
    for group, count in results['posts']['weekday_groups'].items():
        print(f"  {group}: {count}")
    
    print("\nAnalyse des indisponibilités des médecins:")
    for doctor, percentage in results['unavailability']['doctor_unavailability'].items():
        print(f"  {doctor}: {percentage:.2f}% d'indisponibilité")
    
    print("\nJours les moins disponibles:")
    for date, count in results['unavailability']['least_available_days']:
        print(f"  {date}: {count} médecins indisponibles")
    
    print("\nDistribution idéale des postes par médecin:")
    for doctor, distribution in results['ideal_distribution'].items():
        print(f"\n  {doctor}:")
        print("    Postes du week-end:")
        for post_type, count in distribution['weekend_posts'].items():
            print(f"      {post_type}: min {count['min']}, max {count['max']}")
        print("    Groupes de postes du week-end:")
        for group, count in distribution['weekend_groups'].items():
            print(f"      {group}: min {count['min']}, max {count['max']}")
        print("    Postes de la semaine:")
        for post_type, count in distribution['weekday_posts'].items():
            print(f"      {post_type}: min {count['min']}, max {count['max']}")
        print("    Groupes de postes de la semaine:")
        for group, count in distribution['weekday_groups'].items():
            print(f"      {group}: min {count['min']}, max {count['max']}")
            
    print("\nCombinations idéales de postes par médecin:")
    for doctor, combinations in results['ideal_combinations'].items():
        print(f"\n  {doctor}:")
        for combo, count in combinations.items():
            print(f"    {combo}: {count}")

if __name__ == "__main__":
    test_pre_analyzer()


# gui/main_window.py


# gui/main_window.py
from PyQt6.QtWidgets import QMainWindow, QTabWidget
from .personnel_management import PersonnelManagementWidget
from .planning_view import PlanningViewWidget
from .desiderata_management import DesiderataManagementWidget
from .post_configuration import PostConfigurationWidget
from core.data_persistence import DataPersistence
from .stats_view import StatsView
from .doctor_planning_view import DoctorPlanningView
from .planning_comparison_view import PlanningComparisonView


class MainWindow(QMainWindow):
    def __init__(self, doctors, cats, post_configuration):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.data_persistence = DataPersistence()
        self.comparison_view = None  # Ajoutez cette ligne
        
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle('Planificateur SOS Médecins')
        self.setGeometry(100, 100, 1200, 800)

        self.tab_widget = QTabWidget()
        self.setCentralWidget(self.tab_widget)

        # Onglet Gestion du personnel
        self.personnel_tab = PersonnelManagementWidget(self.doctors, self.cats, self.post_configuration, self)
        self.tab_widget.addTab(self.personnel_tab, "Gestion du personnel")

        # Onglet Planning
        self.planning_tab = PlanningViewWidget(self.doctors, self.cats, self.post_configuration, self)
        self.tab_widget.addTab(self.planning_tab, "Planning")

        # Onglet Gestion des desiderata
        self.desiderata_tab = DesiderataManagementWidget(self.doctors, self.cats, self.planning_tab.start_date.date().toPyDate(), self.planning_tab.end_date.date().toPyDate(), self)
        self.tab_widget.addTab(self.desiderata_tab, "Gestion des desiderata")
        

        # Onglet Configuration des postes
        self.post_config_widget = PostConfigurationWidget(self.post_configuration, self)
        self.tab_widget.addTab(self.post_config_widget, "Configuration des postes")
        
        # Créer l'onglet des statistiques
        self.stats_tab = StatsView(doctors=self.doctors, cats=self.cats)
        self.tab_widget.addTab(self.stats_tab, "Statistiques")
        
          # Ajouter le nouvel onglet pour la vue du planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        self.tab_widget.addTab(self.doctor_planning_view, "Planning par médecin")

        # Ajouter l'onglet de comparaison des plannings
        self.comparison_view = PlanningComparisonView(None, self.doctors, self.cats)
        self.tab_widget.addTab(self.comparison_view, "Comparaison des plannings")
    
    def closeEvent(self, event):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        event.accept()

    def update_post_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        self.planning_tab.update_post_configuration(new_post_configuration)
        self.post_config_widget.update_configuration(new_post_configuration)
        # Ajoutez ici toute autre mise à jour nécessaire
        # Assurez-vous que d'autres parties de l'application qui utilisent post_configuration sont mises à jour si nécessaire
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        
    def update_data(self):
        self.personnel_tab.update_tables()
        self.planning_tab.update_data(self.doctors, self.cats, self.post_configuration)
        self.desiderata_tab.update_stats()  # Changez cette ligne
        self.post_config_widget.update_configuration(self.post_configuration)
        if hasattr(self.planning_tab, 'planning'):
            self.stats_tab.update_stats(self.planning_tab.planning, self.doctors, self.cats)
            if self.comparison_view:  # Ajoutez cette vérification
                self.comparison_view.planning = self.planning_tab.planning
                self.comparison_view.update_selectors()
        
        # Mettre à jour la vue du planning par médecin
        if hasattr(self.planning_tab, 'planning'):
            self.doctor_planning_view.planning = self.planning_tab.planning
            self.doctor_planning_view.update_table()
        
        if hasattr(self.planning_tab, 'planning'):
            self.comparison_view.planning = self.planning_tab.planning
            self.comparison_view.update_selectors()
            
    def save_data(self):
        self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)



# gui/stats_view.py



# gui/stats_view.py

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QTabWidget
from PyQt6.QtGui import QColor, QBrush
from PyQt6.QtCore import Qt
from core.models import ALL_POST_TYPES
import numpy as np
from datetime import datetime, time

class StatsView(QWidget):
    def __init__(self, planning=None, doctors=None, cats=None):
        super().__init__()
        self.planning = planning
        self.doctors = doctors
        self.cats = cats
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        tab_widget = QTabWidget()
        
        # Onglet des statistiques générales
        general_stats_widget = QWidget()
        general_stats_layout = QVBoxLayout(general_stats_widget)
        self.stats_table = QTableWidget()
        general_stats_layout.addWidget(self.stats_table)
        tab_widget.addTab(general_stats_widget, "Statistiques générales")
        
        # Nouvel onglet pour les statistiques détaillées
        detailed_stats_widget = QWidget()
        detailed_stats_layout = QVBoxLayout(detailed_stats_widget)
        self.create_detailed_stats_table()
        detailed_stats_layout.addWidget(self.detailed_stats_table)
        tab_widget.addTab(detailed_stats_widget, "Statistiques détaillées")
        
        layout.addWidget(tab_widget)
        self.setLayout(layout)

        if self.planning and self.doctors and self.cats:
            self.update_stats()
        else:
            self.stats_table.setRowCount(1)
            self.stats_table.setColumnCount(1)
            self.stats_table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))

    def update_stats(self, planning=None, doctors=None, cats=None):
        if planning is not None:
            self.planning = planning
        if doctors is not None:
            self.doctors = doctors
        if cats is not None:
            self.cats = cats
        
        if self.planning and self.doctors and self.cats:
            self.create_stats_table()
            detailed_stats = self.calculate_detailed_stats()  # Ajoutez cette ligne
            self.update_detailed_stats_table(detailed_stats)  # Et cette ligne
    
        else:
            self.stats_table.setRowCount(1)
            self.stats_table.setColumnCount(1)
            self.stats_table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))
            self.detailed_stats_table.setRowCount(1)
            self.detailed_stats_table.setColumnCount(1)
            self.detailed_stats_table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))

    def update_detailed_stats_table(self, stats):
        self.detailed_stats_table.setRowCount(len(stats))
        for row, (doctor, data) in enumerate(stats.items()):
            self.detailed_stats_table.setItem(row, 0, QTableWidgetItem(doctor))
            for col, (key, value) in enumerate(data.items(), start=1):
                item = QTableWidgetItem(str(value))
                self.detailed_stats_table.setItem(row, col, item)
            
            # Vérifier si le médecin n'a qu'une seule demi-part
            doctor_obj = next((d for d in self.doctors if d.name == doctor), None)
            if doctor_obj and doctor_obj.half_parts == 1:
                for col in range(self.detailed_stats_table.columnCount()):
                    item = self.detailed_stats_table.item(row, col)
                    item.setBackground(QBrush(QColor(240, 240, 240)))  # Gris clair
                    
    def calculate_stats(self):
        stats = {doctor.name: {post_type: 0 for post_type in ALL_POST_TYPES} for doctor in self.doctors}
        stats.update({cat.name: {post_type: 0 for post_type in ALL_POST_TYPES} for cat in self.cats})
        stats["Non attribué"] = {post_type: 0 for post_type in ALL_POST_TYPES}
        
        if not self.planning or not self.planning.days:
            return stats

        for day_planning in self.planning.days:
            for slot in day_planning.slots:
                if slot.assignee in stats:
                    stats[slot.assignee][slot.abbreviation] += 1
                else:
                    stats["Non attribué"][slot.abbreviation] += 1
        
        return stats
    
    def create_stats_table(self):
        stats = self.calculate_stats()
        print("Calculated stats:", stats)  # Debugging output

        self.stats_table.clear()
        self.stats_table.setRowCount(len(self.doctors) + len(self.cats) + 2)  # +2 pour les lignes de total et non attribués
        self.stats_table.setColumnCount(len(ALL_POST_TYPES) + 2)  # +2 pour la colonne "Assigné à" et "Total"

        headers = ["Assigné à"] + ALL_POST_TYPES + ["Total"]
        self.stats_table.setHorizontalHeaderLabels(headers)

        sorted_doctors = sorted([d.name for d in self.doctors])
        sorted_cats = sorted([c.name for c in self.cats])
        sorted_assignees = sorted_doctors + sorted_cats + ["Non attribué"]

        total_row = {post_type: 0 for post_type in ALL_POST_TYPES}
        total_row["Total"] = 0

        for row, assignee in enumerate(sorted_assignees):
            self.stats_table.setItem(row, 0, QTableWidgetItem(assignee))
            assignee_stats = stats.get(assignee, {})
            
            assignee_total = 0
            for col, post_type in enumerate(ALL_POST_TYPES, start=1):
                count = assignee_stats.get(post_type, 0)
                self.stats_table.setItem(row, col, QTableWidgetItem(str(count)))
                
                if assignee in sorted_doctors:
                    avg_count = np.mean([stats.get(d, {}).get(post_type, 0) for d in sorted_doctors])
                    if count >= avg_count + 3:
                        self.stats_table.item(row, col).setBackground(QBrush(QColor(255, 200, 200)))
                    elif count <= avg_count - 3:
                        self.stats_table.item(row, col).setBackground(QBrush(QColor(200, 255, 200)))
                
                assignee_total += count
                total_row[post_type] += count
            
            self.stats_table.setItem(row, len(ALL_POST_TYPES) + 1, QTableWidgetItem(str(assignee_total)))
            total_row["Total"] += assignee_total

        # Ajouter la ligne de total
        last_row = self.stats_table.rowCount() - 1
        self.stats_table.setItem(last_row, 0, QTableWidgetItem("Total"))
        for col, post_type in enumerate(ALL_POST_TYPES, start=1):
            self.stats_table.setItem(last_row, col, QTableWidgetItem(str(total_row[post_type])))
        self.stats_table.setItem(last_row, len(ALL_POST_TYPES) + 1, QTableWidgetItem(str(total_row["Total"])))

        self.stats_table.resizeColumnsToContents()
        self.stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        
    def calculate_unassigned_posts(self):
        unassigned = {post_type: 0 for post_type in ALL_POST_TYPES}
        if not self.planning or not self.planning.days:
            return unassigned

        for day in self.planning.days:
            for slot in day.slots:
                if slot.assignee == "Non attribué":
                    unassigned[slot.abbreviation] += 1
        return unassigned
    
    
    def create_detailed_stats_table(self):
        self.detailed_stats_table = QTableWidget()
        headers = [
            "Médecin", "NLv", "NLs", "NLd", "NLw", "NAMw",
            "VmS", "VmD", "VaSD", "CmS", "CmD", "CaS", "CaD", "CsSD",
            "WE Lib"
        ]
        self.detailed_stats_table.setColumnCount(len(headers))
        self.detailed_stats_table.setHorizontalHeaderLabels(headers)

        stats = self.calculate_detailed_stats()
        self.detailed_stats_table.setRowCount(len(stats))

        for row, (doctor, data) in enumerate(stats.items()):
            self.detailed_stats_table.setItem(row, 0, QTableWidgetItem(doctor))
            for col, (key, value) in enumerate(data.items(), start=1):
                self.detailed_stats_table.setItem(row, col, QTableWidgetItem(str(value)))

        self.detailed_stats_table.resizeColumnsToContents()
        self.detailed_stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

    def calculate_detailed_stats(self):
        stats = {doctor.name: {
            "NLv": 0, "NLs": 0, "NLd": 0, "NLw": 0, "NAMw": 0,
            "VmS": 0, "VmD": 0, "VaSD": 0,
            "CmS": 0, "CmD": 0, "CaS": 0, "CaD": 0, "CsSD": 0,
            "WE Lib": 0
        } for doctor in self.doctors}

        if not self.planning or not self.planning.days:
            print("No planning data available")
            return stats

        weekend_worked = {doctor.name: set() for doctor in self.doctors}

        for day in self.planning.days:
            is_friday = day.date.weekday() == 4
            is_saturday = day.date.weekday() == 5
            is_sunday_holiday = day.date.weekday() == 6 or day.is_holiday_or_bridge
            is_weekend_or_holiday = is_saturday or is_sunday_holiday

            for slot in day.slots:
                if slot.assignee in stats:
                    if slot.abbreviation == "NL":
                        if is_friday:
                            stats[slot.assignee]["NLv"] += 1
                        elif is_saturday:
                            stats[slot.assignee]["NLs"] += 1
                        elif is_sunday_holiday:
                            stats[slot.assignee]["NLd"] += 1
                        stats[slot.assignee]["NLw"] += 1
                    elif slot.abbreviation in ["NM", "NA"] and is_weekend_or_holiday:
                        stats[slot.assignee]["NAMw"] += 1
                    elif slot.abbreviation == "ML" and is_saturday:
                        stats[slot.assignee]["VmS"] += 1
                    elif (slot.abbreviation == "ML" or slot.abbreviation == "MC") and is_sunday_holiday:
                        stats[slot.assignee]["VmD"] += 1
                    elif slot.abbreviation in ["AL", "AC"] and is_weekend_or_holiday:
                        stats[slot.assignee]["VaSD"] += 1
                    elif slot.abbreviation in ["CM", "HM"] and is_saturday:
                        stats[slot.assignee]["CmS"] += 1
                    elif slot.abbreviation in ["CM", "HM", "SM", "RM"] and is_sunday_holiday:
                        stats[slot.assignee]["CmD"] += 1
                    elif slot.abbreviation in ["CA", "HA", "RA", "SA"] and is_saturday:
                        stats[slot.assignee]["CaS"] += 1
                    elif slot.abbreviation in ["CA", "HA", "RA", "SA"] and is_sunday_holiday:
                        stats[slot.assignee]["CaD"] += 1
                    elif slot.abbreviation in ["CS", "HS", "RS", "SS"] and is_weekend_or_holiday:
                        stats[slot.assignee]["CsSD"] += 1

                    if is_weekend_or_holiday:
                        weekend_worked[slot.assignee].add(day.date.isocalendar()[1])  # Add week number

        # Calculer les weekends libres
        total_weekends = len(set(day.date.isocalendar()[1] for day in self.planning.days if day.date.weekday() in [5, 6]))
        for doctor in self.doctors:
            stats[doctor.name]["WE Lib"] = total_weekends - len(weekend_worked[doctor.name])

        return stats

# gui/planning_comparison_view.py


# gui/planning_comparison_view.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox, QPushButton,
                             QTableWidget, QTableWidgetItem, QDialog, QLabel, QScrollArea)
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QColor, QBrush
from datetime import date, timedelta
import calendar

class PlanningComparisonView(QWidget):
    def __init__(self, planning, doctors, cats):
        super().__init__()
        self.planning = planning

        # Tri alphabétique des médecins et des CAT
        self.doctors = sorted(doctors, key=lambda d: d.name)
        self.cats = sorted(cats, key=lambda c: c.name)
        self.init_ui()
        self.synchronize_scrollbars()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteurs
        controls_layout = QHBoxLayout()
        self.selector1 = QComboBox()
        self.selector2 = QComboBox()
        self.info_label1 = QLabel("")  # Label pour afficher les informations sous le premier menu
        self.info_label2 = QLabel("")  # Label pour afficher les informations sous le deuxième menu
        self.update_selectors()
        controls_layout.addWidget(self.selector1)
        controls_layout.addWidget(self.info_label1)
        controls_layout.addWidget(self.selector2)
        controls_layout.addWidget(self.info_label2)
        layout.addLayout(controls_layout)

        # Scroll areas pour les tables
        scroll_area1 = QScrollArea()
        scroll_area2 = QScrollArea()
        scroll_area1.setWidgetResizable(True)
        scroll_area2.setWidgetResizable(True)

        self.table1 = FullPlanningTable(self)
        self.table2 = FullPlanningTable(self)
        scroll_area1.setWidget(self.table1)
        scroll_area2.setWidget(self.table2)

        tables_layout = QHBoxLayout()
        tables_layout.addWidget(scroll_area1)
        tables_layout.addWidget(scroll_area2)
        layout.addLayout(tables_layout)

        self.setLayout(layout)

        # Initialiser l'affichage
        self.update_comparison()

    def get_doctor_parts(self, doctor_name):
        """
        Méthode pour récupérer dynamiquement le nombre de parts d'un médecin.
        Doit être adaptée en fonction de l'endroit où cette information est stockée.
        """
        doctor = next((d for d in self.doctors if d.name == doctor_name), None)
        if doctor:
            # Vérifier si le médecin a un attribut ou une méthode pour obtenir le nombre de parts
            return getattr(doctor, 'half_parts', 1)  # Utilise 'half_parts' ou une valeur par défaut de 1
        return None

    def update_selectors(self):
        # Ajout des médecins et CAT dans les sélecteurs, avec couleur pour les CAT
        self.selector1.clear()
        self.selector2.clear()

        options1 = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        options2 = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        
        self.selector1.addItems(options1)
        self.selector2.addItems(options2)

        # Colorer les CAT
        for i in range(self.selector1.count()):
            if i > len(self.doctors):
                self.selector1.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)
                self.selector2.setItemData(i, QColor(Qt.GlobalColor.blue), Qt.ItemDataRole.ForegroundRole)

        # Conserver le focus sur le sélecteur pour parcourir avec les flèches
        self.selector1.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.selector2.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

        # Connecter les sélecteurs à la mise à jour des informations et de la table
        self.selector1.currentIndexChanged.connect(self.update_comparison)
        self.selector1.currentIndexChanged.connect(self.update_info_label1)
        self.selector2.currentIndexChanged.connect(self.update_comparison)
        self.selector2.currentIndexChanged.connect(self.update_info_label2)

    def update_info_label1(self):
        selected = self.selector1.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label1.setText("Médecin à plein temps")
            else:
                self.info_label1.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label1.setText("CAT")
        else:
            self.info_label1.setText("")

    def update_info_label2(self):
        selected = self.selector2.currentText()
        if selected in [d.name for d in self.doctors]:
            # Appel à la méthode pour récupérer le nombre de parts
            parts = self.get_doctor_parts(selected)
            if parts == 2:
                self.info_label2.setText("Médecin à plein temps")
            else:
                self.info_label2.setText("Médecin à mi-temps")
        elif selected in [c.name for c in self.cats]:
            self.info_label2.setText("CAT")
        else:
            self.info_label2.setText("")

    def update_comparison(self):
        selected1 = self.selector1.currentText()
        selected2 = self.selector2.currentText()
        self.table1.populate_table(selected1)
        self.table2.populate_table(selected2)




    def on_assignment_changed(self):
            self.update_comparison()
            # Mettre à jour les autres vues si nécessaire
            if hasattr(self.window(), 'planning_tab'):
                self.window().planning_tab.update_table()
            if hasattr(self.window(), 'stats_tab'):
                self.window().stats_tab.update_stats(self.planning, self.doctors, self.cats)
            # Ajoutez cette ligne pour mettre à jour la vue du planning par médecin
            if hasattr(self.window(), 'doctor_planning_view'):
                self.window().doctor_planning_view.update_view(self.planning, self.doctors, self.cats)
    def synchronize_scrollbars(self):
        """
        Synchronise les barres de défilement des deux tables pour un défilement horizontal et vertical simultané.
        """
        # Synchronisation du défilement vertical
        self.table1.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table2)
        self.table2.verticalScrollBar().valueChanged.connect(self.sync_scroll_vertical_table1)

        # Synchronisation du défilement horizontal
        self.table1.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table2)
        self.table2.horizontalScrollBar().valueChanged.connect(self.sync_scroll_horizontal_table1)

        self.is_syncing_vertical = False
        self.is_syncing_horizontal = False

    def sync_scroll_vertical_table2(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table2.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_vertical_table1(self, value):
        if not self.is_syncing_vertical:
            self.is_syncing_vertical = True
            self.table1.verticalScrollBar().setValue(value)
            self.is_syncing_vertical = False

    def sync_scroll_horizontal_table2(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table2.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False

    def sync_scroll_horizontal_table1(self, value):
        if not self.is_syncing_horizontal:
            self.is_syncing_horizontal = True
            self.table1.horizontalScrollBar().setValue(value)
            self.is_syncing_horizontal = False



class FullPlanningTable(QTableWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.verticalHeader().setVisible(False)
        
        # Connecter les événements pour clic simple et double-clic
        self.itemClicked.connect(self.on_item_clicked)
        self.cellDoubleClicked.connect(self.on_item_double_clicked)

    def populate_table(self, selected):
        if not self.parent.planning or not self.parent.planning.days:
            return

        self.clear()

        # Dynamique : calculer le nombre total de mois et jours
        start_date = self.parent.planning.start_date
        end_date = self.parent.planning.end_date
        total_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

        # Ajuster le nombre de lignes en fonction des jours entre start_date et end_date
        self.setRowCount(max((end_date - start_date).days + 1, 31))
        self.setColumnCount(total_months + 2)

        # Création des étiquettes d'en-tête avec une conversion en chaînes de caractères
        headers = ["Jour", "Sem"] + [(start_date + timedelta(days=30 * i)).strftime("%B %Y") for i in range(total_months)]
        self.setHorizontalHeaderLabels(headers)

        # Autres opérations d'affichage
        weekend_color = QColor(240, 240, 240)
        desiderata_color = QColor(255, 200, 200)  # Rouge très clair pour les desiderata

        current_date = start_date
        while current_date <= end_date:
            month_col = (current_date.year - start_date.year) * 12 + current_date.month - start_date.month + 1
            day_row = current_date.day - 1
            day_item = QTableWidgetItem(str(current_date.day))
            week_day_item = QTableWidgetItem(current_date.strftime("%a"))
            self.setItem(day_row, 0, day_item)
            self.setItem(day_row, 1, week_day_item)

            day_planning = next((day for day in self.parent.planning.days if day.date == current_date), None)
            if day_planning:
                posts = [slot.abbreviation for slot in day_planning.slots if (selected == "Non attribué" and slot.assignee is None) or slot.assignee == selected]
                post_text = ", ".join(posts)
                item = QTableWidgetItem(post_text)
                item.setData(Qt.ItemDataRole.UserRole, day_planning)

                if day_planning.is_weekend or day_planning.is_holiday_or_bridge:
                    item.setBackground(QBrush(weekend_color))

                # Colorer les desiderata
                selected_person = next((p for p in self.parent.doctors + self.parent.cats if p.name == selected), None)
                if selected_person:
                    for desiderata in selected_person.desiderata:
                        if desiderata.start_date <= current_date <= desiderata.end_date:
                            item.setBackground(QBrush(desiderata_color))

                self.setItem(day_row, month_col, item)

            current_date += timedelta(days=1)

        self.resizeColumnsToContents()



    
    def on_item_clicked(self, item):
        """
        Met en surbrillance la même case dans l'autre tableau.
        """
        if item.column() > 0:  # Ignorer la colonne des numéros de jour
            row = item.row()
            column = item.column()

            # Mettre en surbrillance la cellule correspondante dans l'autre tableau
            if self == self.parent.table1:
                other_table = self.parent.table2
            else:
                other_table = self.parent.table1
            
            other_table.setCurrentCell(row, column)

    def on_item_double_clicked(self, row, column):
        """
        Ouvre la boîte de dialogue lors d'un double clic et affiche uniquement les postes présents dans la cellule.
        """
        if column > 0:  # Ignorer la colonne des numéros de jour
            item = self.item(row, column)
            day = item.data(Qt.ItemDataRole.UserRole)
            if day:
                # Sélectionner l'assigné du tableau comparé
                if self == self.parent.table1:
                    current_assignee = self.parent.selector1.currentText()
                    compared_assignee = self.parent.selector2.currentText()  # Nom du tableau comparé
                else:
                    current_assignee = self.parent.selector2.currentText()
                    compared_assignee = self.parent.selector1.currentText()  # Nom du tableau comparé

                # Récupérer les postes de la cellule associés à l'assigné
                available_posts = [slot.abbreviation for slot in day.slots if slot.assignee == current_assignee]

                # Ouvrir la boîte de dialogue avec les postes filtrés
                dialog = PostAssignmentDialog(day, current_assignee, self.parent.doctors, self.parent.cats, compared_assignee, available_posts)
                if dialog.exec() == QDialog.DialogCode.Accepted:
                    new_assignee = dialog.get_selected_assignee()
                    selected_post = dialog.get_selected_post()
                    self.update_assignment(day, current_assignee, new_assignee, selected_post)


    def update_assignment(self, day, current_assignee, new_assignee, selected_post):
        """
        Met à jour l'assignation pour le poste sélectionné.
        """
        for slot in day.slots:
            if slot.abbreviation == selected_post:  # On ne change que l'assigné pour le poste sélectionné
                if (current_assignee == "Non attribué" and slot.assignee is None) or slot.assignee == current_assignee:
                    slot.assignee = new_assignee if new_assignee != "Non attribué" else None
        self.parent.on_assignment_changed()



class PostAssignmentDialog(QDialog):
    def __init__(self, day, current_assignee, doctors, cats, compared_assignee, available_posts):
        super().__init__()
        self.day = day
        self.current_assignee = current_assignee
        self.doctors = doctors
        self.cats = cats
        self.compared_assignee = compared_assignee
        self.available_posts = available_posts
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Affichage du nom de l'assigné par défaut (comparé)
        layout.addWidget(QLabel(f"Choisir un nouvel assigné pour le {self.day.date}:"))
        
        # Sélecteur pour l'assigné (docteurs et CAT)
        self.assignee_selector = QComboBox()
        options = ["Non attribué"] + [d.name for d in self.doctors] + [c.name for c in self.cats]
        self.assignee_selector.addItems(options)
        
        # Définir l'assigné par défaut comme celui comparé
        self.assignee_selector.setCurrentText(self.compared_assignee)
        layout.addWidget(self.assignee_selector)

        # Sélecteur pour les postes disponibles (seulement les postes présents dans la case)
        layout.addWidget(QLabel("Choisir les postes à échanger :"))
        self.post_selector = QComboBox()
        self.post_selector.addItems(self.available_posts)
        layout.addWidget(self.post_selector)

        # Boutons d'action
        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addLayout(buttons)

    def get_selected_assignee(self):
        return self.assignee_selector.currentText()

    def get_selected_post(self):
        return self.post_selector.currentText()


# gui/__init__.py



# gui/personnel_management.py


# gui/personnel_management.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                             QFormLayout, QLineEdit, QSpinBox, QMessageBox, QSizePolicy,
                             QLabel, QFrame, QTableWidget, QTableWidgetItem, QDialog, QGridLayout)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont, QColor
from core.models import Doctor, CAT, ALL_POST_TYPES, Desiderata
from core.data_persistence import DataPersistence



class PersonnelManagementWidget(QWidget):
    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.data_persistence = DataPersistence()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        tab_widget = QTabWidget()
        
        # Onglet des médecins
        doctors_tab = QWidget()
        doctors_layout = QVBoxLayout(doctors_tab)

        grid_container = QWidget()
        grid_container.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        self.doctors_grid = QGridLayout(grid_container)
        self.doctors_grid.setSpacing(0)
        self.doctors_grid.setContentsMargins(1, 1, 1, 1)

        doctors_layout.addWidget(grid_container)

        add_doctor_button = QPushButton("Ajouter un médecin")
        add_doctor_button.clicked.connect(lambda: self.add_personnel("Médecin"))
        add_doctor_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        doctors_layout.addWidget(add_doctor_button)

        tab_widget.addTab(doctors_tab, "Médecins")

        # Onglet des CAT
        cats_tab = QWidget()
        cats_layout = QVBoxLayout(cats_tab)
        
        self.cats_grid = QWidget()
        self.cats_grid.setStyleSheet("""
            QWidget {
                background-color: white;
                border: 1px solid #ddd;
            }
        """)
        cats_layout.addWidget(self.cats_grid)
        
        add_cat_button = QPushButton("Ajouter un CAT")
        add_cat_button.clicked.connect(lambda: self.add_personnel("CAT"))
        add_cat_button.setStyleSheet("""
            QPushButton {
                background-color: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px 10px;
                font-size: 14px;
                border-radius: 3px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        cats_layout.addWidget(add_cat_button)
        
        tab_widget.addTab(cats_tab, "CAT")

        layout.addWidget(tab_widget)

        self.update_tables()

    def update_tables(self):
        self.update_doctors_table()
        self.update_cats_table()

    def update_doctors_table(self):
        for i in reversed(range(self.doctors_grid.count())): 
            self.doctors_grid.itemAt(i).widget().setParent(None)

        sorted_doctors = sorted(self.doctors, key=lambda x: x.name.lower())

        for index, doctor in enumerate(sorted_doctors):
            row = index // 2
            col = index % 2 * 4

            doctor_frame = QFrame()
            doctor_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                }
            """)
            doctor_layout = QHBoxLayout(doctor_frame)
            doctor_layout.setContentsMargins(5, 5, 5, 5)
            doctor_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            doctor_layout.addWidget(number_label)

            name_label = QLabel(doctor.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            doctor_layout.addWidget(name_label)

            half_parts_label = QLabel(f"Demi-parts: {doctor.half_parts}")
            doctor_layout.addWidget(half_parts_label)

            edit_button = QPushButton("Modifier")
            edit_button.clicked.connect(lambda _, d=doctor: self.edit_personnel(d))
            delete_button = QPushButton("Supprimer")
            delete_button.clicked.connect(lambda _, d=doctor: self.delete_personnel(d))
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 3px 8px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 1px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                doctor_layout.addWidget(button)

            if doctor.half_parts == 1:
                doctor_frame.setStyleSheet("""
                    QFrame {
                        border: 1px solid #ddd;
                        background-color: #FFFFD0;
                    }
                """)

            self.doctors_grid.addWidget(doctor_frame, row, col, 1, 4)

        for i in range(8):
            self.doctors_grid.setColumnStretch(i, 1)
            
    def update_cats_table(self):
        if self.cats_grid.layout():
            QWidget().setLayout(self.cats_grid.layout())

        cats_layout = QVBoxLayout(self.cats_grid)
        cats_layout.setSpacing(0)
        cats_layout.setContentsMargins(0, 0, 0, 0)

        sorted_cats = sorted(self.cats, key=lambda x: x.name.lower())

        for index, cat in enumerate(sorted_cats):
            cat_frame = QFrame()
            cat_frame.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    background-color: #fff;
                    padding: 2px;
                }
            """)
            cat_layout = QHBoxLayout(cat_frame)
            cat_layout.setContentsMargins(5, 5, 5, 5)
            cat_layout.setSpacing(10)

            number_label = QLabel(f"{index + 1}.")
            number_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            number_label.setFixedWidth(20)
            cat_layout.addWidget(number_label)

            name_label = QLabel(cat.name)
            name_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
            cat_layout.addWidget(name_label)

            cat_layout.addStretch(1)

            edit_button = QPushButton("Modifier")
            edit_button.clicked.connect(lambda _, c=cat: self.edit_personnel(c))
            delete_button = QPushButton("Supprimer")
            delete_button.clicked.connect(lambda _, c=cat: self.delete_personnel(c))
            
            button_style = """
                QPushButton {
                    background-color: #f8f8f8;
                    color: #333;
                    border: 1px solid #ddd;
                    padding: 2px 5px;
                    font-size: 11px;
                    border-radius: 2px;
                    margin: 0px;
                }
                QPushButton:hover {
                    background-color: #e8e8e8;
                }
            """
            
            for button in [edit_button, delete_button]:
                button.setStyleSheet(button_style)
                button.setFixedSize(70, 25)
                cat_layout.addWidget(button)

            cats_layout.addWidget(cat_frame)

        cats_layout.addStretch(1)

    def add_personnel(self, personnel_type):
        if personnel_type == "Médecin":
            dialog = PersonnelDialog(self, personnel_type=personnel_type)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                self.doctors.append(Doctor(name, half_parts))
        else:  # CAT
            dialog = CATDialog(self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()
                new_cat = CAT(name)
                self.cats.append(new_cat)
        self.update_tables()
        self.save_data()

    def delete_personnel(self, person):
        confirm = QMessageBox.question(self, "Confirmer la suppression", 
                                       f"Êtes-vous sûr de vouloir supprimer {person.name} ?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            if isinstance(person, Doctor):
                self.doctors.remove(person)
            else:
                self.cats.remove(person)
            self.update_tables()
            self.save_data()

    def edit_personnel(self, person):
        if isinstance(person, Doctor):
            dialog = PersonnelDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name, _, half_parts = dialog.get_personnel_info()
                person.name = name
                person.half_parts = half_parts
        else:  # CAT
            dialog = CATDialog(self, person)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                name = dialog.get_cat_info()                    
                person.name = name
        self.update_tables()
        self.save_data()

    def save_data(self):
        if hasattr(self, 'data_persistence'):
            self.data_persistence.save_data(self.doctors, self.cats, self.post_configuration)
        else:
            print("Attention : Aucun mécanisme de persistance des données n'est configuré.")

class PersonnelDialog(QDialog):
    def __init__(self, parent=None, person=None, personnel_type=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier personnel")
        self.person = person
        self.personnel_type = personnel_type if person is None else ("Médecin" if isinstance(person, Doctor) else "CAT")
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        if self.personnel_type == "Médecin":
            self.half_parts_input = QSpinBox()
            self.half_parts_input.setRange(1, 2)
            layout.addRow("Demi-parts:", self.half_parts_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.person:
            self.name_input.setText(self.person.name)
            if isinstance(self.person, Doctor):
                self.half_parts_input.setValue(self.person.half_parts)

    def get_personnel_info(self):
        half_parts = self.half_parts_input.value() if self.personnel_type == "Médecin" else 0
        return self.name_input.text(), self.personnel_type, half_parts
    

    
class CATDialog(QDialog):
    def __init__(self, parent=None, cat=None):
        super().__init__(parent)
        self.setWindowTitle("Ajouter/Modifier CAT")
        self.cat = cat
        self.init_ui()

    def init_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit()
        layout.addRow("Nom:", self.name_input)

        buttons = QHBoxLayout()
        save_button = QPushButton("Enregistrer")
        save_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Annuler")
        cancel_button.clicked.connect(self.reject)
        buttons.addWidget(save_button)
        buttons.addWidget(cancel_button)
        layout.addRow(buttons)

        if self.cat:
            self.name_input.setText(self.cat.name)

    def get_cat_info(self):
        return self.name_input.text()




# gui/planning_view.py


# gui/planning_view.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QLabel,
                             QTableWidget, QTableWidgetItem, QDateEdit, QMessageBox, QProgressBar)
from PyQt6.QtCore import Qt, QDate, QThread, pyqtSignal
from PyQt6.QtGui import QColor, QBrush
from core.planning_generator import PlanningGenerator
from datetime import date, timedelta
from .doctor_planning_view import DoctorPlanningView

class PlanningGenerationThread(QThread):
    progress_update = pyqtSignal(int)
    planning_generated = pyqtSignal(object)

    def __init__(self, planning_generator, start_date, end_date):
        super().__init__()
        self.planning_generator = planning_generator
        self.start_date = start_date
        self.end_date = end_date

    def run(self):
        planning = self.planning_generator.generate_planning(self.start_date, self.end_date)
        self.planning_generated.emit(planning)

class PlanningViewWidget(QWidget):
    def __init__(self, doctors, cats, post_configuration, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        self.planning = None
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout(self)

        # Contrôles de date et bouton de génération
        date_layout = QHBoxLayout()
        
        self.start_date = QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setCalendarPopup(True)

        # Définir les dates par défaut
        today = date.today()
        end_date = today + timedelta(days=4*30)  # Environ 4 mois plus tard
        self.start_date.setDate(QDate(today.year, today.month, today.day))
        self.end_date.setDate(QDate(end_date.year, end_date.month, end_date.day))

        date_layout.addWidget(QLabel("Du:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("Au:"))
        date_layout.addWidget(self.end_date)
        
        # Bouton de génération
        generate_button = QPushButton("Générer le planning")
        generate_button.clicked.connect(self.generate_planning)
        generate_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #e8e8e8;
            }
        """)
        date_layout.addWidget(generate_button)
        
        date_layout.setStretchFactor(self.start_date, 2)
        date_layout.setStretchFactor(self.end_date, 2)
        date_layout.setStretchFactor(generate_button, 1)
        
        layout.addLayout(date_layout)

        # Barre de progression
        self.progress_bar = QProgressBar(self)
        layout.addWidget(self.progress_bar)

        # Créer un widget avec des onglets
        tab_widget = QTabWidget()
        
        # Vue globale du planning
        self.global_view = QTableWidget(self)
        tab_widget.addTab(self.global_view, "Vue globale")

        # Nouvelle vue du planning par médecin
        self.doctor_planning_view = DoctorPlanningView(None, self.doctors, self.cats)
        tab_widget.addTab(self.doctor_planning_view, "Planning par médecin")

        layout.addWidget(tab_widget)

    def generate_planning(self):
        start_date = self.start_date.date().toPyDate()
        end_date = self.end_date.date().toPyDate()

        if start_date > end_date:
            QMessageBox.warning(self, "Erreur", "La date de début doit être antérieure à la date de fin.")
            return

        self.progress_bar.setValue(0)
        self.generation_thread = PlanningGenerationThread(self.planning_generator, start_date, end_date)
        self.generation_thread.progress_update.connect(self.progress_bar.setValue)
        self.generation_thread.planning_generated.connect(self.planning_generated)
        self.generation_thread.start()

    def planning_generated(self, planning):
        if planning is None:
            QMessageBox.warning(self, "Erreur", "Impossible de générer le planning. Veuillez vérifier les desideratas des médecins.")
            self.progress_bar.setValue(0)
        else:
            self.planning = planning
            self.update_table()
            self.doctor_planning_view.update_view(planning, self.doctors, self.cats)
            self.progress_bar.setValue(100)
            if hasattr(self.main_window, 'comparison_view') and self.main_window.comparison_view:
                self.main_window.comparison_view.planning = planning
                self.main_window.comparison_view.update_selectors()
            self.main_window.update_data()
            
            # Afficher les desideratas non respectés
            # unrespected_desiderata = self.planning_generator.get_unrespected_desiderata()
            

    def display_constraint_analysis(self):
            if hasattr(self.planning_generator, 'pre_analyzer'):
                analysis = self.planning_generator.pre_analyzer.analyze()
                if analysis is not None and 'constraint_analysis' in analysis:
                    constraint_analysis = analysis['constraint_analysis']
                    
                    message = f"Analyse des contraintes :\n"
                    message += f"Conflits potentiels : {constraint_analysis.get('potential_conflicts', 'N/A')}\n"
                    # Ajoutez d'autres informations sur les contraintes ici
                    
                    QMessageBox.information(self, "Analyse des contraintes", message)
                else:
                    QMessageBox.warning(self, "Erreur", "L'analyse des contraintes n'est pas disponible.")
            else:
                QMessageBox.warning(self, "Erreur", "L'analyseur de pré-planning n'est pas disponible.")
                
    def update_table(self):
        if not self.planning:
            return

        self.global_view.clear()
        self.global_view.setRowCount(0)
        self.global_view.setColumnCount(5)
        self.global_view.setHorizontalHeaderLabels(["Date", "Créneau", "Type", "Site", "Assigné à"])

        weekend_color = QColor(240, 240, 240)  # Gris clair pour les week-ends, jours fériés et ponts

        for day_planning in self.planning.days:  # Changement ici
            for slot in day_planning.slots:
                row = self.global_view.rowCount()
                self.global_view.insertRow(row)
                date_item = QTableWidgetItem(day_planning.date.strftime("%Y-%m-%d"))
                self.global_view.setItem(row, 0, date_item)
                self.global_view.setItem(row, 1, QTableWidgetItem(f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}"))
                self.global_view.setItem(row, 2, QTableWidgetItem(slot.abbreviation))
                self.global_view.setItem(row, 3, QTableWidgetItem(slot.site))
                self.global_view.setItem(row, 4, QTableWidgetItem(slot.assignee or "Non attribué"))

                # Colorer la ligne si c'est un week-end, un jour férié ou un pont
                if day_planning.is_weekend or day_planning.is_holiday_or_bridge:
                    for col in range(self.global_view.columnCount()):
                        self.global_view.item(row, col).setBackground(QBrush(weekend_color))

        self.global_view.resizeColumnsToContents()
        
    def update_post_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        self.planning_generator = PlanningGenerator(self.doctors, self.cats, self.post_configuration)
        if self.planning:
            self.generate_planning()
            
    def update_data(self, doctors, cats, post_configuration):
        self.doctors = doctors
        self.cats = cats
        self.post_configuration = post_configuration
        self.planning_generator = PlanningGenerator(doctors, cats, post_configuration)
        if self.planning:
            self.update_table()
            self.doctor_planning_view.update_view(self.planning, self.doctors, self.cats)

    def update_planning(self, updated_planning):
        self.planning = updated_planning
        self.update_table()
        self.doctor_planning_view.update_view(updated_planning, self.doctors, self.cats)
        self.main_window.update_data()




# gui/post_configuration.py


# gui/post_configuration.py
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget,
                             QTableWidget, QTableWidgetItem, QLabel, QSpinBox)
from core.models import DailyPostConfiguration, PostConfig, ALL_POST_TYPES

class PostConfigurationWidget(QWidget):
    def __init__(self, post_configuration, main_window):
        super().__init__()
        self.post_configuration = post_configuration
        self.main_window = main_window
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        tab_widget = QTabWidget()
        
        # Onglet pour les médecins
        doctors_tab = QWidget()
        doctors_layout = QHBoxLayout(doctors_tab)
        for day_type, config in [
            ("weekday", self.post_configuration.weekday),
            ("saturday", self.post_configuration.saturday),
            ("sunday_holiday", self.post_configuration.sunday_holiday)
        ]:
            column_layout = QVBoxLayout()
            column_layout.addWidget(QLabel(day_type.capitalize()))
            table = self.create_config_table(config, day_type)
            column_layout.addWidget(table)
            doctors_layout.addLayout(column_layout)
        doctors_tab.setLayout(doctors_layout)
        tab_widget.addTab(doctors_tab, "Médecins")

        # Onglet pour les CAT
        cats_tab = QWidget()
        cats_layout = QHBoxLayout(cats_tab)
        for day_type, config in [
            ("cat_weekday", self.post_configuration.cat_weekday),
            ("cat_saturday", self.post_configuration.cat_saturday),
            ("cat_sunday_holiday", self.post_configuration.cat_sunday_holiday)
        ]:
            column_layout = QVBoxLayout()
            column_layout.addWidget(QLabel(day_type.replace('cat_', '').capitalize()))
            table = self.create_config_table(config, day_type)
            column_layout.addWidget(table)
            cats_layout.addLayout(column_layout)
        cats_tab.setLayout(cats_layout)
        tab_widget.addTab(cats_tab, "CAT")

        layout.addWidget(tab_widget)
        
        save_button = QPushButton("Enregistrer la configuration")
        save_button.clicked.connect(self.save_configuration)
        layout.addWidget(save_button)

    def create_config_table(self, config, day_type):
        table = QTableWidget(self)
        table.setObjectName(day_type)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Type de poste", "Nombre total"])
        
        table.setRowCount(len(ALL_POST_TYPES))
        for row, post_type in enumerate(ALL_POST_TYPES):
            table.setItem(row, 0, QTableWidgetItem(post_type))
            
            total_spin_box = QSpinBox()
            total_spin_box.setRange(0, 20)
            total_spin_box.setValue(config.get(post_type, PostConfig()).total)
            table.setCellWidget(row, 1, total_spin_box)

        table.resizeColumnsToContents()
        return table
    
    def save_configuration(self):
        for day_type, config in [
            ("weekday", self.post_configuration.weekday),
            ("saturday", self.post_configuration.saturday),
            ("sunday_holiday", self.post_configuration.sunday_holiday),
            ("cat_weekday", self.post_configuration.cat_weekday),
            ("cat_saturday", self.post_configuration.cat_saturday),
            ("cat_sunday_holiday", self.post_configuration.cat_sunday_holiday)
        ]:
            table = self.findChild(QTableWidget, day_type)
            for row in range(table.rowCount()):
                post_type = table.item(row, 0).text()
                total_count = table.cellWidget(row, 1).value()
                config[post_type] = PostConfig(total=total_count)

        # Informez la fenêtre principale que la configuration a été mise à jour
        self.main_window.update_post_configuration(self.post_configuration)
        print("Configuration sauvegardée")
        
    def update_configuration(self, new_post_configuration):
        self.post_configuration = new_post_configuration
        for day_type, config in [
            ("weekday", self.post_configuration.weekday),
            ("saturday", self.post_configuration.saturday),
            ("sunday_holiday", self.post_configuration.sunday_holiday),
            ("cat_weekday", self.post_configuration.cat_weekday),
            ("cat_saturday", self.post_configuration.cat_saturday),
            ("cat_sunday_holiday", self.post_configuration.cat_sunday_holiday)
        ]:
            table = self.findChild(QTableWidget, day_type)
            for row in range(table.rowCount()):
                post_type = table.item(row, 0).text()
                total_count = config.get(post_type, PostConfig()).total
                table.cellWidget(row, 1).setValue(total_count)


# gui/doctor_planning_view.py


# gui/doctor_planning_view.py

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QComboBox, QScrollArea
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QColor, QBrush
from datetime import date, timedelta
import calendar

class DoctorPlanningView(QWidget):
    def __init__(self, planning, doctors, cats):
        super().__init__()
        self.planning = planning
        self.doctors = doctors
        self.cats = cats
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Sélecteur de médecin/CAT
        self.selector = QComboBox()
        self.update_selector()
        self.selector.currentIndexChanged.connect(self.update_table)
        layout.addWidget(self.selector)


        # Créer une zone de défilement pour la table
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)

        # Table du planning
        self.table = QTableWidget()
        scroll_area.setWidget(self.table)

        self.setLayout(layout)

    def update_selector(self):
        self.selector.clear()
        self.selector.addItems([doctor.name for doctor in self.doctors])
        self.selector.addItems([cat.name for cat in self.cats])
        
    def update_view(self, planning, doctors, cats):
        self.planning = planning
        self.doctors = doctors
        self.cats = cats
        self.update_selector()
        self.update_table()

    def update_table(self):
        if not self.planning or not self.planning.days:
            self.clear_table()
            return

        selected_name = self.selector.currentText()
        start_date = self.planning.start_date
        end_date = self.planning.end_date

        
        # Calculer le nombre de mois
        num_months = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1

        # Configurer la table
        self.table.clear()
        self.table.setRowCount(31)  # Un mois maximum a 31 jours
        self.table.setColumnCount(1 + num_months * 2)  # 1 pour les numéros de jours + 2 colonnes par mois

        # En-têtes de colonnes
        headers = ["Jour"]
        current_date = date(start_date.year, start_date.month, 1)
        for _ in range(num_months):
            month_name = current_date.strftime("%B %Y")
            headers.extend([f"{month_name}\nJour", f"{month_name}\nPoste"])
            current_date = (current_date.replace(day=28) + timedelta(days=4)).replace(day=1)
        self.table.setHorizontalHeaderLabels(headers)

        # Remplir la table
        for day in range(1, 32):
            self.table.setItem(day - 1, 0, QTableWidgetItem(str(day)))

        weekend_color = QColor(240, 240, 240)  # Gris clair pour les week-ends, jours fériés et ponts
        desiderata_color = QColor(255, 200, 200)  # Rouge très clair pour les desiderata

        current_date = start_date
        while current_date <= end_date:
            month_col = 1 + (current_date.month - start_date.month + (current_date.year - start_date.year) * 12) * 2
            day_row = current_date.day - 1

            # Jour de la semaine
            day_item = QTableWidgetItem(current_date.strftime("%a"))
            self.table.setItem(day_row, month_col, day_item)

            # Poste attribué
            day_planning = next((day for day in self.planning.days if day.date == current_date), None)
            if day_planning:
                slots = [slot for slot in day_planning.slots if slot.assignee == selected_name]
                post = ", ".join(slot.abbreviation for slot in slots) if slots else ""
                post_item = QTableWidgetItem(post)
                self.table.setItem(day_row, month_col + 1, post_item)

                # Colorer les week-ends, jours fériés et ponts
                if day_planning.is_weekend or day_planning.is_holiday_or_bridge:
                    for col in range(month_col, month_col + 2):
                        item = self.table.item(day_row, col)
                        if item:
                            item.setBackground(QBrush(weekend_color))

                # Colorer les desiderata
                selected_person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
                if selected_person:
                    for desiderata in selected_person.desiderata:
                        if desiderata.start_date <= current_date <= desiderata.end_date:
                            for col in range(month_col, month_col + 2):
                                item = self.table.item(day_row, col)
                                if item:
                                    item.setBackground(QBrush(desiderata_color))

            current_date += timedelta(days=1)

        # Ajuster la taille des colonnes et des lignes
        self.table.resizeColumnsToContents()
        self.table.resizeRowsToContents()

        # Définir une largeur fixe pour la première colonne (numéros de jour)
        self.table.setColumnWidth(0, 40)

        self.table.verticalHeader().hide()  # Cacher l'en-tête vertical car nous avons notre propre colonne de jours

        # Empêcher l'édition des cellules
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        
    def clear_table(self):
        self.table.clear()
        self.table.setRowCount(1)
        self.table.setColumnCount(1)
        self.table.setItem(0, 0, QTableWidgetItem("Aucun planning généré"))



# gui/desiderata_management.py


# gui/desiderata_management.py

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QScrollArea, QGridLayout,
                             QTableWidget, QTableWidgetItem, QComboBox, QMessageBox, QLabel,
                             QSplitter, QHeaderView)
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QColor, QBrush
from core.models import Desiderata, Doctor, CAT
from datetime import date, timedelta
import calendar
from dateutil.relativedelta import relativedelta

class DesiderataCalendarWidget(QTableWidget):
    def __init__(self, start_date, end_date):
        super().__init__()
        self.start_date = start_date
        self.end_date = end_date
        self.init_ui()
        self.last_clicked_item = None

    def init_ui(self):
        self.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.verticalHeader().setVisible(False)
        self.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.create_calendar()
        self.cellClicked.connect(self.handle_cell_clicked)
        
    def create_calendar(self):
        months = (self.end_date.year - self.start_date.year) * 12 + self.end_date.month - self.start_date.month + 1
        self.setColumnCount(2 + months * 3)
        self.setRowCount(31)

        # Set headers
        self.setHorizontalHeaderItem(0, QTableWidgetItem("Jour"))
        self.setHorizontalHeaderItem(1, QTableWidgetItem("Sem"))

        current_date = self.start_date
        for i in range(months):
            month_name = current_date.strftime("%b")  # Utilisez %b pour l'abréviation du mois
            self.setHorizontalHeaderItem(2 + i*3, QTableWidgetItem(f"{month_name}\nM"))
            self.setHorizontalHeaderItem(3 + i*3, QTableWidgetItem(f"{month_name}\nAM"))
            self.setHorizontalHeaderItem(4 + i*3, QTableWidgetItem(f"{month_name}\nN"))
            current_date = current_date + relativedelta(months=1)

        # Fill the table
        current_date = self.start_date
        while current_date <= self.end_date:
            row = current_date.day - 1
            month_col = (current_date.year - self.start_date.year) * 12 + current_date.month - self.start_date.month
            col = 2 + month_col * 3
            print(f"Debug: Setting up date {current_date} at row {row}, col {col}")  # Debug log

            day_item = QTableWidgetItem(str(current_date.day))
            day_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.setItem(row, 0, day_item)

            weekday_item = QTableWidgetItem(current_date.strftime("%a"))
            weekday_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.setItem(row, 1, weekday_item)

            for i in range(3):
                item = QTableWidgetItem()
                item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
                item.setCheckState(Qt.CheckState.Unchecked)
                self.setItem(row, 2 + month_col*3 + i, item)

            if current_date.weekday() >= 5:  # Weekend
                for col in range(2 + month_col*3, 5 + month_col*3):
                    self.item(row, col).setBackground(QBrush(QColor(240, 240, 240)))

            current_date += timedelta(days=1)

        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        self.resizeRowsToContents()

   

    def mousePressEvent(self, event):
        item = self.itemAt(event.pos())
        if item and item.column() >= 2:
            self.last_clicked_item = item
            self.toggle_item(item)
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        item = self.itemAt(event.pos())
        if item and item.column() >= 2 and item != self.last_clicked_item:
            self.toggle_item(item)
            self.last_clicked_item = item
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        self.last_clicked_item = None
        super().mouseReleaseEvent(event)

    def handle_cell_clicked(self, row, column):
        if column >= 2:
            item = self.item(row, column)
            if item:
                self.toggle_item(item)

    def toggle_item(self, item):
        new_state = Qt.CheckState.Checked if item.checkState() == Qt.CheckState.Unchecked else Qt.CheckState.Unchecked
        item.setCheckState(new_state)

    def get_selected_desiderata(self):
        desiderata = []
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 3):
                date = self.get_date_from_cell(row, col)
                if date is None or date > self.end_date:
                    continue
                for i in range(3):
                    item = self.item(row, col + i)
                    if item and item.checkState() == Qt.CheckState.Checked:
                        print(f"Debug: Selected date: {date}, period: {i + 1}")  # Debug log
                        desiderata.append((date, i + 1))
        return desiderata

    def get_date_from_cell(self, row, col):
        month_col = (col - 2) // 3
        year = self.start_date.year + (self.start_date.month + month_col - 1) // 12
        month = (self.start_date.month + month_col - 1) % 12 + 1
        day = row + 1
        try:
            return date(year, month, day)
        except ValueError:
            return None
        
    def set_desiderata(self, desiderata):
        self.clear_all_selections()
        for date, period in desiderata:
            if self.start_date <= date <= self.end_date:
                row = date.day - 1
                month_col = (date.year - self.start_date.year) * 12 + date.month - self.start_date.month
                col = 2 + month_col * 3 + (period - 1)
                item = self.item(row, col)
                if item:
                    item.setCheckState(Qt.CheckState.Checked)

    def clear_all_selections(self):
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount()):
                item = self.item(row, col)
                if item:
                    item.setCheckState(Qt.CheckState.Unchecked)

    def get_desiderata_dict(self):
        desiderata_dict = {}
        for row in range(self.rowCount()):
            for col in range(2, self.columnCount(), 3):
                date = self.get_date_from_cell(row, col)
                if date is None or date > self.end_date:
                    continue
                for i in range(3):
                    item = self.item(row, col + i)
                    if item and item.checkState() == Qt.CheckState.Checked:
                        if date not in desiderata_dict:
                            desiderata_dict[date] = []
                        desiderata_dict[date].append(i + 1)
        return desiderata_dict
class DesiderataManagementWidget(QWidget):
    def __init__(self, doctors, cats, planning_start_date, planning_end_date, main_window):
        super().__init__()
        self.doctors = doctors
        self.cats = cats
        self.planning_start_date = planning_start_date
        self.planning_end_date = planning_end_date
        self.main_window = main_window
        self.init_ui()
    def init_ui(self):
        main_layout = QHBoxLayout(self)

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        self.person_selector = QComboBox()
        self.person_selector.addItems([doctor.name for doctor in self.doctors] + [cat.name for cat in self.cats])
        self.person_selector.currentIndexChanged.connect(self.update_calendar)
        left_layout.addWidget(self.person_selector)

        self.calendar_widget = DesiderataCalendarWidget(self.planning_start_date, self.planning_end_date)
        self.calendar_widget.setMinimumSize(800, 600)
        left_layout.addWidget(self.calendar_widget)

        button_layout = QHBoxLayout()
        save_button = QPushButton("Enregistrer les desiderata")
        save_button.clicked.connect(self.save_desiderata)
        button_layout.addWidget(save_button)

        reset_button = QPushButton("Réinitialiser les desiderata")
        reset_button.clicked.connect(self.reset_desiderata)
        button_layout.addWidget(reset_button)

        reset_all_button = QPushButton("Réinitialiser tous les desiderata")
        reset_all_button.clicked.connect(self.reset_all_desiderata)
        button_layout.addWidget(reset_all_button)

        left_layout.addLayout(button_layout)

        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)

        self.stats_label = QLabel("Statistiques d'indisponibilité:")
        right_layout.addWidget(self.stats_label)
        
        self.stats_table = QTableWidget()
        self.stats_table.setColumnCount(2)
        self.stats_table.setHorizontalHeaderLabels(["Médecin/CAT", "% d'indisponibilité"])
        right_layout.addWidget(self.stats_table)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)
        splitter.setSizes([int(self.width() * 0.7), int(self.width() * 0.3)])

        main_layout.addWidget(splitter)

        self.update_stats()
        self.update_calendar()


    def update_calendar(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            self.calendar_widget.set_desiderata([(d.start_date, d.period) for d in person.desiderata])
        else:
            self.calendar_widget.clear_all_selections()
            
    def save_desiderata(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            new_desiderata = self.calendar_widget.get_selected_desiderata()
            print(f"Debug: Selected desiderata before creation: {new_desiderata}")  # Debug log
            person.desiderata = [
                Desiderata(date, date, "Indisponibilité", period) 
                for date, period in new_desiderata
            ]
            print(f"Debug: Created desiderata: {person.desiderata}")  # Debug log
            self.update_stats()
            self.main_window.save_data()
            QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été enregistrés avec succès.")
    def reset_desiderata(self):
        selected_name = self.person_selector.currentText()
        person = next((p for p in self.doctors + self.cats if p.name == selected_name), None)
        if person:
            confirm = QMessageBox.question(self, "Confirmation", 
                                           f"Êtes-vous sûr de vouloir réinitialiser les desiderata de {person.name} ?",
                                           QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if confirm == QMessageBox.StandardButton.Yes:
                person.desiderata = []
                self.calendar_widget.clear_all_selections()
                self.update_stats()
                QMessageBox.information(self, "Succès", f"Les desiderata de {person.name} ont été réinitialisés.")

    def reset_all_desiderata(self):
        confirm = QMessageBox.question(self, "Confirmation", 
                                       "Êtes-vous sûr de vouloir réinitialiser tous les desiderata pour tous les médecins et CAT ?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            for person in self.doctors + self.cats:
                person.desiderata = []
            self.calendar_widget.clear_all_selections()
            self.update_stats()
            self.update_calendar()
            QMessageBox.information(self, "Succès", "Tous les desiderata ont été réinitialisés.")

    def update_stats(self):
        self.stats_table.setRowCount(0)
        total_days = (self.planning_end_date - self.planning_start_date).days + 1
        stats = []

        for person in self.doctors + self.cats:
            unavailable_periods = sum(1 for d in person.desiderata if d.type == "Indisponibilité")
            total_periods = total_days * 3  # 3 périodes par jour
            unavailability_percentage = (unavailable_periods / total_periods) * 100
            
            # Initialiser le pourcentage de postes non attribués à 0
            unassigned_percentage = 0
            
            # Vérifier si le planning a été généré
            if (hasattr(self.main_window, 'planning_tab') and 
                hasattr(self.main_window.planning_tab, 'planning_generator') and 
                hasattr(self.main_window.planning_tab.planning_generator, 'planning') and
                self.main_window.planning_tab.planning_generator.planning is not None):
                
                planning = self.main_window.planning_tab.planning_generator.planning
                unassigned_shifts = self.main_window.planning_tab.planning_generator.analyze_unassigned_shifts(planning)
                
                if hasattr(self.main_window.planning_tab.planning_generator, 'target_distribution'):
                    target_distribution = self.main_window.planning_tab.planning_generator.target_distribution
                    expected_shifts = sum(target_distribution[person.name][day_type][post_type] 
                                          for day_type in target_distribution[person.name] 
                                          for post_type in target_distribution[person.name][day_type])
                    if expected_shifts > 0:
                        unassigned_percentage = (sum(unassigned_shifts[person.name].values()) / expected_shifts) * 100

            stats.append((person.name, unavailability_percentage, unassigned_percentage))

        stats.sort(key=lambda x: x[1], reverse=True)

        for row, (name, unavailability_percentage, unassigned_percentage) in enumerate(stats):
            self.stats_table.insertRow(row)
            self.stats_table.setItem(row, 0, QTableWidgetItem(name))
            self.stats_table.setItem(row, 1, QTableWidgetItem(f"{unavailability_percentage:.2f}%"))
            self.stats_table.setItem(row, 2, QTableWidgetItem(f"{unassigned_percentage:.2f}%"))

        self.stats_table.setHorizontalHeaderLabels(["Nom", "% d'indisponibilité", "% de postes non attribués"])
        self.stats_table.resizeColumnsToContents()


# .vscode/settings.json

{
    "CodeGPT.apiKey": "CodeGPT Plus Beta",
    "CodeGPT.Autocomplete.enabled": false,
    "CodeGPT.Autocomplete.maxTokens": 240
}

